
Title:
Prolog
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Programming language that uses first order logic
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}This article is about the programming language. For the narrative device, see Prologue. For other uses, see Prologue (disambiguation).
.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}PrologParadigmLogicDesignedÂ byAlain Colmerauer, Robert KowalskiFirstÂ appeared1972; 50Â years agoÂ (1972)Stable releasePart 1: General core-Edition 1 (JuneÂ 1995; 26Â years agoÂ (1995-06))Part 2: Modules-Edition 1 (JuneÂ 2000; 21Â years agoÂ (2000-06))
   
Typing disciplineUntyped (its single data type is "term")Filename extensions.pl, .pro, .PWebsitePart 1: www.iso.org/standard/21413.html Part 2: www.iso.org/standard/20775.htmlMajor implementationsB-Prolog, Ciao, ECLiPSe, GNU Prolog, Poplog Prolog, P#, Quintus Prolog, SICStus, Strawberry, SWI-Prolog, Tau Prolog, tuProlog, WIN-PROLOG, XSB, YAP.DialectsISO Prolog, Edinburgh PrologInfluenced byPlannerInfluencedCHR, Clojure, Datalog, Erlang, KL0, KL1, Mercury, Oz, Strand, Visual Prolog, XSB
 Prolog at Wikibooks

Prolog is a logic programming language associated with artificial intelligence and computational linguistics.[1][2][3]
Prolog has its roots in first-order logic, a formal logic, and unlike many other programming languages, Prolog is intended primarily as a declarative programming language: the program logic is expressed in terms of relations, represented as facts and rules.  A computation is initiated by running a query over these relations.[4]
The language was developed and implemented in Marseille, France, in 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses.[5][6]
Prolog was one of the first logic programming languages[7] and remains the most popular such language today, with several free and commercial implementations available. The language has been used for theorem proving,[8] expert systems,[9] term rewriting,[10] type systems,[11] and automated planning,[12] as well as its original intended field of use, natural language processing.[13][14]  Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications.
Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates.

Contents

1 Syntax and semantics

1.1 Data types
1.2 Rules and facts
1.3 Execution
1.4 Loops and recursion
1.5 Negation


2 Programming in Prolog

2.1 Hello World
2.2 Compiler optimization
2.3 Quicksort


3 Design patterns of Prolog
4 Higher-order programming
5 Modules
6 Parsing
7 Meta-interpreters and reflection
8 Turing completeness
9 Implementation

9.1 ISO Prolog
9.2 Compilation
9.3 Tail recursion
9.4 Term indexing
9.5 Hashing
9.6 Tabling
9.7 Implementation in hardware


10 Limitations
11 Extensions

11.1 Types
11.2 Modes
11.3 Constraints
11.4 Object-orientation
11.5 Graphics
11.6 Concurrency
11.7 Web programming
11.8 Adobe Flash
11.9 Other


12 Interfaces to other languages
13 History
14 Use in industry
15 See also

15.1 Related languages


16 References
17 Further reading



Syntax and semantics[edit]
Main article: Prolog syntax and semantics
In Prolog, program logic is expressed in terms of relations, and a computation is initiated by running a query over these relations.  Relations and queries are constructed using Prolog's single data type, the term.[4] Relations are defined by clauses.  Given a query, the Prolog engine attempts to find a resolution refutation of the negated query. If the negated query can be refuted, i.e., an instantiation for all free variables is found that makes the union of clauses and the singleton set consisting of the negated query false, it follows that the original query, with the found instantiation applied, is a logical consequence of the program. This makes Prolog (and other logic programming languages) particularly useful for database, symbolic mathematics, and language parsing applications.  Because Prolog allows impure predicates, checking the truth value of certain special predicates may have some deliberate side effect, such as printing a value to the screen.  Because of this, the programmer is permitted to use some amount of conventional imperative programming when the logical paradigm is inconvenient.  It has a purely logical subset, called "pure Prolog", as well as a number of extralogical features.

Data types[edit]
Prolog's single data type is the term. Terms are either atoms, numbers, variables or compound terms.

An atom is a general-purpose name with no inherent meaning.  Examples of atoms include x, red, 'Taco', and 'some atom'.
Numbers can be floats or integers. ISO standard compatible Prolog systems can check the Prolog flag "bounded". Most of the major Prolog systems support arbitrary length integer numbers.
Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms.
A compound term is composed of an atom called a "functor" and a number of "arguments", which are again terms.  Compound terms are ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses.  The number of arguments is called the term's arity.  An atom can be regarded as a compound term with arity zero. An example of a compound term is person_friends(zelda,[tom,jim]).
Special cases of compound terms:

A List is an ordered collection of terms.  It is denoted by square brackets with the terms separated by commas, or in the case of the empty list, by []. For example, [1,2,3] or [red,green,blue].
Strings: A sequence of characters surrounded by quotes is equivalent to either a list of (numeric) character codes, a list of characters (atoms of length 1), or an atom depending on the value of the Prolog flag double_quotes. For example, "to be, or not to be".[15]
ISO Prolog provides the atom/1, number/1, integer/1, and float/1 predicates for type-checking.[16]

Rules and facts[edit]
Prolog programs describe relations, defined by means of clauses. Pure Prolog is restricted to Horn clauses.  There are two types of clauses: facts and rules.  A rule is of the form

Head :- Body.

and is read as "Head is true if Body is true". A rule's body consists of calls to predicates, which are called the rule's goals. The built-in logical operator ,/2 (meaning an arity 2 operator with name ,) denotes conjunction of goals, and ;/2 denotes disjunction.  Conjunctions and disjunctions can only appear in the body, not in the head of a rule.
Clauses with empty bodies are called facts.  An example of a fact is:

cat(crookshanks).

which is equivalent to the rule:

cat(crookshanks) :- true.

The built-in predicate true/0 is always true.
Given the above fact, one can ask:
is crookshanks a cat?

 ?- cat(crookshanks).
 Yes

what things are cats?

 ?- cat(X).
 X = crookshanks

Clauses with bodies are called rules.  An example of a rule is:

animal(X) :- cat(X).

If we add that rule and ask what things are animals?

 ?- animal(X).
 X = crookshanks

Due to the relational nature of many built-in predicates, they can typically be used in several directions. For example, length/2 can be used to determine the length of a list (length(List, L), given a list List) as well as to generate a list skeleton of a given length (length(X, 5)), and also to generate both list skeletons and their lengths together (length(X, L)).  Similarly, append/3 can be used both to append two lists (append(ListA, ListB, X) given lists ListA and ListB) as well as to split a given list into parts (append(X, Y, List), given a list List).  For this reason, a comparatively small set of library predicates suffices for many Prolog programs.
As a general purpose language, Prolog also provides various built-in predicates to perform routine activities like input/output, using graphics and otherwise communicating with the operating system. These predicates are not given a relational meaning and are only useful for the side-effects they exhibit on the system. For example, the predicate write/1 displays a term on the screen.

Execution[edit]
Execution of a Prolog program is initiated by the user's posting of a single goal, called the query. Logically, the Prolog engine tries to find a resolution refutation of the negated query. The resolution method used by Prolog is called SLD resolution. If the negated query can be refuted, it follows that the query, with the appropriate variable bindings in place, is a logical consequence of the program. In that case, all generated variable bindings are reported to the user, and the query is said to have succeeded. Operationally, Prolog's execution strategy can be thought of as a generalization of function calls in other languages, one difference being that multiple clause heads can match a given call. In that case, the system creates a choice-point, unifies the goal with the clause head of the first alternative, and continues with the goals of that first alternative. If any goal fails in the course of executing the program, all variable bindings that were made since the most recent choice-point was created are undone, and execution continues with the next alternative of that choice-point. This execution strategy is called chronological backtracking. For example:

mother_child(trude, sally).
 
father_child(tom, sally).
father_child(tom, erica).
father_child(mike, tom).
 
sibling(X, Y)      :- parent_child(Z, X), parent_child(Z, Y).
 
parent_child(X, Y) :- father_child(X, Y).
parent_child(X, Y) :- mother_child(X, Y).

This results in the following query being evaluated as true:

 ?- sibling(sally, erica).
 Yes

This is obtained as follows: Initially, the only matching clause-head for the query sibling(sally, erica) is the first one, so proving the query is equivalent to proving the body of that clause with the appropriate variable bindings in place, i.e., the conjunction (parent_child(Z,sally), parent_child(Z,erica)). The next goal to be proved is the leftmost one of this conjunction, i.e., parent_child(Z, sally). Two clause heads match this goal. The system creates a choice-point and tries the first alternative, whose body is father_child(Z, sally). This goal can be proved using the fact father_child(tom, sally), so the binding Z = tom is generated, and the next goal to be proved is the second part of the above conjunction: parent_child(tom, erica). Again, this can be proved by the corresponding fact. Since all goals could be proved, the query succeeds. Since the query contained no variables, no bindings are reported to the user. A query with variables, like:

?- father_child(Father, Child).

enumerates all valid answers on backtracking.
Notice that with the code as stated above, the query ?- sibling(sally, sally). also succeeds. One would insert additional goals to describe the relevant restrictions, if desired.

Loops and recursion[edit]
Iterative algorithms can be implemented by means of recursive predicates.[17]

Negation[edit]
The built-in Prolog predicate \+/1 provides negation as failure, which allows for non-monotonic reasoning. The goal \+ illegal(X) in the rule

legal(X) :- \+ illegal(X).

is evaluated as follows: Prolog attempts to prove illegal(X). If a proof for that goal can be found, the original goal (i.e., \+ illegal(X)) fails. If no proof can be found, the original goal succeeds. Therefore, the \+/1 prefix operator is called the "not provable" operator, since the query ?- \+ Goal. succeeds if Goal is not provable. This kind of negation is sound if its argument is "ground" (i.e. contains no variables). Soundness is lost if the argument contains variables and the proof procedure is complete. In particular, the query ?- legal(X). now cannot be used to enumerate all things that are legal.

Programming in Prolog[edit]
In Prolog, loading code is referred to as consulting.  Prolog can be used interactively by entering queries at the Prolog prompt ?-.  If there is no solution, Prolog writes no.  If a solution exists then it is printed.  If there are multiple solutions to the query, then these can be requested by entering a semi-colon ;.  There are guidelines on good programming practice to improve code efficiency, readability and maintainability.[18]
Here follow some example programs written in Prolog.

Hello World[edit]
An example of a query:

?- write('Hello World!'), nl.
Hello World!
true.

?-

Compiler optimization[edit]
Any computation can be expressed declaratively as a sequence of state transitions.  As an example, an optimizing compiler with three optimization passes could be implemented as a relation between an initial program and its optimized form:

program_optimized(Prog0, Prog) :-
    optimization_pass_1(Prog0, Prog1),
    optimization_pass_2(Prog1, Prog2),
    optimization_pass_3(Prog2, Prog).

or equivalently using DCG notation:

program_optimized --> optimization_pass_1, optimization_pass_2, optimization_pass_3.

Quicksort[edit]
The quicksort sorting algorithm, relating a list to its sorted version:

partition([], _, [], []).
partition([X|Xs], Pivot, Smalls, Bigs) :-
    (   X @< Pivot ->
        Smalls = [X|Rest],
        partition(Xs, Pivot, Rest, Bigs)
    ;   Bigs = [X|Rest],
        partition(Xs, Pivot, Smalls, Rest)
    ).
 
quicksort([])     --> [].
quicksort([X|Xs]) -->
    { partition(Xs, X, Smaller, Bigger) },
    quicksort(Smaller), [X], quicksort(Bigger).

Design patterns of Prolog[edit]
A design pattern is a general reusable solution to a commonly occurring problem in software design.  Some design patterns in Prolog are skeletons, techniques,[19][20] cliches,[21] program schemata,[22] logic description schemata,[23] and higher order programming.[24]

Higher-order programming[edit]
Main articles: Higher-order logic and Higher-order programming
A higher-order predicate is a predicate that takes one or more other predicates as arguments.  Although support for higher-order programming takes Prolog outside the domain of first-order logic, which does not allow quantification over predicates,[25] ISO Prolog now has some built-in higher-order predicates such as call/1, call/2, call/3, findall/3, setof/3, and bagof/3.[26]  Furthermore, since arbitrary Prolog goals can be constructed and evaluated at run-time, it is easy to write higher-order predicates like maplist/2, which applies an arbitrary predicate to each member of a given list, and sublist/3, which filters elements that satisfy a given predicate, also allowing for currying.[24]
To convert solutions from temporal representation (answer substitutions on backtracking) to spatial representation (terms), Prolog has various all-solutions predicates that collect all answer substitutions of a given query in a list. This can be used for list comprehension. For example, perfect numbers equal the sum of their proper divisors:

 perfect(N) :-
     between(1, inf, N), U is N // 2,
     findall(D, (between(1,U,D), N mod D =:= 0), Ds),
     sumlist(Ds, N).

This can be used to enumerate perfect numbers, and also to check whether a number is perfect.
As another example, the predicate maplist applies a predicate P to all corresponding positions in a pair of lists:

maplist(_, [], []).
maplist(P, [X|Xs], [Y|Ys]) :-
   call(P, X, Y),
   maplist(P, Xs, Ys).

When P is a predicate that for all X, P(X,Y) unifies Y with a single unique value, maplist(P, Xs, Ys) is equivalent to applying the map function in functional programming as Ys = map(Function, Xs).
Higher-order programming style in Prolog was pioneered in HiLog and Î»Prolog.

Modules[edit]
For programming in the large, Prolog provides a module system.  The module system is standardised by ISO.[27]  However, not all Prolog compilers support modules, and there are compatibility problems between the module systems of the major Prolog compilers.[28] Consequently, modules written on one Prolog compiler will not necessarily work on others.

Parsing[edit]
Main articles: Prolog syntax and semantics Â§Â Definite clause grammars, and Definite clause grammar
There is a special notation called definite clause grammars (DCGs). A rule defined via -->/2 instead of :-/2 is expanded by the preprocessor (expand_term/2, a facility analogous to macros in other languages) according to a few straightforward rewriting rules, resulting in ordinary Prolog clauses. Most notably, the rewriting equips the predicate with two additional arguments, which can be used to implicitly thread state around,[clarification needed] analogous to monads in other languages. DCGs are often used to write parsers or list generators, as they also provide a convenient interface to difference lists.

Meta-interpreters and reflection[edit]
Prolog is a homoiconic language and provides many facilities for reflection. Its implicit execution strategy makes it possible to write a concise meta-circular evaluator (also called meta-interpreter) for pure Prolog code:

solve(true).
solve((Subgoal1,Subgoal2)) :- 
    solve(Subgoal1),
    solve(Subgoal2).
solve(Head) :- 
    clause(Head, Body),
    solve(Body).

where true represents an empty conjunction, and clause(Head, Body) unifies with clauses in the database of the form HeadÂ :- Body.
Since Prolog programs are themselves sequences of Prolog terms (:-/2 is an infix operator) that are easily read and inspected using built-in mechanisms (like read/1), it is possible to write customized interpreters that augment Prolog with domain-specific features. For example, Sterling and Shapiro present a meta-interpreter that performs reasoning with uncertainty, reproduced here with slight modifications:[29]:â330â

solve(true, 1) :- !.
solve((Subgoal1,Subgoal2), Certainty) :-
    !,
    solve(Subgoal1, Certainty1),
    solve(Subgoal2, Certainty2),
    Certainty is min(Certainty1, Certainty2).
solve(Goal, 1) :-
    builtin(Goal), !, 
    Goal.
solve(Head, Certainty) :-
    clause_cf(Head, Body, Certainty1),
    solve(Body, Certainty2),
    Certainty is Certainty1 * Certainty2.

This interpreter uses a table of built-in Prolog predicates of the form[29]:â327â

builtin(A is B).
builtin(read(X)).
% etc.

and clauses represented as clause_cf(Head, Body, Certainty). Given those, it can be called as solve(Goal, Certainty) to execute Goal and obtain a measure of certainty about the result.

Turing completeness[edit]
Pure Prolog is based on a subset of first-order predicate logic, Horn clauses, which is Turing-complete.  Turing completeness of Prolog can be shown by using it to simulate a Turing machine:

turing(Tape0, Tape) :-
    perform(q0, [], Ls, Tape0, Rs),
    reverse(Ls, Ls1),
    append(Ls1, Rs, Tape).
 
perform(qf, Ls, Ls, Rs, Rs) :- !.
perform(Q0, Ls0, Ls, Rs0, Rs) :-
    symbol(Rs0, Sym, RsRest),
    once(rule(Q0, Sym, Q1, NewSym, Action)),
    action(Action, Ls0, Ls1, [NewSym|RsRest], Rs1),
    perform(Q1, Ls1, Ls, Rs1, Rs).
 
symbol([], b, []).
symbol([Sym|Rs], Sym, Rs).
 
action(left, Ls0, Ls, Rs0, Rs) :- left(Ls0, Ls, Rs0, Rs).
action(stay, Ls, Ls, Rs, Rs).
action(right, Ls0, [Sym|Ls0], [Sym|Rs], Rs).
 
left([], [], Rs0, [b|Rs0]).
left([L|Ls], Ls, Rs, [L|Rs]).

A simple example Turing machine is specified by the facts:

rule(q0, 1, q0, 1, right).
rule(q0, b, qf, 1, stay).

This machine performs incrementation by one of a number in unary encoding: It loops over any number of "1" cells and appends an additional "1" at the end. Example query and result:

?- turing([1,1,1], Ts).
Ts = [1, 1, 1, 1] ;

This illustrates how any computation can be expressed declaratively as a sequence of state transitions, implemented in Prolog as a relation between successive states of interest.

Implementation[edit]
Further information: Comparison of Prolog implementations
ISO Prolog[edit]
The ISO Prolog standard consists of two parts. ISO/IEC 13211-1,[26][30] published in 1995, aims to standardize the existing practices of the many implementations of the core elements of Prolog. It has clarified aspects of the language that were previously ambiguous and leads to portable programs. There are three corrigenda: Cor.1:2007,[31] Cor.2:2012,[32] and Cor.3:2017.[33] ISO/IEC 13211-2,[26] published in 2000, adds support for modules to the standard. The standard is maintained by the ISO/IEC JTC1/SC22/WG17[34] working group. ANSI X3J17 is the US Technical Advisory Group for the standard.[35]

Compilation[edit]
For efficiency, Prolog code is typically compiled to abstract machine code, often influenced by the register-based Warren Abstract Machine (WAM) instruction set.[36] Some implementations employ abstract interpretation to derive type and mode information of predicates at compile time, or compile to real machine code for high performance.[37] Devising efficient implementation methods for Prolog code is a field of active research in the logic programming community, and various other execution methods are employed in some implementations. These include clause binarization and stack-based virtual machines.[citation needed]

Tail recursion[edit]
Prolog systems typically implement a well-known optimization method called tail call optimization (TCO) for deterministic predicates exhibiting tail recursion or, more generally, tail calls: A clause's stack frame is discarded before performing a call in a tail position. Therefore, deterministic tail-recursive predicates are executed with constant stack space, like loops in other languages.

Term indexing[edit]
Main article: Term indexing
Finding clauses that are unifiable with a term in a query is linear in the number of clauses. Term indexing uses a data structure that enables sub-linear-time lookups.[38]  Indexing only affects program performance, it does not affect semantics. Most Prologs only use indexing on the first term, as indexing on all terms is expensive, but techniques based on field-encoded words or superimposed codewords provide fast indexing across the full query and head.[39][40]

Hashing[edit]
Some Prolog systems, such as WIN-PROLOG and SWI-Prolog, now implement hashing to help handle large datasets more efficiently. This tends to yield very large performance gains when working with large corpora such as WordNet.

Tabling[edit]
Some Prolog systems, (B-Prolog, XSB, SWI-Prolog, YAP, and Ciao), implement a memoization method called tabling, which frees the user from manually storing intermediate results. Tabling is a spaceâtime tradeoff; execution time can be reduced by using more memory to store intermediate results:[41][42]

Subgoals encountered in a query evaluation are maintained in a table, along with answers to these subgoals. If a subgoal is re-encountered, the evaluation reuses information from the table rather than re-performing resolution against program clauses.[43]
Tabling can be extended in various directions. It can support recursive predicates through SLG-resolution or linear tabling. In a multi-threaded Prolog system tabling results could be kept private to a thread or shared among all threads. And in incremental tabling, tabling might react to changes.

Implementation in hardware[edit]
During the Fifth Generation Computer Systems project, there were attempts to implement Prolog in hardware with the aim of achieving faster execution with dedicated architectures.[44][45][46]  Furthermore, Prolog has a number of properties that may allow speed-up through parallel execution.[47]  A more recent approach has been to compile restricted Prolog programs to a field programmable gate array.[48]  However, rapid progress in general-purpose hardware has consistently overtaken more specialised architectures.
Sega implemented Prolog for use with the Sega AI Computer, released for the Japanese market in 1986. Prolog was used for reading natural language inputs, in the Japanese language, via a touch pad.[49]

Limitations[edit]
Although Prolog is widely used in research and education,[citation needed] Prolog and other logic programming languages have not had a significant impact on the computer industry in general.[50]  Most applications are small by industrial standards, with few exceeding 100,000 lines of code.[50][51] Programming in the large is considered to be complicated because not all Prolog compilers support modules, and there are compatibility problems between the module systems of the major Prolog compilers.[28]  Portability of Prolog code across implementations has also been a problem, but developments since 2007 have meant: "the portability within the family of Edinburgh/Quintus derived Prolog implementations is good enough to allow for maintaining portable real-world applications."[52]
Software developed in Prolog has been criticised for having a high performance penalty compared to conventional programming languages. In particular, Prolog's non-deterministic evaluation strategy can be problematic when programming deterministic computations, or when even using "don't care non-determinism" (where a single choice is made instead of backtracking over all possibilities). Cuts and other language constructs may have to be used to achieve desirable performance, destroying one of Prolog's main attractions, the ability to run programs "backwards and forwards".[53]
Prolog is not purely declarative: because of constructs like the cut operator, a procedural reading of a Prolog program is needed to understand it.[54] The order of clauses in a Prolog program is significant, as the execution strategy of the language depends on it.[55] Other logic programming languages, such as Datalog, are truly declarative but restrict the language. As a result, many practical Prolog programs are written to conform to Prolog's depth-first search order, rather than as purely declarative logic programs.[53]

Extensions[edit]
Various implementations have been developed from Prolog to extend logic programming capabilities in numerous directions.  These include types, modes, constraint logic programming (CLP), object-oriented logic programming (OOLP), concurrency, linear logic (LLP), functional and higher-order logic programming capabilities, plus interoperability with knowledge bases:

Types[edit]
Prolog is an untyped language.  Attempts to introduce types date back to the 1980s,[56][57] and as of 2008 there are still attempts to extend Prolog with types.[58]  Type information is useful not only for type safety but also for reasoning about Prolog programs.[59]

Modes[edit]



Mode specifier

Interpretation


+

nonvar on entry


-

var on entry


?

Not specified

The syntax of Prolog does not specify which arguments of a predicate are inputs and which are outputs.[60] However, this information is significant and it is recommended that it be included in the comments.[61] Modes provide valuable information when reasoning about Prolog programs[59] and can also be used to accelerate execution.[62]

Constraints[edit]
Constraint logic programming extends Prolog to include concepts from constraint satisfaction.[63][64] A constraint logic program allows constraints in the body of clauses, such as: A(X,Y)Â :- X+Y>0.  It is suited to large-scale combinatorial optimisation problems[65] and is thus useful for applications in industrial settings, such as automated time-tabling and production scheduling. Most Prolog systems ship with at least one constraint solver for finite domains, and often also with solvers for other domains like rational numbers.

Object-orientation[edit]
Flora-2 is an object-oriented knowledge representation and reasoning system based on F-logic and incorporates HiLog, Transaction logic, and defeasible reasoning.
Logtalk is an object-oriented logic programming language that can use most Prolog implementations as a back-end compiler. As a multi-paradigm language, it includes support for both prototypes and classes.
Oblog is a small, portable, object-oriented extension to Prolog by Margaret McDougall of EdCAAD, University of Edinburgh.
Objlog was a frame-based language combining objects and Prolog II from CNRS, Marseille, France.
Prolog++ was developed by Logic Programming Associates and first released in 1989 for MS-DOS PCs. Support for other platforms was added, and a second version was released in 1995. A book about Prolog++ by Chris Moss was published by Addison-Wesley in 1994.
Visual Prolog is a multi-paradigm language with interfaces, classes, implementations and object expressions.

Graphics[edit]
Prolog systems that provide a graphics library are SWI-Prolog,[66] Visual Prolog, WIN-PROLOG, and B-Prolog.

Concurrency[edit]
Prolog-MPI is an open-source SWI-Prolog extension for distributed computing over the Message Passing Interface.[67] Also there are various concurrent Prolog programming languages.[68]

Web programming[edit]
Some Prolog implementations, notably Visual Prolog, SWI-Prolog and Ciao, support server-side web programming with support for web protocols, HTML and XML.[69]  There are also extensions to support semantic web formats such as RDF and OWL.[70][71]  Prolog has also been suggested as a client-side language.[72]  In addition Visual Prolog supports JSON-RPC and Websockets.

Adobe Flash[edit]
Cedar is a free and basic Prolog interpreter. From version 4 and above Cedar has a FCA (Flash Cedar App) support. This provides a new platform to programming in Prolog through ActionScript.

Other[edit]
F-logic extends Prolog with frames/objects for knowledge representation.
Transaction logic extends Prolog with a logical theory of state-changing update operators. It has both a model-theoretic and procedural semantics.
OW Prolog has been created in order to answer Prolog's lack of graphics and interface.
Interfaces to other languages[edit]
Frameworks exist which can bridge between Prolog and other languages:

The LPA Intelligence Server allows the embedding of LPA Prolog for Windows  within C, C#, C++, Java, VB, Delphi, .Net, Lua, Python and other languages. It exploits the dedicated string data-type which LPA Prolog provides
The Logic Server API allows both the extension and embedding of Prolog in C, C++, Java, VB, Delphi, .NET and any language/environment which can call a .dll or .so.  It is implemented for Amzi! Prolog Amzi! Prolog + Logic Server but the API specification can be made available for any implementation.
JPL is a bi-directional Java Prolog bridge which ships with SWI-Prolog by default, allowing Java and Prolog to call each other (recursively).  It is known to have good concurrency support and is under active development.
InterProlog, a programming library bridge between Java and Prolog, implementing bi-directional predicate/method calling between both languages. Java objects can be mapped into Prolog terms and vice versa. Allows the development of GUIs and other functionality in Java while leaving logic processing in the Prolog layer. Supports XSB, with support for SWI-Prolog and YAP planned for 2013.
Prova provides native syntax integration with Java, agent messaging and reaction rules. Prova positions itself as a rule-based scripting (RBS) system for middleware. The language breaks new ground in combining imperative and declarative programming.
PROL An embeddable Prolog engine for Java. It includes a small IDE and a few libraries.
GNU Prolog for Java is an implementation of ISO Prolog as a Java library (gnu.prolog)
Ciao provides interfaces to C, C++, Java, and relational databases.
C#-Prolog is a Prolog interpreter written in (managed) C#. Can easily be integrated in C# programs. Characteristics: reliable and fairly fast interpreter, command line interface, Windows-interface, builtin DCG, XML-predicates, SQL-predicates, extendible. The complete source code is available, including a parser generator that can be used for adding special purpose extensions.
A Warren Abstract Machine for PHP A Prolog compiler and interpreter in PHP 5.3. A library that can be used standalone or within Symfony2.1 framework which was translated from Stephan Buettcher's work in Java which can be found [here stefan.buettcher.org/cs/wam/index.html]
tuProlog is a light-weight Prolog system for distributed applications and infrastructures, intentionally designed around a minimal core, to be either statically or dynamically configured by loading/unloading libraries of predicates. tuProlog natively supports multi-paradigm programming, providing a clean, seamless integration model between Prolog and mainstream object-oriented languagesânamely Java, for tuProlog Java version, and any .NET-based language (C#, F#..), for tuProlog .NET version.[73]
History[edit]
The name Prolog was chosen by Philippe Roussel as an abbreviation for programmation en logique (French for programming in logic).  It was created around 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses.  It was motivated in part by the desire to reconcile the use of logic as a declarative knowledge representation language with the procedural representation of knowledge that was popular in North America in the late 1960s and early 1970s.  According to Robert Kowalski, the first Prolog system was developed in 1972 by Colmerauer and Phillipe Roussel.[5] The first implementation of Prolog was an interpreter written in Fortran by Gerard Battani and Henri Meloni. David H. D. Warren took this interpreter to Edinburgh, and there implemented an alternative front-end, which came to define the âEdinburgh Prologâ syntax used by most modern implementations.  Warren also implemented the first compiler for Prolog, creating the influential DEC-10 Prolog in collaboration with Fernando Pereira.  Warren later generalised the ideas behind DEC-10 Prolog, to create the Warren Abstract Machine.
European AI researchers favored Prolog while Americans favored Lisp, reportedly causing many nationalistic debates on the merits of the languages.[74] Much of the modern development of Prolog came from the impetus of the Fifth Generation Computer Systems project (FGCS), which developed a variant of Prolog named Kernel Language for its first operating system.
Pure Prolog was originally restricted to the use of a resolution theorem prover with Horn clauses of the form:

HÂ :- B1, ..., Bn.

The application of the theorem-prover treats such clauses as procedures:

to show/solve H, show/solve B1 and ... and Bn.

Pure Prolog was soon extended, however, to include negation as failure, in which negative conditions of the form not(Bi) are shown by trying and failing to solve the corresponding positive conditions Bi.
Subsequent extensions of Prolog by the original team introduced constraint logic programming abilities into the implementations.

Use in industry[edit]
Prolog has been used in Watson. Watson uses IBM's DeepQA software and the Apache UIMA (Unstructured Information Management Architecture) framework. The system was written in various languages, including Java, C++, and Prolog, and runs on the SUSE Linux Enterprise Server 11 operating system using Apache Hadoop framework to provide distributed computing. Prolog is used for pattern matching over natural language parse trees. The developers have stated: "We required a language in which we could conveniently express pattern matching rules over the parse trees and other annotations (such as named entity recognition results), and a technology that could execute these rules very efficiently. We found that Prolog was the ideal choice for the language due to its simplicity and expressiveness."[14] Prolog is being used in the Low-Code Development Platform GeneXus, which is focused around AI.[75][circular reference] Open source graph database TerminusDB is implemented in prolog.[76] TerminusDB is designed for collaboratively building and curating knowledge graphs.

See also[edit]
Comparison of Prolog implementations
Logico-linguistic modeling. A method for building knowledge-based system that uses Prolog.
Answer set programming. A fully declarative approach to logic programming.
Association for Logic Programming
Related languages[edit]
The GÃ¶del language is a strongly typed implementation of concurrent constraint logic programming. It is built on SICStus Prolog.
Visual Prolog, formerly known as PDC Prolog and Turbo Prolog, is a strongly typed object-oriented dialect of Prolog, which is very different from standard Prolog.  As Turbo Prolog, it was marketed by Borland, but it is now developed and marketed by the Danish firm PDC (Prolog Development Center) that originally produced it.
Datalog is a subset of Prolog.  It is limited to relationships that may be stratified and does not allow compound terms. In contrast to Prolog, Datalog is not Turing-complete.
Mercury is an offshoot of Prolog geared toward software engineering in the large with a static, polymorphic type system, as well as a mode and determinism system.
GraphTalk is a proprietary implementation of Warren's Abstract Machine, with additional object-oriented properties.
In some ways[which?] Prolog is a subset of Planner.  The ideas in Planner were later further developed in the Scientific Community Metaphor.
AgentSpeak is a variant of Prolog for programming agent behavior in multi-agent systems.
Erlang began life with a Prolog-based implementation and maintains much of Prolog's unification-based syntax.
Pilog is a declarative language built on top of PicoLisp, that has the semantics of Prolog, but uses the syntax of Lisp.
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Clocksin, William F.; Mellish, Christopher S. (2003). Programming in Prolog. Berlin; New York: Springer-Verlag. ISBNÂ 978-3-540-00678-7.

^ Bratko, Ivan (2012). Prolog programming for artificial intelligence (4thÂ ed.). Harlow, England; New York: Addison Wesley. ISBNÂ 978-0-321-41746-6.

^ Covington, Michael A. (1994). Natural language processing for Prolog programmers. Englewood Cliffs, N.J.: Prentice Hall. ISBNÂ 978-0-13-629213-5.

^ Jump up to: a b Lloyd, J. W. (1984). Foundations of logic programming. Berlin: Springer-Verlag. ISBNÂ 978-3-540-13299-8.

^ Jump up to: a b Kowalski, R. A. (1988). "The early years of logic programming" (PDF). Communications of the ACM. 31: 38. doi:10.1145/35043.35046. S2CIDÂ 12259230.

^ Colmerauer, A.; Roussel, P. (1993). "The birth of Prolog" (PDF). ACM SIGPLAN Notices. 28 (3): 37. doi:10.1145/155360.155362.

^ See Logic programming Â§Â History.

^ Stickel, M. E. (1988). "A prolog technology theorem prover: Implementation by an extended prolog compiler". Journal of Automated Reasoning. 4 (4): 353â380. CiteSeerXÂ 10.1.1.47.3057. doi:10.1007/BF00297245. S2CIDÂ 14621218.

^ Merritt, Dennis (1989). Building expert systems in Prolog. Berlin: Springer-Verlag. ISBNÂ 978-0-387-97016-5.

^ Felty, Amy. "A logic programming approach to implementing higher-order term rewriting." Extensions of Logic Programming (1992): 135-161.

^ Kent D. Lee (19 January 2015). Foundations of Programming Languages. Springer. pp.Â 298â. ISBNÂ 978-3-319-13314-0.

^ Ute Schmid (21 August 2003). Inductive Synthesis of Functional Programs: Universal Planning, Folding of Finite Programs, and Schema Abstraction by Analogical Reasoning. Springer Science & Business Media. ISBNÂ 978-3-540-40174-2.

^ Fernando C. N. Pereira; Stuart M. Shieber (2005). Prolog and Natural Language Analysis. Microtome.

^ Jump up to: a b Adam Lally; Paul Fodor (31 March 2011). "Natural Language Processing With Prolog in the IBM Watson System". Association for Logic Programming. See also Watson (computer).

^ ISO/IEC 13211-1:1995 Prolog, 6.3.7 Terms - double quoted list notation. International Organization for Standardization, Geneva.

^ "Verify Type of a Term - SWI-Prolog".

^ Carlsson, Mats (27 May 2014). SICStus Prolog User's Manual 4.3: Core reference documentation. BoD â Books on Demand. ISBNÂ 9783735737441 â via Google Books.

^ Covington, Michael A.; Bagnara, Roberto; O'Keefe, Richard A.; Wielemaker, Jan; Price, Simon (2011). "Coding guidelines for Prolog". Theory and Practice of Logic Programming. 12 (6): 889â927. arXiv:0911.2899. doi:10.1017/S1471068411000391. S2CIDÂ 438363.

^ Kirschenbaum, M.; Sterling, L.S. (1993). "Applying Techniques to Skeletons". Constructing Logic Programs, (Ed. J.M.J. Jacquet): 27â140. CiteSeerXÂ 10.1.1.56.7278.

^ Sterling, Leon (2002). "Patterns for Prolog Programming". Computational Logic: Logic Programming and Beyond. Lecture Notes in Computer Science / Lecture Notes in Artificial Intelligence. Vol.Â 2407. pp.Â 17â26. doi:10.1007/3-540-45628-7_15. ISBNÂ 978-3-540-43959-2.

^ D. Barker-Plummer. Cliche programming in Prolog. In M. Bruynooghe, editor, Proc. Second Workshop on Meta-Programming in Logic, pages 247--256. Dept. of Comp. Sci., Katholieke Univ. Leuven, 1990.

^ Gegg-harrison, T. S. (1995). Representing Logic Program Schemata in Prolog. Procs Twelfth International Conference on Logic Programming. pp.Â 467â481.

^ Deville, Yves (1990). Logic programming: systematic program development. Wokingham, England: Addison-Wesley. ISBNÂ 978-0-201-17576-9.

^ Jump up to: a b Naish, Lee (1996). Higher-order logic programming in Prolog (Report). Department of Computer Science, University of Melbourne. CiteSeerXÂ 10.1.1.35.4505.

^ "With regard to Prolog variables, variables only in the head are implicitly universally quantified, and those only in the body are implicitly existentially quantified". Retrieved 2013-05-04.

^ Jump up to: a b c ISO/IEC 13211: Information technology â Programming languages â Prolog. International Organization for Standardization, Geneva.

^ ISO/IEC 13211-2: Modules.

^ Jump up to: a b Moura, Paulo (August 2004), "Logtalk", Association of Logic Programming, 17 (3)

^ Jump up to: a b Shapiro, Ehud Y.; Sterling, Leon (1994). The Art of Prolog: Advanced Programming Techniques. Cambridge, Massachusetts: MIT Press. ISBNÂ 978-0-262-19338-2.

^ A. Ed-Dbali; Deransart, Pierre; L. Cervoni (1996). Prolog: the standard: reference manual. Berlin: Springer. ISBNÂ 978-3-540-59304-1.

^ "ISO/IEC 13211-1:1995/Cor 1:2007 -".

^ "ISO/IEC 13211-1:1995/Cor 2:2012 -".

^ "ISO/IEC 13211-1:1995/Cor 3:2017 -".

^ "ISO/IEC JTC1 SC22 WG17".[permanent dead link]

^ "X3J17 and the Prolog Standard". Archived from the original on 2009-08-23. Retrieved 2009-10-02.

^ David H. D. Warren. "An abstract Prolog instruction set". Technical Note 309, SRI International, Menlo Park, CA, October 1983.

^ Van Roy, P.; Despain, A. M. (1992). "High-performance logic programming with the Aquarius Prolog compiler". Computer. 25: 54â68. doi:10.1109/2.108055. S2CIDÂ 16447071.

^ Graf, Peter (1995). Term indexing. Springer. ISBNÂ 978-3-540-61040-3.

^ Wise, Michael J.; Powers, David M. W. (1986). Indexing Prolog Clauses via Superimposed Code Words and Field Encoded Words. International Symposium on Logic Programming. pp.Â 203â210.

^ Colomb, Robert M. (1991). "Enhancing unification in PROLOG through clause indexing". The Journal of Logic Programming. 10: 23â44. doi:10.1016/0743-1066(91)90004-9.

^ Swift, T. (1999). "Tabling for nonâmonotonic programming". Annals of Mathematics and Artificial Intelligence. 25 (3/4): 201â240. doi:10.1023/A:1018990308362. S2CIDÂ 16695800.

^ Zhou, Neng-Fa; Sato, Taisuke (2003). "Efficient Fixpoint Computation in Linear Tabling" (PDF). Proceedings of the 5th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming: 275â283.

^ Swift, T.; Warren, D. S. (2011). "XSB: Extending Prolog with Tabled Logic Programming". Theory and Practice of Logic Programming. 12 (1â2): 157â187. arXiv:1012.5123. doi:10.1017/S1471068411000500. S2CIDÂ 6153112.

^ Abe, S.; Bandoh, T.; Yamaguchi, S.; Kurosawa, K.; Kiriyama, K. (1987). "High performance integrated Prolog processor IPP". Proceedings of the 14th annual international symposium on Computer architecture - ISCA '87. p.Â 100. doi:10.1145/30350.30362. ISBNÂ 978-0818607769. S2CIDÂ 10283148.

^ Robinson, Ian (1986). A Prolog processor based on a pattern matching memory device. Third International Conference on Logic Programming. Lecture Notes in Computer Science. Vol.Â 225. Springer. pp.Â 172â179. doi:10.1007/3-540-16492-8_73. ISBNÂ 978-3-540-16492-0.

^ Taki, K.; Nakajima, K.; Nakashima, H.; Ikeda, M. (1987). "Performance and architectural evaluation of the PSI machine". ACM SIGPLAN Notices. 22 (10): 128. doi:10.1145/36205.36195.

^ Gupta, G.; Pontelli, E.; Ali, K. A. M.; Carlsson, M.; Hermenegildo, M. V. (2001). "Parallel execution of prolog programs: a survey". ACM Transactions on Programming Languages and Systems. 23 (4): 472. doi:10.1145/504083.504085. S2CIDÂ 2978041.

^ "Statically Allocated Systems".

^ "Software that takes games seriously". New Scientist. Reed Business Information. March 26, 1987. p.Â 34 â via Google Books.{{cite magazine}}:  CS1 maint: url-status (link)

^ Jump up to: a b Logic programming for the real world. Zoltan Somogyi,  Fergus Henderson, Thomas Conway, Richard O'Keefe. Proceedings of the ILPS'95 Postconference Workshop on Visions for the Future of Logic Programming.

^ "FAQ: Prolog Resource Guide 1/2 [Monthly posting] Section - [1-8] The Prolog 1000 Database".

^ Jan Wielemaker and VÄ±tor Santos Costa: Portability of Prolog programs: theory and case-studies. CICLOPS-WLPE Workshop 2010.

^ Jump up to: a b Kiselyov, Oleg; Kameyama, Yukiyoshi (2014). Re-thinking Prolog. Proc. 31st meeting of the Japan Society for Software Science and Technology.

^ Franzen, Torkel (1994), "Declarative vs procedural", Association of Logic Programming, 7 (3)

^ Dantsin, Evgeny; Eiter, Thomas; Gottlob, Georg; Voronkov, Andrei (2001). "Complexity and Expressive Power of Logic Programming". ACM Computing Surveys. 33 (3): 374â425. CiteSeerXÂ 10.1.1.616.6372. doi:10.1145/502807.502810. S2CIDÂ 518049.

^ Mycroft, A.; O'Keefe, R. A. (1984). "A polymorphic type system for prolog". Artificial Intelligence. 23 (3): 295. doi:10.1016/0004-3702(84)90017-1.

^ Pfenning, Frank (1992). Types in logic programming. Cambridge, Massachusetts: MIT Press. ISBNÂ 978-0-262-16131-2.

^ Schrijvers, Tom; Santos Costa, Vitor; Wielemaker, Jan; Demoen, Bart (2008). "Towards Typed Prolog".  In Maria Garcia de la Banda; Enrico Pontelli (eds.). Logic programmingÂ : 24th international conference, ICLP 2008, Udine, Italy, December 9-13, 2008Â : proceedings. Lecture Notes in Computer Science. Vol.Â 5366. pp.Â 693â697. doi:10.1007/978-3-540-89982-2_59. ISBNÂ 9783540899822.

^ Jump up to: a b Apt, K. R.; Marchiori, E. (1994). "Reasoning about Prolog programs: From modes through types to assertions". Formal Aspects of Computing. 6 (S1): 743. CiteSeerXÂ 10.1.1.57.395. doi:10.1007/BF01213601. S2CIDÂ 12235465.

^ O'Keefe, Richard A. (1990). The craft of Prolog. Cambridge, Massachusetts: MIT Press. ISBNÂ 978-0-262-15039-2.

^ Michael Covington; Roberto Bagnara;  etÂ al. (2010). "Coding guidelines for Prolog". arXiv:0911.2899 [cs.PL].

^ Roy, P.; Demoen, B.; Willems, Y. D. (1987). "Improving the execution speed of compiled Prolog with modes, clause selection, and determinism". Tapsoft '87. Lecture Notes in Computer Science. Vol.Â 250. pp.Â 111. doi:10.1007/BFb0014976. ISBNÂ 978-3-540-17611-4.

^ Jaffar, J. (1994). "Constraint logic programming: a survey". The Journal of Logic Programming. 19â20: 503â581. doi:10.1016/0743-1066(94)90033-7.

^ Colmerauer, Alain (1987). "Opening the Prolog III Universe". Byte. August.

^ Wallace, M. (2002). "Constraint Logic Programming". Computational Logic: Logic Programming and Beyond. Lecture Notes in Computer Science. Vol.Â 2407. pp.Â 512â556. doi:10.1007/3-540-45628-7_19. ISBNÂ 978-3540456285.

^ "XPCE graphics library".

^ "prolog-mpi". Apps.lumii.lv. Retrieved 2010-09-16.

^ Ehud Shapiro. The family of concurrent logic programming languages ACM Computing Surveys. September 1989.

^ Wielemaker, J.; Huang, Z.; Van Der Meij, L. (2008). "SWI-Prolog and the web" (PDF). Theory and Practice of Logic Programming. 8 (3): 363. doi:10.1017/S1471068407003237. S2CIDÂ 5404048.

^ Jan Wielemaker and Michiel Hildebrand and Jacco van Ossenbruggen (2007),  S. Heymans; A. Polleres; E. Ruckhaus; D. Pearse; G. Gupta (eds.), "Using {Prolog} as the fundament for applications on the semantic web" (PDF), Proceedings of the 2nd Workshop on Applications of Logic Programming and to the Web, Semantic Web and Semantic Web Services, CEUR Workshop Proceedings, Porto, Portugal: CEUR-WS.org, vol.Â 287, pp.Â 84â98

^ Processing OWL2 Ontologies using Thea: An Application of Logic Programming. Vangelis Vassiliadis, Jan Wielemaker and Chris Mungall. Proceedings of the 5th International Workshop on OWL: Experiences and Directions (OWLED 2009), Chantilly, VA, United States, October 23â24, 2009

^ Loke, S. W.; Davison, A. (2001). "Secure Prolog-based mobile code". Theory and Practice of Logic Programming. 1 (3): 321. arXiv:cs/0406012. CiteSeerXÂ 10.1.1.58.6610. doi:10.1017/S1471068401001211. S2CIDÂ 11754347.

^ "Archived copy". Archived from the original on 2019-03-17. Retrieved 2019-06-08.{{cite web}}:  CS1 maint: archived copy as title (link)

^ Pountain, Dick (October 1984). "POP and SNAP". BYTE. p.Â 381. Retrieved 23 October 2013.

^ "Wikipedia GeneXus Page".

^ terminusdb/terminusdb, TerminusDB, 2020-12-13, retrieved 2020-12-15


Further reading[edit]
.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}
Blackburn, Patrick; Bos, Johan; Striegnitz, Kristina (2006). Learn Prolog Now!. ISBNÂ 978-1-904987-17-8.
Ivan Bratko, Prolog Programming for Artificial Intelligence, 4th ed., 2012, ISBNÂ 978-0-321-41746-6. Book supplements and source code[permanent dead link]
William F. Clocksin, Christopher S. Mellish: Programming in Prolog: Using the ISO Standard. Springer, 5th ed., 2003, ISBNÂ 978-3-540-00678-7. (This edition is updated for ISO Prolog. Previous editions described Edinburgh Prolog.)
William F. Clocksin: Clause and Effect. Prolog Programming for the Working Programmer. Springer, 2003, ISBNÂ 978-3-540-62971-9.
Michael A. Covington, Donald Nute, Andre Vellino, Prolog Programming in Depth, 1996, ISBNÂ 0-13-138645-X.
Michael A. Covington, Natural Language Processing for Prolog Programmers, 1994, ISBNÂ 978-0-13-629213-5
M. S. Dawe and C.M.Dawe, Prolog for Computer Sciences, Springer Verlag 1992.
ISO/IEC 13211: Information technology â Programming languages â Prolog. International Organization for Standardization, Geneva.
Feliks KluÅºniak and StanisÅaw Szpakowicz (with a contribution by Janusz S. BieÅ). Prolog for Programmers. Academic Press Inc. (London), 1985, 1987 (available under a Creative Commons license at sites.google.com/site/prologforprogrammers/[permanent dead link]). ISBNÂ 0-12-416521-4.
Richard O'Keefe, The Craft of Prolog,  ISBNÂ 0-262-15039-5.
Robert Smith, John Gibson, Aaron Sloman: 'POPLOG's two-level virtual machine support for interactive languages', in Research Directions in Cognitive Science Volume 5: Artificial Intelligence, Eds D. Sleeman and N. Bernsen, Lawrence Erlbaum Associates, pp 203â231, 1992.
Leon Sterling and Ehud Shapiro, The Art of Prolog: Advanced Programming Techniques, 1994, ISBNÂ 0-262-19338-8.
David H D Warren, Luis M. Pereira and Fernando Pereira, Prolog - the language and its implementation compared with Lisp. ACM SIGART Bulletin archive, Issue 64. Proceedings of the 1977 symposium on Artificial intelligence and programming languages, pp 109â115.




Wikibooks has more on the topic of: Prolog

.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteProgramming languages
Comparison
Timeline
History

Ada
ALGOL
APL
Assembly
BASIC
C
C++
C#
COBOL
Erlang
Forth
Fortran
Go
Haskell
Java
JavaScript
Kotlin
Lisp
Lua
ML
Pascal
Perl
PHP
Prolog
Python
R
Ruby
Rust
SQL
Shell
Simula
Smalltalk
Swift
more...

 Category
 Lists: Alphabetical
Categorical
Generational
Non-English-based

vteISO standards .mw-parser-output .nobold{font-weight:normal}by standard numberList of ISO standardsÂ / ISO romanizationsÂ / IEC standards1â9999
1
2
3
4
5
6
7
9
16
17
31
-0
-1
-2
-3
-4
-5
-6
-7
-8
-9
-10
-11
-12
-13
68-1
128
216
217
226
228
233
259
261
262
269
302
306
361
428
500
518
519
639
-1
-2
-3
-5
-6
646
657
668
690
704
732
764
838
843
860
898
965
999
1000
1004
1007
1073-1
1073-2
1155
1413
1538
1629
1745
1989
2014
2015
2022
2033
2047
2108
2145
2146
2240
2281
2533
2709
2711
2720
2788
2848
2852
3029
3103
3166
-1
-2
-3
3297
3307
3601
3602
3864
3901
3950
3977
4031
4157
4165
4217
4909
5218
5426
5427
5428
5725
5775
5776
5800
5807
5964
6166
6344
6346
6385
6425
6429
6438
6523
6709
6943
7001
7002
7010
7027
7064
7098
7185
7200
7498
-1
7637
7736
7810
7811
7812
7813
7816
7942
8000
8093
8178
8217
8373
8501-1
8571
8583
8601
8613
8632
8651
8652
8691
8805/8806
8807
8820-5
8859
-1
-2
-3
-4
-5
-6
-7
-8
-8-I
-9
-10
-11
-12
-13
-14
-15
-16
8879
9000/9001
9036
9075
9126
9141
9227
9241
9293
9314
9362
9407
9496
9506
9529
9564
9592/9593
9594
9660
9797-1
9897
9899
9945
9984
9985
9995
10000â19999
10005
10006
10007
10116
10118-3
10160
10161
10165
10179
10206
10218
10303
-11
-21
-22
-28
-238
10383
10487
10585
10589
10628
10646
10664
10746
10861
10957
10962
10967
11073
11170
11179
11404
11544
11783
11784
11785
11801
11889
11898
11940 (-2)
11941
11941 (TR)
11992
12006
12182
12207
12234-2
12620
13211
-1
-2
13216
13250
13399
13406-2
13450
13485
13490
13567
13568
13584
13616
13816
14000
14031
14224
14289
14396
14443
14496
-2
-3
-6
-10
-11
-12
-14
-17
-20
14617
14644
14649
14651
14698
14764
14882
14971
15022
15189
15288
15291
15292
15398
15408
15444
-3
15445
15438
15504
15511
15686
15693
15706
-2
15707
15897
15919
15924
15926
15926 WIP
15930
16023
16262
16355-1
16612-2
16750
16949 (TS)
17024
17025
17100
17203
17369
17442
17799
18000
18004
18014
18245
18629
18916
19005
19011
19092
-1
-2
19114
19115
19125
19136
19407
19439
19500
19501
19502
19503
19505
19506
19507
19508
19509
19510
19600
19752
19757
19770
19775-1
19794-5
19831
20000â29999
20000
20022
20121
20400
20802
21000
21047
21500
21827
22000
22300
22395
23090-3
23270
23271
23360
24517
24613
24617
24707
25178
25964
26000
26262
26300
26324
27000 series
27000
27001
27002
27005
27006
27729
28000
29110
29148
29199-2
29500
30000+
30170
31000
32000
37001
38500
40500
42010
45001
50001
55000
56000
80000

 Category

Authority control National libraries
France (data)
United States
Other
SUDOC (France)
1





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Prolog&oldid=1068030824"
		Categories: 1972 in computingDeclarative programming languagesDynamically typed programming languagesLogic programming languagesPattern matching programming languagesProgramming languages created in 1972Programming languages with an ISO standardProlog programming language familyHomoiconic programming languagesHidden categories: All articles with dead external linksArticles with dead external links from June 2020Articles with permanently dead external linksCS1 maint: url-statusCS1: long volume valueCS1 maint: archived copy as titleArticles with short descriptionShort description matches WikidataWikipedia articles needing clarification from October 2012All articles with unsourced statementsArticles with unsourced statements from November 2010Articles with unsourced statements from June 2021Articles containing French-language textAll articles lacking reliable referencesArticles lacking reliable references from February 2021All articles with specifically marked weasel-worded phrasesArticles with specifically marked weasel-worded phrases from February 2010Articles with dead external links from August 2019Articles with dead external links from September 2019Articles with BNF identifiersArticles with LCCN identifiersArticles with SUDOC identifiers
	
