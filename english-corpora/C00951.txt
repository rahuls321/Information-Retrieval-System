
Title:
Church encoding
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Representation of the natural numbers as higher-order functions
In mathematics, Church encoding is a means of representing data and operators in the lambda calculus. The Church numerals are a representation of the natural numbers using lambda notation. The method is named for Alonzo Church, who first encoded data in the lambda calculus this way.
Terms that are usually considered primitive in other notations (such as integers, booleans, pairs, lists, and tagged unions) are mapped to higher-order functions under Church encoding.  The Church-Turing thesis asserts that any computable operator (and its operands) can be represented under Church encoding.  In the untyped lambda calculus the only primitive data type is the function.  
The Church encoding is not intended[by whom?] as a practical implementation of primitive data types.  Its use is to show that other primitive data types are not required to represent any calculation.  The completeness is representational.  Additional functions are needed to translate the representation into common data types, for display to people.  It is not possible in general to decide if two functions are extensionally equal due to the undecidability of equivalence from Church's theorem.  The translation may apply the function in some way to retrieve the value it represents, or look up its value as a literal lambda term.
Lambda calculus is usually interpreted as using intensional equality.  There are potential problems with the interpretation of results because of the difference between the intensional and extensional definition of equality.

Contents

1 Church numerals

1.1 Calculation with Church numerals
1.2 Table of functions on Church numerals
1.3 Derivation of predecessor function

1.3.1 Value container
1.3.2 Inc
1.3.3 Extract
1.3.4 Const
1.3.5 Another way of defining pred


1.4 Division
1.5 Signed numbers
1.6 Plus and minus
1.7 Multiply and  divide
1.8 Rational and real numbers
1.9 Translation with other representations


2 Church Booleans
3 Predicates
4 Church pairs
5 List encodings

5.1 Two pairs as a list node
5.2 One pair as a list node
5.3 Represent the list using right fold
5.4 Represent the list using Scott encoding


6 See also
7 Notes
8 References



Church numerals[edit]
Church numerals are the representations of natural numbers under Church encoding.  The higher-order function that represents natural number n is a function that maps any function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 to its n-fold composition. In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.


  
    
      
        
          f
          
            â
            n
          
        
        =
        
          
            
              
                f
                â
                f
                â
                â¯
                â
                f
              
              â
            
          
          
            n
            
              Â times
            
          
        
        .
        
      
    
    {\displaystyle f^{\circ n}=\underbrace {f\circ f\circ \cdots \circ f} _{n{\text{ times}}}.\,}
  

All Church numerals are functions that take two parameters.  Church numerals 0, 1, 2, ..., are defined as follows in the lambda calculus.
Starting with 0 not applying the function at all, proceed with 1 applying the function once, 2 applying the function twice, 3 applying the function three times, etc.:


  
    
      
        
          
            
              
                
                  Number
                
              
              
                
                  Function definition
                
              
              
                
                  Lambda expression
                
              
            
            
              
                0
              
              
                0
                Â 
                f
                Â 
                x
                =
                x
              
              
                0
                =
                Î»
                f
                .
                Î»
                x
                .
                x
              
            
            
              
                1
              
              
                1
                Â 
                f
                Â 
                x
                =
                f
                Â 
                x
              
              
                1
                =
                Î»
                f
                .
                Î»
                x
                .
                f
                Â 
                x
              
            
            
              
                2
              
              
                2
                Â 
                f
                Â 
                x
                =
                f
                Â 
                (
                f
                Â 
                x
                )
              
              
                2
                =
                Î»
                f
                .
                Î»
                x
                .
                f
                Â 
                (
                f
                Â 
                x
                )
              
            
            
              
                3
              
              
                3
                Â 
                f
                Â 
                x
                =
                f
                Â 
                (
                f
                Â 
                (
                f
                Â 
                x
                )
                )
              
              
                3
                =
                Î»
                f
                .
                Î»
                x
                .
                f
                Â 
                (
                f
                Â 
                (
                f
                Â 
                x
                )
                )
              
            
            
              
                â®
              
              
                â®
              
              
                â®
              
            
            
              
                n
              
              
                n
                Â 
                f
                Â 
                x
                =
                
                  f
                  
                    n
                  
                
                Â 
                x
              
              
                n
                =
                Î»
                f
                .
                Î»
                x
                .
                
                  f
                  
                    â
                    n
                  
                
                Â 
                x
              
            
          
        
      
    
    {\displaystyle {\begin{array}{r|l|l}{\text{Number}}&{\text{Function definition}}&{\text{Lambda expression}}\\\hline 0&0\ f\ x=x&0=\lambda f.\lambda x.x\\1&1\ f\ x=f\ x&1=\lambda f.\lambda x.f\ x\\2&2\ f\ x=f\ (f\ x)&2=\lambda f.\lambda x.f\ (f\ x)\\3&3\ f\ x=f\ (f\ (f\ x))&3=\lambda f.\lambda x.f\ (f\ (f\ x))\\\vdots &\vdots &\vdots \\n&n\ f\ x=f^{n}\ x&n=\lambda f.\lambda x.f^{\circ n}\ x\end{array}}}
  

The Church numeral 3 represents the action of applying any given function three times to a value.  The supplied function is first applied to a supplied parameter and then successively to its own result.  The end result is not the numeral 3 (unless the supplied parameter happens to be 0 and the function is a successor function).  The function itself, and not its end result, is the Church numeral 3.  The Church numeral 3 means simply to do anything three times.  It is an ostensive demonstration of what is meant by "three times".

Calculation with Church numerals[edit]
Arithmetic operations on numbers may be represented by functions on Church numerals.  These functions may be defined in lambda calculus, or implemented in most functional programming languages  (see converting lambda expressions to functions).
The addition function 
  
    
      
        plus
        â¡
        (
        m
        ,
        n
        )
        =
        m
        +
        n
      
    
    {\displaystyle \operatorname {plus} (m,n)=m+n}
  
 uses the identity 
  
    
      
        
          f
          
            â
            (
            m
            +
            n
            )
          
        
        (
        x
        )
        =
        
          f
          
            â
            m
          
        
        (
        
          f
          
            â
            n
          
        
        (
        x
        )
        )
      
    
    {\displaystyle f^{\circ (m+n)}(x)=f^{\circ m}(f^{\circ n}(x))}
  
.


  
    
      
        plus
        â¡
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        m
        Â 
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \operatorname {plus} \equiv \lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)}
  

The successor function 
  
    
      
        succ
        â¡
        (
        n
        )
        =
        n
        +
        1
      
    
    {\displaystyle \operatorname {succ} (n)=n+1}
  
 is Î²-equivalent to 
  
    
      
        (
        plus
        â¡
        Â 
        1
        )
      
    
    {\displaystyle (\operatorname {plus} \ 1)}
  
.


  
    
      
        succ
        â¡
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \operatorname {succ} \equiv \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)}
  

The multiplication function 
  
    
      
        mult
        â¡
        (
        m
        ,
        n
        )
        =
        m
        â
        n
      
    
    {\displaystyle \operatorname {mult} (m,n)=m*n}
  
 uses the identity 
  
    
      
        
          f
          
            â
            (
            m
            â
            n
            )
          
        
        (
        x
        )
        =
        (
        
          f
          
            â
            n
          
        
        
          )
          
            â
            m
          
        
        (
        x
        )
      
    
    {\displaystyle f^{\circ (m*n)}(x)=(f^{\circ n})^{\circ m}(x)}
  
.


  
    
      
        mult
        â¡
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        m
        Â 
        (
        n
        Â 
        f
        )
        Â 
        x
      
    
    {\displaystyle \operatorname {mult} \equiv \lambda m.\lambda n.\lambda f.\lambda x.m\ (n\ f)\ x}
  

The exponentiation function 
  
    
      
        exp
        â¡
        (
        m
        ,
        n
        )
        =
        
          m
          
            n
          
        
      
    
    {\displaystyle \operatorname {exp} (m,n)=m^{n}}
  
 is given by the definition of Church numerals, 
  
    
      
        n
        Â 
        h
        Â 
        x
        =
        
          h
          
            n
          
        
        Â 
        x
      
    
    {\displaystyle n\ h\ x=h^{n}\ x}
  
.  In the definition substitute 
  
    
      
        h
        â
        m
        ,
        x
        â
        f
      
    
    {\displaystyle h\to m,x\to f}
  
 to get 
  
    
      
        n
        Â 
        m
        Â 
        f
        =
        
          m
          
            n
          
        
        Â 
        f
      
    
    {\displaystyle n\ m\ f=m^{n}\ f}
  
 and,


  
    
      
        exp
        â¡
        Â 
        m
        Â 
        n
        =
        
          m
          
            n
          
        
        =
        n
        Â 
        m
      
    
    {\displaystyle \operatorname {exp} \ m\ n=m^{n}=n\ m}
  

which gives the lambda expression,


  
    
      
        exp
        â¡
        Î»
        m
        .
        Î»
        n
        .
        n
        Â 
        m
      
    
    {\displaystyle \operatorname {exp} \equiv \lambda m.\lambda n.n\ m}
  

The 
  
    
      
        pred
        â¡
        (
        n
        )
      
    
    {\displaystyle \operatorname {pred} (n)}
  
 function is more difficult to understand.


  
    
      
        pred
        â¡
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        n
        Â 
        (
        Î»
        g
        .
        Î»
        h
        .
        h
        Â 
        (
        g
        Â 
        f
        )
        )
        Â 
        (
        Î»
        u
        .
        x
        )
        Â 
        (
        Î»
        u
        .
        u
        )
      
    
    {\displaystyle \operatorname {pred} \equiv \lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)}
  

A Church numeral applies a function n times.  The predecessor function must return a function that applies its parameter n - 1 times.  This is achieved by building a container around f and x, which is initialized in a way that omits the application of the function the first time.  See predecessor for a more detailed explanation.
The subtraction function can be written based on the predecessor function.


  
    
      
        minus
        â¡
        Î»
        m
        .
        Î»
        n
        .
        (
        n
        pred
        )
        Â 
        m
      
    
    {\displaystyle \operatorname {minus} \equiv \lambda m.\lambda n.(n\operatorname {pred} )\ m}
  

Table of functions on Church numerals[edit]



Function
Algebra
Identity
Function definition

Lambda expressions


Successor

  
    
      
        n
        +
        1
      
    
    {\displaystyle n+1}
  


  
    
      
        
          f
          
            n
            +
            1
          
        
        Â 
        x
        =
        f
        (
        
          f
          
            n
          
        
        x
        )
      
    
    {\displaystyle f^{n+1}\ x=f(f^{n}x)}
  


  
    
      
        succ
        â¡
        Â 
        n
        Â 
        f
        Â 
        x
        =
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \operatorname {succ} \ n\ f\ x=f\ (n\ f\ x)}
  


  
    
      
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \lambda n.\lambda f.\lambda x.f\ (n\ f\ x)}
  

...


Addition

  
    
      
        m
        +
        n
      
    
    {\displaystyle m+n}
  


  
    
      
        
          f
          
            m
            +
            n
          
        
        Â 
        x
        =
        
          f
          
            m
          
        
        (
        
          f
          
            n
          
        
        x
        )
      
    
    {\displaystyle f^{m+n}\ x=f^{m}(f^{n}x)}
  


  
    
      
        plus
        â¡
        Â 
        m
        Â 
        n
        Â 
        f
        Â 
        x
        =
        m
        Â 
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \operatorname {plus} \ m\ n\ f\ x=m\ f\ (n\ f\ x)}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        m
        Â 
        f
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
      
    
    {\displaystyle \lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x)}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        n
        succ
        â¡
        m
      
    
    {\displaystyle \lambda m.\lambda n.n\operatorname {succ} m}
  



Multiplication

  
    
      
        m
        â
        n
      
    
    {\displaystyle m*n}
  


  
    
      
        
          f
          
            m
            â
            n
          
        
        Â 
        x
        =
        (
        
          f
          
            m
          
        
        
          )
          
            n
          
        
        Â 
        x
      
    
    {\displaystyle f^{m*n}\ x=(f^{m})^{n}\ x}
  


  
    
      
        multiply
        â¡
        Â 
        m
        Â 
        n
        Â 
        f
        Â 
        x
        =
        m
        Â 
        (
        n
        Â 
        f
        )
        Â 
        x
      
    
    {\displaystyle \operatorname {multiply} \ m\ n\ f\ x=m\ (n\ f)\ x}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        m
        Â 
        (
        n
        Â 
        f
        )
        Â 
        x
      
    
    {\displaystyle \lambda m.\lambda n.\lambda f.\lambda x.m\ (n\ f)\ x}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        m
        Â 
        (
        n
        Â 
        f
        )
      
    
    {\displaystyle \lambda m.\lambda n.\lambda f.m\ (n\ f)}
  



Exponentiation

  
    
      
        
          m
          
            n
          
        
      
    
    {\displaystyle m^{n}}
  


  
    
      
        n
        Â 
        m
        Â 
        f
        =
        
          m
          
            n
          
        
        Â 
        f
      
    
    {\displaystyle n\ m\ f=m^{n}\ f}
  
[1]

  
    
      
        exp
        â¡
        Â 
        m
        Â 
        n
        Â 
        f
        Â 
        x
        =
        (
        n
        Â 
        m
        )
        Â 
        f
        Â 
        x
      
    
    {\displaystyle \operatorname {exp} \ m\ n\ f\ x=(n\ m)\ f\ x}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        (
        n
        Â 
        m
        )
        Â 
        f
        Â 
        x
      
    
    {\displaystyle \lambda m.\lambda n.\lambda f.\lambda x.(n\ m)\ f\ x}
  


  
    
      
        Î»
        m
        .
        Î»
        n
        .
        n
        Â 
        m
      
    
    {\displaystyle \lambda m.\lambda n.n\ m}
  



Predecessor*

  
    
      
        n
        â
        1
      
    
    {\displaystyle n-1}
  


  
    
      
        
          inc
          
            n
          
        
        â¡
        con
        =
        val
        â¡
        (
        
          f
          
            n
            â
            1
          
        
        x
        )
      
    
    {\displaystyle \operatorname {inc} ^{n}\operatorname {con} =\operatorname {val} (f^{n-1}x)}
  


  
    
      
        i
        f
        (
        n
        ==
        0
        )
        Â 
        0
        Â 
        e
        l
        s
        e
        Â 
        (
        n
        â
        1
        )
      
    
    {\displaystyle if(n==0)\ 0\ else\ (n-1)}
  




  
    
      
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        n
        Â 
        (
        Î»
        g
        .
        Î»
        h
        .
        h
        Â 
        (
        g
        Â 
        f
        )
        )
        Â 
        (
        Î»
        u
        .
        x
        )
        Â 
        (
        Î»
        u
        .
        u
        )
      
    
    {\displaystyle \lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)}
  




Subtraction*

  
    
      
        m
        â
        n
      
    
    {\displaystyle m-n}
  


  
    
      
        
          f
          
            m
            â
            n
          
        
        Â 
        x
        =
        (
        
          f
          
            â
            1
          
        
        
          )
          
            n
          
        
        (
        
          f
          
            m
          
        
        x
        )
      
    
    {\displaystyle f^{m-n}\ x=(f^{-1})^{n}(f^{m}x)}
  


  
    
      
        minus
        â¡
        Â 
        m
        Â 
        n
        =
        (
        n
        pred
        )
        Â 
        m
      
    
    {\displaystyle \operatorname {minus} \ m\ n=(n\operatorname {pred} )\ m}
  

...

  
    
      
        Î»
        m
        .
        Î»
        n
        .
        n
        pred
        â¡
        m
      
    
    {\displaystyle \lambda m.\lambda n.n\operatorname {pred} m}
  


* Note that in the Church encoding,


  
    
      
        pred
        â¡
        (
        0
        )
        =
        0
      
    
    {\displaystyle \operatorname {pred} (0)=0}
  


  
    
      
        m
        <=
        n
        â
        m
        â
        n
        =
        0
      
    
    {\displaystyle m<=n\to m-n=0}
  

Derivation of predecessor function[edit]
The predecessor function used in the Church encoding is,


  
    
      
        pred
        â¡
        (
        n
        )
        =
        
          
            {
            
              
                
                  0
                
                
                  
                    
                      ifÂ 
                    
                  
                  n
                  =
                  0
                  ,
                
              
              
                
                  n
                  â
                  1
                
                
                  
                    
                      otherwise
                    
                  
                
              
            
            
          
        
      
    
    {\displaystyle \operatorname {pred} (n)={\begin{cases}0&{\mbox{if }}n=0,\\n-1&{\mbox{otherwise}}\end{cases}}}
  
.
To build the predecessor we need a way of applying the function 1 fewer time.  A numeral n applies the function f n times to x.  The predecessor function must use the numeral n to apply the function n-1 times.
Before implementing the predecessor function, here is a scheme that wraps the value in a container function.  We will define new functions to use in place of f and x, called inc and init.  The container function is called value.  The left hand side of the table shows a numeral n applied to inc and init.


  
    
      
        
          
            
              
                
                  Number
                
              
              
                
                  Using init
                
              
              
                
                  Using const
                
              
            
            
              
                0
              
              
                init
                =
                value
                â¡
                Â 
                x
              
              
            
            
              
                1
              
              
                inc
                â¡
                Â 
                init
                =
                value
                â¡
                Â 
                (
                f
                Â 
                x
                )
              
              
                inc
                â¡
                Â 
                const
                =
                value
                â¡
                Â 
                x
              
            
            
              
                2
              
              
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                init
                )
                =
                value
                â¡
                Â 
                (
                f
                Â 
                (
                f
                Â 
                x
                )
                )
              
              
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                const
                )
                =
                value
                â¡
                Â 
                (
                f
                Â 
                x
                )
              
            
            
              
                3
              
              
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                init
                )
                )
                =
                value
                â¡
                Â 
                (
                f
                Â 
                (
                f
                Â 
                (
                f
                Â 
                x
                )
                )
                )
              
              
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                (
                inc
                â¡
                Â 
                const
                )
                )
                =
                value
                â¡
                Â 
                (
                f
                Â 
                (
                f
                Â 
                x
                )
                )
              
            
            
              
                â®
              
              
                â®
              
              
                â®
              
            
            
              
                n
              
              
                n
                inc
                â¡
                Â 
                init
                =
                value
                â¡
                Â 
                (
                
                  f
                  
                    n
                  
                
                Â 
                x
                )
                =
                value
                â¡
                Â 
                (
                n
                Â 
                f
                Â 
                x
                )
              
              
                n
                inc
                â¡
                Â 
                const
                =
                value
                â¡
                Â 
                (
                
                  f
                  
                    n
                    â
                    1
                  
                
                Â 
                x
                )
                =
                value
                â¡
                Â 
                (
                (
                n
                â
                1
                )
                Â 
                f
                Â 
                x
                )
              
            
          
        
      
    
    {\displaystyle {\begin{array}{r|r|r}{\text{Number}}&{\text{Using init}}&{\text{Using const}}\\\hline 0&\operatorname {init} =\operatorname {value} \ x&\\1&\operatorname {inc} \ \operatorname {init} =\operatorname {value} \ (f\ x)&\operatorname {inc} \ \operatorname {const} =\operatorname {value} \ x\\2&\operatorname {inc} \ (\operatorname {inc} \ \operatorname {init} )=\operatorname {value} \ (f\ (f\ x))&\operatorname {inc} \ (\operatorname {inc} \ \operatorname {const} )=\operatorname {value} \ (f\ x)\\3&\operatorname {inc} \ (\operatorname {inc} \ (\operatorname {inc} \ \operatorname {init} ))=\operatorname {value} \ (f\ (f\ (f\ x)))&\operatorname {inc} \ (\operatorname {inc} \ (\operatorname {inc} \ \operatorname {const} ))=\operatorname {value} \ (f\ (f\ x))\\\vdots &\vdots &\vdots \\n&n\operatorname {inc} \ \operatorname {init} =\operatorname {value} \ (f^{n}\ x)=\operatorname {value} \ (n\ f\ x)&n\operatorname {inc} \ \operatorname {const} =\operatorname {value} \ (f^{n-1}\ x)=\operatorname {value} \ ((n-1)\ f\ x)\\\end{array}}}
  

The general recurrence rule is,


  
    
      
        inc
        â¡
        Â 
        (
        value
        â¡
        Â 
        v
        )
        =
        value
        â¡
        Â 
        (
        f
        Â 
        v
        )
      
    
    {\displaystyle \operatorname {inc} \ (\operatorname {value} \ v)=\operatorname {value} \ (f\ v)}
  

If there is also a function to retrieve the value from the container (called extract),


  
    
      
        extract
        â¡
        Â 
        (
        value
        â¡
        Â 
        v
        )
        =
        v
      
    
    {\displaystyle \operatorname {extract} \ (\operatorname {value} \ v)=v}
  

Then extract may be used to define the samenum function as,


  
    
      
        samenum
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        extract
        â¡
        Â 
        (
        n
        inc
        â¡
        init
        )
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        extract
        â¡
        Â 
        (
        value
        â¡
        Â 
        (
        n
        Â 
        f
        Â 
        x
        )
        )
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        n
        Â 
        f
        Â 
        x
        =
        Î»
        n
        .
        n
      
    
    {\displaystyle \operatorname {samenum} =\lambda n.\lambda f.\lambda x.\operatorname {extract} \ (n\operatorname {inc} \operatorname {init} )=\lambda n.\lambda f.\lambda x.\operatorname {extract} \ (\operatorname {value} \ (n\ f\ x))=\lambda n.\lambda f.\lambda x.n\ f\ x=\lambda n.n}
  

The samenum function is not intrinsically useful. However, as inc delegates calling of f to its container argument, we can arrange that on the first application inc receives a special container that ignores its argument allowing to skip the first application of f.  Call this new initial container const.  The right hand side of the above table shows the expansions of n inc const.  Then by replacing init with const in the expression for the same function we get the predecessor function,


  
    
      
        pred
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        extract
        â¡
        Â 
        (
        n
        inc
        â¡
        const
        )
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        extract
        â¡
        Â 
        (
        value
        â¡
        Â 
        (
        (
        n
        â
        1
        )
        Â 
        f
        Â 
        x
        )
        )
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        (
        n
        â
        1
        )
        Â 
        f
        Â 
        x
        =
        Î»
        n
        .
        (
        n
        â
        1
        )
      
    
    {\displaystyle \operatorname {pred} =\lambda n.\lambda f.\lambda x.\operatorname {extract} \ (n\operatorname {inc} \operatorname {const} )=\lambda n.\lambda f.\lambda x.\operatorname {extract} \ (\operatorname {value} \ ((n-1)\ f\ x))=\lambda n.\lambda f.\lambda x.(n-1)\ f\ x=\lambda n.(n-1)}
  

As explained below the functions inc, init, const, value and extract may be defined as,


  
    
      
        
          
            
              
                value
              
              
                
                =
                Î»
                v
                .
                (
                Î»
                h
                .
                h
                Â 
                v
                )
              
            
            
              
                extract
                â¡
                k
              
              
                
                =
                k
                Â 
                Î»
                u
                .
                u
              
            
            
              
                inc
              
              
                
                =
                Î»
                g
                .
                Î»
                h
                .
                h
                Â 
                (
                g
                Â 
                f
                )
              
            
            
              
                init
              
              
                
                =
                Î»
                h
                .
                h
                Â 
                x
              
            
            
              
                const
              
              
                
                =
                Î»
                u
                .
                x
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {value} &=\lambda v.(\lambda h.h\ v)\\\operatorname {extract} k&=k\ \lambda u.u\\\operatorname {inc} &=\lambda g.\lambda h.h\ (g\ f)\\\operatorname {init} &=\lambda h.h\ x\\\operatorname {const} &=\lambda u.x\end{aligned}}}
  

Which gives the lambda expression for pred as,


  
    
      
        pred
        =
        Î»
        n
        .
        Î»
        f
        .
        Î»
        x
        .
        n
        Â 
        (
        Î»
        g
        .
        Î»
        h
        .
        h
        Â 
        (
        g
        Â 
        f
        )
        )
        Â 
        (
        Î»
        u
        .
        x
        )
        Â 
        (
        Î»
        u
        .
        u
        )
      
    
    {\displaystyle \operatorname {pred} =\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)}
  





Value container[edit]
The value container applies a function to its value.  It is defined by,


  
    
      
        value
        â¡
        Â 
        v
        Â 
        h
        =
        h
        Â 
        v
      
    
    {\displaystyle \operatorname {value} \ v\ h=h\ v}
  

so,


  
    
      
        value
        =
        Î»
        v
        .
        (
        Î»
        h
        .
        h
        Â 
        v
        )
      
    
    {\displaystyle \operatorname {value} =\lambda v.(\lambda h.h\ v)}
  

Inc[edit]
The inc function should take a value containing v, and return a new value containing f v.


  
    
      
        inc
        â¡
        Â 
        (
        value
        â¡
        Â 
        v
        )
        =
        value
        â¡
        Â 
        (
        f
        Â 
        v
        )
      
    
    {\displaystyle \operatorname {inc} \ (\operatorname {value} \ v)=\operatorname {value} \ (f\ v)}
  

Letting g be the value container,


  
    
      
        g
        =
        value
        â¡
        Â 
        v
      
    
    {\displaystyle g=\operatorname {value} \ v}
  

then,


  
    
      
        g
        Â 
        f
        =
        value
        â¡
        Â 
        v
        Â 
        f
        =
        f
        Â 
        v
      
    
    {\displaystyle g\ f=\operatorname {value} \ v\ f=f\ v}
  

so,


  
    
      
        inc
        â¡
        Â 
        g
        =
        value
        â¡
        Â 
        (
        g
        Â 
        f
        )
      
    
    {\displaystyle \operatorname {inc} \ g=\operatorname {value} \ (g\ f)}
  


  
    
      
        inc
        =
        Î»
        g
        .
        Î»
        h
        .
        h
        Â 
        (
        g
        Â 
        f
        )
      
    
    {\displaystyle \operatorname {inc} =\lambda g.\lambda h.h\ (g\ f)}
  



Extract[edit]
The value may be extracted by applying the identity function,


  
    
      
        I
        =
        Î»
        u
        .
        u
      
    
    {\displaystyle I=\lambda u.u}
  

Using I,


  
    
      
        value
        â¡
        Â 
        v
        Â 
        I
        =
        v
      
    
    {\displaystyle \operatorname {value} \ v\ I=v}
  

so,


  
    
      
        extract
        â¡
        Â 
        k
        =
        k
        Â 
        I
      
    
    {\displaystyle \operatorname {extract} \ k=k\ I}
  

Const[edit]
To implement pred the init function is replaced with the const that does not apply f.  We need const to satisfy,


  
    
      
        inc
        â¡
        Â 
        const
        =
        value
        â¡
        Â 
        x
      
    
    {\displaystyle \operatorname {inc} \ \operatorname {const} =\operatorname {value} \ x}
  


  
    
      
        Î»
        h
        .
        h
        Â 
        (
        const
        â¡
        Â 
        f
        )
        =
        Î»
        h
        .
        h
        Â 
        x
      
    
    {\displaystyle \lambda h.h\ (\operatorname {const} \ f)=\lambda h.h\ x}
  

Which is satisfied if,


  
    
      
        const
        â¡
        Â 
        f
        =
        x
      
    
    {\displaystyle \operatorname {const} \ f=x}
  

Or as a lambda expression,


  
    
      
        const
        =
        Î»
        u
        .
        x
      
    
    {\displaystyle \operatorname {const} =\lambda u.x}
  


Another way of defining pred[edit]
Pred may also be defined using pairs:


  
    
      
        
          
            
              
                f
                =
              
              
                Â 
                Î»
                p
                .
                Â 
                pair
                â¡
                Â 
                (
                second
                â¡
                Â 
                p
                )
                Â 
                (
                succ
                â¡
                Â 
                (
                second
                â¡
                Â 
                p
                )
                )
              
            
            
              
                zero
                =
              
              
                Â 
                (
                Î»
                f
                .
                Î»
                x
                .
                Â 
                x
                )
              
            
            
              
                pc0
                =
              
              
                Â 
                pair
                â¡
                Â 
                zero
                â¡
                Â 
                zero
              
            
            
              
                pred
                =
              
              
                Â 
                Î»
                n
                .
                Â 
                first
                â¡
                Â 
                (
                n
                Â 
                f
                â¡
                Â 
                pc0
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {f} =&\ \lambda p.\ \operatorname {pair} \ (\operatorname {second} \ p)\ (\operatorname {succ} \ (\operatorname {second} \ p))\\\operatorname {zero} =&\ (\lambda f.\lambda x.\ x)\\\operatorname {pc0} =&\ \operatorname {pair} \ \operatorname {zero} \ \operatorname {zero} \\\operatorname {pred} =&\ \lambda n.\ \operatorname {first} \ (n\ \operatorname {f} \ \operatorname {pc0} )\\\end{aligned}}}
  

This is a simpler definition, but leads to a more complex expression for pred.
The expansion for 
  
    
      
        pred
        â¡
        three
      
    
    {\displaystyle \operatorname {pred} \operatorname {three} }
  
:


  
    
      
        
          
            
              
                pred
                â¡
                three
                =
              
              
                Â 
                first
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                pair
                â¡
                Â 
                zero
                â¡
                Â 
                zero
                )
                )
                )
                )
              
            
            
              
                =
              
              
                Â 
                first
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                pair
                â¡
                Â 
                zero
                â¡
                Â 
                one
                )
                )
                )
              
            
            
              
                =
              
              
                Â 
                first
                â¡
                Â 
                (
                f
                â¡
                Â 
                (
                pair
                â¡
                Â 
                one
                â¡
                Â 
                two
                )
                )
              
            
            
              
                =
              
              
                Â 
                first
                â¡
                Â 
                (
                pair
                â¡
                Â 
                two
                â¡
                Â 
                three
                )
              
            
            
              
                =
              
              
                Â 
                two
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {pred} \operatorname {three} =&\ \operatorname {first} \ (\operatorname {f} \ (\operatorname {f} \ (\operatorname {f} \ (\operatorname {pair} \ \operatorname {zero} \ \operatorname {zero} ))))\\=&\ \operatorname {first} \ (\operatorname {f} \ (\operatorname {f} \ (\operatorname {pair} \ \operatorname {zero} \ \operatorname {one} )))\\=&\ \operatorname {first} \ (\operatorname {f} \ (\operatorname {pair} \ \operatorname {one} \ \operatorname {two} ))\\=&\ \operatorname {first} \ (\operatorname {pair} \ \operatorname {two} \ \operatorname {three} )\\=&\ \operatorname {two} \end{aligned}}}
  

Division[edit]
Division of natural numbers may be implemented by,[2]


  
    
      
        n
        
          /
        
        m
        =
        if
        â¡
        Â 
        n
        â¥
        m
        Â 
        then
        â¡
        Â 
        1
        +
        (
        n
        â
        m
        )
        
          /
        
        m
        Â 
        else
        â¡
        Â 
        0
      
    
    {\displaystyle n/m=\operatorname {if} \ n\geq m\ \operatorname {then} \ 1+(n-m)/m\ \operatorname {else} \ 0}
  

Calculating 
  
    
      
        n
        â
        m
      
    
    {\displaystyle n-m}
  
 takes many beta reductions.  Unless doing the reduction by hand, this doesn't matter that much, but it is preferable to not have to do this calculation twice.  The simplest predicate for testing numbers is IsZero so consider the condition.


  
    
      
        IsZero
        â¡
        Â 
        (
        minus
        â¡
        Â 
        n
        Â 
        m
        )
      
    
    {\displaystyle \operatorname {IsZero} \ (\operatorname {minus} \ n\ m)}
  

But this condition is equivalent to 
  
    
      
        n
        â¤
        m
      
    
    {\displaystyle n\leq m}
  
, not 
  
    
      
        n
        <
        m
      
    
    {\displaystyle n<m}
  
.  If this expression is used then the mathematical definition of division given above is translated into function on Church numerals as,


  
    
      
        divide1
        â¡
        Â 
        n
        Â 
        m
        Â 
        f
        Â 
        x
        =
        (
        Î»
        d
        .
        IsZero
        â¡
        Â 
        d
        Â 
        (
        0
        Â 
        f
        Â 
        x
        )
        Â 
        (
        f
        Â 
        (
        divide1
        â¡
        Â 
        d
        Â 
        m
        Â 
        f
        Â 
        x
        )
        )
        )
        Â 
        (
        minus
        â¡
        Â 
        n
        Â 
        m
        )
      
    
    {\displaystyle \operatorname {divide1} \ n\ m\ f\ x=(\lambda d.\operatorname {IsZero} \ d\ (0\ f\ x)\ (f\ (\operatorname {divide1} \ d\ m\ f\ x)))\ (\operatorname {minus} \ n\ m)}
  

As desired, this definition has a single call to 
  
    
      
        minus
        â¡
        Â 
        n
        Â 
        m
      
    
    {\displaystyle \operatorname {minus} \ n\ m}
  
. However the result is that this formula gives the value of 
  
    
      
        (
        n
        â
        1
        )
        
          /
        
        m
      
    
    {\displaystyle (n-1)/m}
  
.
This problem may be corrected by adding 1 to n before calling divide. The definition of divide is then,


  
    
      
        divide
        â¡
        Â 
        n
        =
        divide1
        â¡
        Â 
        (
        succ
        â¡
        Â 
        n
        )
      
    
    {\displaystyle \operatorname {divide} \ n=\operatorname {divide1} \ (\operatorname {succ} \ n)}
  

divide1 is a recursive definition.  The Y combinator may  be used to implement the recursion.  Create a new function called div by;

In the left hand side 
  
    
      
        divide1
        â
        div
        â¡
        Â 
        c
      
    
    {\displaystyle \operatorname {divide1} \rightarrow \operatorname {div} \ c}
  

In the right hand side 
  
    
      
        divide1
        â
        c
      
    
    {\displaystyle \operatorname {divide1} \rightarrow c}
  

to get,


  
    
      
        div
        =
        Î»
        c
        .
        Î»
        n
        .
        Î»
        m
        .
        Î»
        f
        .
        Î»
        x
        .
        (
        Î»
        d
        .
        IsZero
        â¡
        Â 
        d
        Â 
        (
        0
        Â 
        f
        Â 
        x
        )
        Â 
        (
        f
        Â 
        (
        c
        Â 
        d
        Â 
        m
        Â 
        f
        Â 
        x
        )
        )
        )
        Â 
        (
        minus
        â¡
        Â 
        n
        Â 
        m
        )
      
    
    {\displaystyle \operatorname {div} =\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d.\operatorname {IsZero} \ d\ (0\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ (\operatorname {minus} \ n\ m)}
  

Then,


  
    
      
        divide
        =
        Î»
        n
        .
        divide1
        â¡
        Â 
        (
        succ
        â¡
        Â 
        n
        )
      
    
    {\displaystyle \operatorname {divide} =\lambda n.\operatorname {divide1} \ (\operatorname {succ} \ n)}
  

where,


  
    
      
        
          
            
              
                divide1
              
              
                
                =
                Y
                Â 
                div
              
            
            
              
                succ
              
              
                
                =
                Î»
                n
                .
                Î»
                f
                .
                Î»
                x
                .
                f
                Â 
                (
                n
                Â 
                f
                Â 
                x
                )
              
            
            
              
                Y
              
              
                
                =
                Î»
                f
                .
                (
                Î»
                x
                .
                f
                Â 
                (
                x
                Â 
                x
                )
                )
                Â 
                (
                Î»
                x
                .
                f
                Â 
                (
                x
                Â 
                x
                )
                )
              
            
            
              
                0
              
              
                
                =
                Î»
                f
                .
                Î»
                x
                .
                x
              
            
            
              
                IsZero
              
              
                
                =
                Î»
                n
                .
                n
                Â 
                (
                Î»
                x
                .
                false
                )
                Â 
                true
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {divide1} &=Y\ \operatorname {div} \\\operatorname {succ} &=\lambda n.\lambda f.\lambda x.f\ (n\ f\ x)\\Y&=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\\0&=\lambda f.\lambda x.x\\\operatorname {IsZero} &=\lambda n.n\ (\lambda x.\operatorname {false} )\ \operatorname {true} \end{aligned}}}
  


  
    
      
        
          
            
              
                true
              
              
                
                â¡
                Î»
                a
                .
                Î»
                b
                .
                a
              
            
            
              
                false
              
              
                
                â¡
                Î»
                a
                .
                Î»
                b
                .
                b
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {true} &\equiv \lambda a.\lambda b.a\\\operatorname {false} &\equiv \lambda a.\lambda b.b\end{aligned}}}
  


  
    
      
        
          
            
              
                minus
              
              
                
                =
                Î»
                m
                .
                Î»
                n
                .
                n
                pred
                â¡
                m
              
            
            
              
                pred
              
              
                
                =
                Î»
                n
                .
                Î»
                f
                .
                Î»
                x
                .
                n
                Â 
                (
                Î»
                g
                .
                Î»
                h
                .
                h
                Â 
                (
                g
                Â 
                f
                )
                )
                Â 
                (
                Î»
                u
                .
                x
                )
                Â 
                (
                Î»
                u
                .
                u
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {minus} &=\lambda m.\lambda n.n\operatorname {pred} m\\\operatorname {pred} &=\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u)\end{aligned}}}
  

Gives,


  
    
      
        
          divide
          =
          Î»
          n
          .
          (
          (
          Î»
          f
          .
          (
          Î»
          x
          .
          x
          Â 
          x
          )
          Â 
          (
          Î»
          x
          .
          f
          Â 
          (
          x
          Â 
          x
          )
          )
          )
          Â 
          (
          Î»
          c
          .
          Î»
          n
          .
          Î»
          m
          .
          Î»
          f
          .
          Î»
          x
          .
          (
          Î»
          d
          .
          (
          Î»
          n
          .
          n
          Â 
          (
          Î»
          x
          .
          (
          Î»
          a
          .
          Î»
          b
          .
          b
          )
          )
          Â 
          (
          Î»
          a
          .
          Î»
          b
          .
          a
          )
          )
          Â 
          d
          Â 
          (
          (
          Î»
          f
          .
          Î»
          x
          .
          x
          )
          Â 
          f
          Â 
          x
          )
          Â 
          (
          f
          Â 
          (
          c
          Â 
          d
          Â 
          m
          Â 
          f
          Â 
          x
          )
          )
          )
          Â 
          (
          (
          Î»
          m
          .
          Î»
          n
          .
          n
          (
          Î»
          n
          .
          Î»
          f
          .
          Î»
          x
          .
          n
          Â 
          (
          Î»
          g
          .
          Î»
          h
          .
          h
          Â 
          (
          g
          Â 
          f
          )
          )
          Â 
          (
          Î»
          u
          .
          x
          )
          Â 
          (
          Î»
          u
          .
          u
          )
          )
          m
          )
          Â 
          n
          Â 
          m
          )
          )
          )
          Â 
          (
          (
          Î»
          n
          .
          Î»
          f
          .
          Î»
          x
          .
          f
          Â 
          (
          n
          Â 
          f
          Â 
          x
          )
          )
          Â 
          n
          )
        
      
    
    {\displaystyle \scriptstyle \operatorname {divide} =\lambda n.((\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x\ x)))\ (\lambda c.\lambda n.\lambda m.\lambda f.\lambda x.(\lambda d.(\lambda n.n\ (\lambda x.(\lambda a.\lambda b.b))\ (\lambda a.\lambda b.a))\ d\ ((\lambda f.\lambda x.x)\ f\ x)\ (f\ (c\ d\ m\ f\ x)))\ ((\lambda m.\lambda n.n(\lambda n.\lambda f.\lambda x.n\ (\lambda g.\lambda h.h\ (g\ f))\ (\lambda u.x)\ (\lambda u.u))m)\ n\ m)))\ ((\lambda n.\lambda f.\lambda x.f\ (n\ f\ x))\ n)}
  

Or as text, using \ for Î»,

divide = (\n.((\f.(\x.x x) (\x.f (x x))) (\c.\n.\m.\f.\x.(\d.(\n.n (\x.(\a.\b.b)) (\a.\b.a)) d ((\f.\x.x) f x) (f (c d m f x))) ((\m.\n.n (\n.\f.\x.n (\g.\h.h (g f)) (\u.x) (\u.u)) m) n m))) ((\n.\f.\x. f (n f x)) n))

For example, 9/3 is represented by

divide (\f.\x.f (f (f (f (f (f (f (f (f x))))))))) (\f.\x.f (f (f x)))

Using a lambda calculus calculator, the above expression reduces to 3, using normal order.

\f.\x.f (f (f (x)))

Signed numbers[edit]
One simple approach for extending Church Numerals to signed numbers is to use a Church pair, containing Church numerals representing a positive and a negative value.[3]  The integer value is the difference between the two Church numerals.
A natural number is converted to a signed number by,


  
    
      
        
          convert
          
            s
          
        
        =
        Î»
        x
        .
        pair
        â¡
        Â 
        x
        Â 
        0
      
    
    {\displaystyle \operatorname {convert} _{s}=\lambda x.\operatorname {pair} \ x\ 0}
  

Negation is performed by swapping the values.


  
    
      
        
          neg
          
            s
          
        
        =
        Î»
        x
        .
        pair
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        x
        )
      
    
    {\displaystyle \operatorname {neg} _{s}=\lambda x.\operatorname {pair} \ (\operatorname {second} \ x)\ (\operatorname {first} \ x)}
  

The integer value is more naturally represented if one of the pair is zero.  The OneZero function achieves this condition,


  
    
      
        OneZero
        =
        Î»
        x
        .
        IsZero
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        x
        Â 
        (
        IsZero
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        x
        Â 
        (
        OneZero
        â¡
        Â 
        pair
        â¡
        Â 
        (
        pred
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        )
        Â 
        (
        pred
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        )
        )
        )
      
    
    {\displaystyle \operatorname {OneZero} =\lambda x.\operatorname {IsZero} \ (\operatorname {first} \ x)\ x\ (\operatorname {IsZero} \ (\operatorname {second} \ x)\ x\ (\operatorname {OneZero} \ \operatorname {pair} \ (\operatorname {pred} \ (\operatorname {first} \ x))\ (\operatorname {pred} \ (\operatorname {second} \ x))))}
  

The recursion may be implemented using the Y combinator,


  
    
      
        OneZ
        =
        Î»
        c
        .
        Î»
        x
        .
        IsZero
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        x
        Â 
        (
        IsZero
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        x
        Â 
        (
        c
        Â 
        pair
        â¡
        Â 
        (
        pred
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        )
        Â 
        (
        pred
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        )
        )
        )
      
    
    {\displaystyle \operatorname {OneZ} =\lambda c.\lambda x.\operatorname {IsZero} \ (\operatorname {first} \ x)\ x\ (\operatorname {IsZero} \ (\operatorname {second} \ x)\ x\ (c\ \operatorname {pair} \ (\operatorname {pred} \ (\operatorname {first} \ x))\ (\operatorname {pred} \ (\operatorname {second} \ x))))}
  


  
    
      
        OneZero
        =
        Y
        OneZ
      
    
    {\displaystyle \operatorname {OneZero} =Y\operatorname {OneZ} }
  

Plus and minus[edit]
Addition is defined mathematically on the pair by,


  
    
      
        x
        +
        y
        =
        [
        
          x
          
            p
          
        
        ,
        
          x
          
            n
          
        
        ]
        +
        [
        
          y
          
            p
          
        
        ,
        
          y
          
            n
          
        
        ]
        =
        
          x
          
            p
          
        
        â
        
          x
          
            n
          
        
        +
        
          y
          
            p
          
        
        â
        
          y
          
            n
          
        
        =
        (
        
          x
          
            p
          
        
        +
        
          y
          
            p
          
        
        )
        â
        (
        
          x
          
            n
          
        
        +
        
          y
          
            n
          
        
        )
        =
        [
        
          x
          
            p
          
        
        +
        
          y
          
            p
          
        
        ,
        
          x
          
            n
          
        
        +
        
          y
          
            n
          
        
        ]
      
    
    {\displaystyle x+y=[x_{p},x_{n}]+[y_{p},y_{n}]=x_{p}-x_{n}+y_{p}-y_{n}=(x_{p}+y_{p})-(x_{n}+y_{n})=[x_{p}+y_{p},x_{n}+y_{n}]}
  

The last expression is translated into lambda calculus as,


  
    
      
        
          plus
          
            s
          
        
        =
        Î»
        x
        .
        Î»
        y
        .
        OneZero
        â¡
        Â 
        (
        pair
        â¡
        Â 
        (
        plus
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        Â 
        (
        plus
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        )
      
    
    {\displaystyle \operatorname {plus} _{s}=\lambda x.\lambda y.\operatorname {OneZero} \ (\operatorname {pair} \ (\operatorname {plus} \ (\operatorname {first} \ x)\ (\operatorname {first} \ y))\ (\operatorname {plus} \ (\operatorname {second} \ x)\ (\operatorname {second} \ y)))}
  

Similarly subtraction is defined,


  
    
      
        x
        â
        y
        =
        [
        
          x
          
            p
          
        
        ,
        
          x
          
            n
          
        
        ]
        â
        [
        
          y
          
            p
          
        
        ,
        
          y
          
            n
          
        
        ]
        =
        
          x
          
            p
          
        
        â
        
          x
          
            n
          
        
        â
        
          y
          
            p
          
        
        +
        
          y
          
            n
          
        
        =
        (
        
          x
          
            p
          
        
        +
        
          y
          
            n
          
        
        )
        â
        (
        
          x
          
            n
          
        
        +
        
          y
          
            p
          
        
        )
        =
        [
        
          x
          
            p
          
        
        +
        
          y
          
            n
          
        
        ,
        
          x
          
            n
          
        
        +
        
          y
          
            p
          
        
        ]
      
    
    {\displaystyle x-y=[x_{p},x_{n}]-[y_{p},y_{n}]=x_{p}-x_{n}-y_{p}+y_{n}=(x_{p}+y_{n})-(x_{n}+y_{p})=[x_{p}+y_{n},x_{n}+y_{p}]}
  

giving,


  
    
      
        
          minus
          
            s
          
        
        =
        Î»
        x
        .
        Î»
        y
        .
        OneZero
        â¡
        Â 
        (
        pair
        â¡
        Â 
        (
        plus
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        Â 
        (
        plus
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        )
      
    
    {\displaystyle \operatorname {minus} _{s}=\lambda x.\lambda y.\operatorname {OneZero} \ (\operatorname {pair} \ (\operatorname {plus} \ (\operatorname {first} \ x)\ (\operatorname {second} \ y))\ (\operatorname {plus} \ (\operatorname {second} \ x)\ (\operatorname {first} \ y)))}
  

Multiply and  divide[edit]
Multiplication may be defined by,


  
    
      
        x
        â
        y
        =
        [
        
          x
          
            p
          
        
        ,
        
          x
          
            n
          
        
        ]
        â
        [
        
          y
          
            p
          
        
        ,
        
          y
          
            n
          
        
        ]
        =
        (
        
          x
          
            p
          
        
        â
        
          x
          
            n
          
        
        )
        â
        (
        
          y
          
            p
          
        
        â
        
          y
          
            n
          
        
        )
        =
        (
        
          x
          
            p
          
        
        â
        
          y
          
            p
          
        
        +
        
          x
          
            n
          
        
        â
        
          y
          
            n
          
        
        )
        â
        (
        
          x
          
            p
          
        
        â
        
          y
          
            n
          
        
        +
        
          x
          
            n
          
        
        â
        
          y
          
            p
          
        
        )
        =
        [
        
          x
          
            p
          
        
        â
        
          y
          
            p
          
        
        +
        
          x
          
            n
          
        
        â
        
          y
          
            n
          
        
        ,
        
          x
          
            p
          
        
        â
        
          y
          
            n
          
        
        +
        
          x
          
            n
          
        
        â
        
          y
          
            p
          
        
        ]
      
    
    {\displaystyle x*y=[x_{p},x_{n}]*[y_{p},y_{n}]=(x_{p}-x_{n})*(y_{p}-y_{n})=(x_{p}*y_{p}+x_{n}*y_{n})-(x_{p}*y_{n}+x_{n}*y_{p})=[x_{p}*y_{p}+x_{n}*y_{n},x_{p}*y_{n}+x_{n}*y_{p}]}
  

The last expression is translated into lambda calculus as,


  
    
      
        
          mult
          
            s
          
        
        =
        Î»
        x
        .
        Î»
        y
        .
        pair
        â¡
        Â 
        (
        plus
        â¡
        Â 
        (
        mult
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        Â 
        (
        mult
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        )
        Â 
        (
        plus
        â¡
        Â 
        (
        mult
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        Â 
        (
        mult
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        )
      
    
    {\displaystyle \operatorname {mult} _{s}=\lambda x.\lambda y.\operatorname {pair} \ (\operatorname {plus} \ (\operatorname {mult} \ (\operatorname {first} \ x)\ (\operatorname {first} \ y))\ (\operatorname {mult} \ (\operatorname {second} \ x)\ (\operatorname {second} \ y)))\ (\operatorname {plus} \ (\operatorname {mult} \ (\operatorname {first} \ x)\ (\operatorname {second} \ y))\ (\operatorname {mult} \ (\operatorname {second} \ x)\ (\operatorname {first} \ y)))}
  

A similar definition is given here for division, except in this definition, one value in each pair must be zero (see OneZero above).  The divZ function allows us to ignore the value that has a zero component.


  
    
      
        divZ
        =
        Î»
        x
        .
        Î»
        y
        .
        IsZero
        â¡
        Â 
        y
        Â 
        0
        Â 
        (
        divide
        â¡
        Â 
        x
        Â 
        y
        )
      
    
    {\displaystyle \operatorname {divZ} =\lambda x.\lambda y.\operatorname {IsZero} \ y\ 0\ (\operatorname {divide} \ x\ y)}
  

divZ is then used in the following formula, which is the same as for multiplication, but with mult replaced by divZ.


  
    
      
        
          divide
          
            s
          
        
        =
        Î»
        x
        .
        Î»
        y
        .
        pair
        â¡
        Â 
        (
        plus
        â¡
        Â 
        (
        divZ
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        Â 
        (
        divZ
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        )
        Â 
        (
        plus
        â¡
        Â 
        (
        divZ
        â¡
        Â 
        (
        first
        â¡
        Â 
        x
        )
        Â 
        (
        second
        â¡
        Â 
        y
        )
        )
        Â 
        (
        divZ
        â¡
        Â 
        (
        second
        â¡
        Â 
        x
        )
        Â 
        (
        first
        â¡
        Â 
        y
        )
        )
        )
      
    
    {\displaystyle \operatorname {divide} _{s}=\lambda x.\lambda y.\operatorname {pair} \ (\operatorname {plus} \ (\operatorname {divZ} \ (\operatorname {first} \ x)\ (\operatorname {first} \ y))\ (\operatorname {divZ} \ (\operatorname {second} \ x)\ (\operatorname {second} \ y)))\ (\operatorname {plus} \ (\operatorname {divZ} \ (\operatorname {first} \ x)\ (\operatorname {second} \ y))\ (\operatorname {divZ} \ (\operatorname {second} \ x)\ (\operatorname {first} \ y)))}
  

Rational and real numbers[edit]
Rational and computable real numbers may also be encoded in lambda calculus.  Rational numbers may be encoded as a pair of signed numbers.  Computable real numbers may be encoded by a limiting process that guarantees that the difference from the real value differs by a number which may be made as small as we need.[4]
[5]  The references given describe software that could, in theory, be translated into lambda calculus.  Once real numbers are defined, complex numbers are naturally encoded as a pair of real numbers.
The data types and functions described above demonstrate that any data type or calculation may be encoded in lambda calculus.  This is the Church-Turing thesis.

Translation with other representations[edit]
Most real-world languages have support for machine-native integers; the church and unchurch functions convert between nonnegative integers and their corresponding Church numerals. The functions are given here in Haskell, where the \ corresponds to the Î» of Lambda calculus. Implementations in other languages are similar.

type Church a = (a -> a) -> a -> a

church :: Integer -> Church Integer
church 0 = \f -> \x -> x
church n = \f -> \x -> f (church (n-1) f x)

unchurch :: Church Integer -> Integer
unchurch cn = cn (+ 1) 0

Church Booleans[edit]
Church Booleans are the Church encoding of the Boolean values true and false. Some programming languages use these as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico.
Boolean logic may be considered as a choice.  The Church encoding of true and false are functions of two parameters:

true chooses the first parameter.
false chooses the second parameter.
The two definitions are known as Church Booleans:


  
    
      
        
          
            
              
                true
              
              
                
                â¡
                Î»
                a
                .
                Î»
                b
                .
                a
              
            
            
              
                false
              
              
                
                â¡
                Î»
                a
                .
                Î»
                b
                .
                b
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {true} &\equiv \lambda a.\lambda b.a\\\operatorname {false} &\equiv \lambda a.\lambda b.b\end{aligned}}}
  

This definition allows predicates (i.e. functions returning logical values) to directly act as if-clauses.  A function returning a Boolean, which is then applied to two parameters, returns either the first or the second parameter:


  
    
      
        
          p
          r
          e
          d
          i
          c
          a
          t
          e
          -
        
        â¡
        x
        Â 
        
          t
          h
          e
          n
          -
          c
          l
          a
          u
          s
          e
        
        â¡
        Â 
        
          e
          l
          s
          e
          -
          c
          l
          a
          u
          s
          e
        
      
    
    {\displaystyle \operatorname {predicate-} x\ \operatorname {then-clause} \ \operatorname {else-clause} }
  

evaluates to then-clause if predicate-x evaluates to true, and to else-clause if predicate-x evaluates to false.
Because true and false choose the first or second parameter they may be combined to provide logic operators. Note that there are multiple possible implementations of not.


  
    
      
        
          
            
              
                and
              
              
                
                =
                Î»
                p
                .
                Î»
                q
                .
                p
                Â 
                q
                Â 
                p
              
            
            
              
                or
              
              
                
                =
                Î»
                p
                .
                Î»
                q
                .
                p
                Â 
                p
                Â 
                q
              
            
            
              
                
                  not
                  
                    1
                  
                
              
              
                
                =
                Î»
                p
                .
                Î»
                a
                .
                Î»
                b
                .
                p
                Â 
                b
                Â 
                a
              
            
            
              
                
                  not
                  
                    2
                  
                
              
              
                
                =
                Î»
                p
                .
                p
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                Î»
                p
                .
                p
                false
                â¡
                true
              
            
            
              
                xor
              
              
                
                =
                Î»
                a
                .
                Î»
                b
                .
                a
                Â 
                (
                not
                â¡
                Â 
                b
                )
                Â 
                b
              
            
            
              
                if
              
              
                
                =
                Î»
                p
                .
                Î»
                a
                .
                Î»
                b
                .
                p
                Â 
                a
                Â 
                b
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {and} &=\lambda p.\lambda q.p\ q\ p\\\operatorname {or} &=\lambda p.\lambda q.p\ p\ q\\\operatorname {not} _{1}&=\lambda p.\lambda a.\lambda b.p\ b\ a\\\operatorname {not} _{2}&=\lambda p.p\ (\lambda a.\lambda b.b)\ (\lambda a.\lambda b.a)=\lambda p.p\operatorname {false} \operatorname {true} \\\operatorname {xor} &=\lambda a.\lambda b.a\ (\operatorname {not} \ b)\ b\\\operatorname {if} &=\lambda p.\lambda a.\lambda b.p\ a\ b\end{aligned}}}
  

Some examples:


  
    
      
        
          
            
              
                and
                â¡
                true
                â¡
                false
              
              
                
                =
                (
                Î»
                p
                .
                Î»
                q
                .
                p
                Â 
                q
                Â 
                p
                )
                Â 
                true
                â¡
                Â 
                false
                =
                true
                â¡
                false
                â¡
                true
                =
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                false
                â¡
                true
                =
                false
              
            
            
              
                or
                â¡
                true
                â¡
                false
              
              
                
                =
                (
                Î»
                p
                .
                Î»
                q
                .
                p
                Â 
                p
                Â 
                q
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                =
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                =
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                true
              
            
            
              
                
                  not
                  
                    1
                  
                
                â¡
                Â 
                true
              
              
                
                =
                (
                Î»
                p
                .
                Î»
                a
                .
                Î»
                b
                .
                p
                Â 
                b
                Â 
                a
                )
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                Î»
                a
                .
                Î»
                b
                .
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                Â 
                b
                Â 
                a
                =
                Î»
                a
                .
                Î»
                b
                .
                (
                Î»
                c
                .
                b
                )
                Â 
                a
                =
                Î»
                a
                .
                Î»
                b
                .
                b
                =
                false
              
            
            
              
                
                  not
                  
                    2
                  
                
                â¡
                Â 
                true
              
              
                
                =
                (
                Î»
                p
                .
                p
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                )
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                (
                Î»
                b
                .
                (
                Î»
                a
                .
                Î»
                b
                .
                b
                )
                )
                Â 
                (
                Î»
                a
                .
                Î»
                b
                .
                a
                )
                =
                Î»
                a
                .
                Î»
                b
                .
                b
                =
                false
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {and} \operatorname {true} \operatorname {false} &=(\lambda p.\lambda q.p\ q\ p)\ \operatorname {true} \ \operatorname {false} =\operatorname {true} \operatorname {false} \operatorname {true} =(\lambda a.\lambda b.a)\operatorname {false} \operatorname {true} =\operatorname {false} \\\operatorname {or} \operatorname {true} \operatorname {false} &=(\lambda p.\lambda q.p\ p\ q)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b.a)\ (\lambda a.\lambda b.a)\ (\lambda a.\lambda b.b)=(\lambda a.\lambda b.a)=\operatorname {true} \\\operatorname {not} _{1}\ \operatorname {true} &=(\lambda p.\lambda a.\lambda b.p\ b\ a)(\lambda a.\lambda b.a)=\lambda a.\lambda b.(\lambda a.\lambda b.a)\ b\ a=\lambda a.\lambda b.(\lambda c.b)\ a=\lambda a.\lambda b.b=\operatorname {false} \\\operatorname {not} _{2}\ \operatorname {true} &=(\lambda p.p\ (\lambda a.\lambda b.b)(\lambda a.\lambda b.a))(\lambda a.\lambda b.a)=(\lambda a.\lambda b.a)(\lambda a.\lambda b.b)(\lambda a.\lambda b.a)=(\lambda b.(\lambda a.\lambda b.b))\ (\lambda a.\lambda b.a)=\lambda a.\lambda b.b=\operatorname {false} \end{aligned}}}
  

Predicates[edit]
A predicate is a function that returns a Boolean value. The most fundamental predicate is 
  
    
      
        IsZero
      
    
    {\displaystyle \operatorname {IsZero} }
  
, which returns 
  
    
      
        true
      
    
    {\displaystyle \operatorname {true} }
  
 if its argument is the Church numeral 
  
    
      
        0
      
    
    {\displaystyle 0}
  
, and 
  
    
      
        false
      
    
    {\displaystyle \operatorname {false} }
  
 if its argument is any other Church numeral:


  
    
      
        IsZero
        =
        Î»
        n
        .
        n
        Â 
        (
        Î»
        x
        .
        false
        )
        Â 
        true
      
    
    {\displaystyle \operatorname {IsZero} =\lambda n.n\ (\lambda x.\operatorname {false} )\ \operatorname {true} }
  

The following predicate tests whether the first argument is less-than-or-equal-to the second:


  
    
      
        LEQ
        =
        Î»
        m
        .
        Î»
        n
        .
        IsZero
        â¡
        Â 
        (
        minus
        â¡
        Â 
        m
        Â 
        n
        )
      
    
    {\displaystyle \operatorname {LEQ} =\lambda m.\lambda n.\operatorname {IsZero} \ (\operatorname {minus} \ m\ n)}
  
,
Because of the identity,


  
    
      
        x
        =
        y
        â¡
        (
        x
        â¤
        y
        â§
        y
        â¤
        x
        )
      
    
    {\displaystyle x=y\equiv (x\leq y\land y\leq x)}
  

The test for equality may be implemented as,


  
    
      
        EQ
        =
        Î»
        m
        .
        Î»
        n
        .
        and
        â¡
        Â 
        (
        LEQ
        â¡
        Â 
        m
        Â 
        n
        )
        Â 
        (
        LEQ
        â¡
        Â 
        n
        Â 
        m
        )
      
    
    {\displaystyle \operatorname {EQ} =\lambda m.\lambda n.\operatorname {and} \ (\operatorname {LEQ} \ m\ n)\ (\operatorname {LEQ} \ n\ m)}
  

Church pairs[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}See also: Cons
Church pairs are the Church encoding of the pair (two-tuple) type.  The pair is represented as a function that takes a function argument.  When given its argument it will apply the argument to the two components of the pair.  The definition in lambda calculus is,


  
    
      
        
          
            
              
                pair
              
              
                
                â¡
                Î»
                x
                .
                Î»
                y
                .
                Î»
                z
                .
                z
                Â 
                x
                Â 
                y
              
            
            
              
                first
              
              
                
                â¡
                Î»
                p
                .
                p
                Â 
                (
                Î»
                x
                .
                Î»
                y
                .
                x
                )
              
            
            
              
                second
              
              
                
                â¡
                Î»
                p
                .
                p
                Â 
                (
                Î»
                x
                .
                Î»
                y
                .
                y
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {pair} &\equiv \lambda x.\lambda y.\lambda z.z\ x\ y\\\operatorname {first} &\equiv \lambda p.p\ (\lambda x.\lambda y.x)\\\operatorname {second} &\equiv \lambda p.p\ (\lambda x.\lambda y.y)\end{aligned}}}
  

For example,


  
    
      
        
          
            
              
              
                first
                â¡
                Â 
                (
                pair
                â¡
                Â 
                a
                Â 
                b
                )
              
            
            
              
                =
              
              
                
                (
                Î»
                p
                .
                p
                Â 
                (
                Î»
                x
                .
                Î»
                y
                .
                x
                )
                )
                Â 
                (
                (
                Î»
                x
                .
                Î»
                y
                .
                Î»
                z
                .
                z
                Â 
                x
                Â 
                y
                )
                Â 
                a
                Â 
                b
                )
              
            
            
              
                =
              
              
                
                (
                Î»
                p
                .
                p
                Â 
                (
                Î»
                x
                .
                Î»
                y
                .
                x
                )
                )
                Â 
                (
                Î»
                z
                .
                z
                Â 
                a
                Â 
                b
                )
              
            
            
              
                =
              
              
                
                (
                Î»
                z
                .
                z
                Â 
                a
                Â 
                b
                )
                Â 
                (
                Î»
                x
                .
                Î»
                y
                .
                x
                )
              
            
            
              
                =
              
              
                
                (
                Î»
                x
                .
                Î»
                y
                .
                x
                )
                Â 
                a
                Â 
                b
                =
                a
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}&\operatorname {first} \ (\operatorname {pair} \ a\ b)\\=&(\lambda p.p\ (\lambda x.\lambda y.x))\ ((\lambda x.\lambda y.\lambda z.z\ x\ y)\ a\ b)\\=&(\lambda p.p\ (\lambda x.\lambda y.x))\ (\lambda z.z\ a\ b)\\=&(\lambda z.z\ a\ b)\ (\lambda x.\lambda y.x)\\=&(\lambda x.\lambda y.x)\ a\ b=a\end{aligned}}}
  

List encodings[edit]
An (immutable) list is constructed from list nodes.  The basic operations on the list are;




Function
Description


nil
Construct an empty list.


isnil
Test if list is empty.


cons
Prepend a given value to a (possibly empty) list.


head
Get the first element of the list.


tail
Get the rest of the list.

We give four different representations of lists below:

Build each list node from two pairs (to allow for empty lists).
Build each list node from one pair.
Represent the list using the right fold function.
Represent the list using Scott's encoding that takes cases of match expression as arguments
Two pairs as a list node[edit]
A nonempty list can be implemented by a Church pair;

First contains the head.
Second contains the tail.
However this does not give a representation of the empty list, because there is no "null" pointer.  To represent null, the pair may be wrapped in another pair, giving free values,

First - Is the null pointer (empty list).
Second.First contains the head.
Second.Second contains the tail.
Using this idea the basic list operations can be defined like this:[6]




Expression
Description



  
    
      
        nil
        â¡
        pair
        â¡
        Â 
        true
        â¡
        Â 
        true
      
    
    {\displaystyle \operatorname {nil} \equiv \operatorname {pair} \ \operatorname {true} \ \operatorname {true} }
  


The first element of the pair is true meaning the list is null.



  
    
      
        isnil
        â¡
        first
      
    
    {\displaystyle \operatorname {isnil} \equiv \operatorname {first} }
  


Retrieve the null (or empty list) indicator.



  
    
      
        cons
        â¡
        Î»
        h
        .
        Î»
        t
        .
        pair
        â¡
        false
        â¡
        Â 
        (
        pair
        â¡
        h
        Â 
        t
        )
      
    
    {\displaystyle \operatorname {cons} \equiv \lambda h.\lambda t.\operatorname {pair} \operatorname {false} \ (\operatorname {pair} h\ t)}
  


Create a list node, which is not null, and give it a head h and a tail t.



  
    
      
        head
        â¡
        Î»
        z
        .
        first
        â¡
        Â 
        (
        second
        â¡
        z
        )
      
    
    {\displaystyle \operatorname {head} \equiv \lambda z.\operatorname {first} \ (\operatorname {second} z)}
  


second.first is the head.



  
    
      
        tail
        â¡
        Î»
        z
        .
        second
        â¡
        Â 
        (
        second
        â¡
        z
        )
      
    
    {\displaystyle \operatorname {tail} \equiv \lambda z.\operatorname {second} \ (\operatorname {second} z)}
  


second.second is the tail.

In a nil node second is never accessed, provided that head and tail are only applied to nonempty lists.

One pair as a list node[edit]
Alternatively, define[7]


  
    
      
        
          
            
              
                cons
              
              
                
                â¡
                pair
              
            
            
              
                head
              
              
                
                â¡
                first
              
            
            
              
                tail
              
              
                
                â¡
                second
              
            
            
              
                nil
              
              
                
                â¡
                false
              
            
            
              
                isnil
              
              
                
                â¡
                Î»
                l
                .
                l
                (
                Î»
                h
                .
                Î»
                t
                .
                Î»
                d
                .
                false
                )
                true
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {cons} &\equiv \operatorname {pair} \\\operatorname {head} &\equiv \operatorname {first} \\\operatorname {tail} &\equiv \operatorname {second} \\\operatorname {nil} &\equiv \operatorname {false} \\\operatorname {isnil} &\equiv \lambda l.l(\lambda h.\lambda t.\lambda d.\operatorname {false} )\operatorname {true} \end{aligned}}}
  

where the last definition is a special case of the general


  
    
      
        
          p
          r
          o
          c
          e
          s
          s
          -
          l
          i
          s
          t
        
        â¡
        Î»
        l
        .
        l
        (
        Î»
        h
        .
        Î»
        t
        .
        Î»
        d
        .
        
          h
          e
          a
          d
          -
          a
          n
          d
          -
          t
          a
          i
          l
          -
          c
          l
          a
          u
          s
          e
        
        )
        
          n
          i
          l
          -
          c
          l
          a
          u
          s
          e
        
      
    
    {\displaystyle \operatorname {process-list} \equiv \lambda l.l(\lambda h.\lambda t.\lambda d.\operatorname {head-and-tail-clause} )\operatorname {nil-clause} }
  

Represent the list using right fold[edit]
As an alternative to the encoding using Church pairs, a list can be encoded by identifying it with its right fold function.  For example, a list of three elements x, y and z can be encoded by a higher-order function that when applied to a combinator c and a value n returns c x (c y (c z n)).


  
    
      
        
          
            
              
                nil
              
              
                
                â¡
                Î»
                c
                .
                Î»
                n
                .
                n
              
            
            
              
                isnil
              
              
                
                â¡
                Î»
                l
                .
                l
                Â 
                (
                Î»
                h
                .
                Î»
                t
                .
                false
                )
                Â 
                true
              
            
            
              
                cons
              
              
                
                â¡
                Î»
                h
                .
                Î»
                t
                .
                Î»
                c
                .
                Î»
                n
                .
                c
                Â 
                h
                Â 
                (
                t
                Â 
                c
                Â 
                n
                )
              
            
            
              
                head
              
              
                
                â¡
                Î»
                l
                .
                l
                Â 
                (
                Î»
                h
                .
                Î»
                t
                .
                h
                )
                Â 
                false
              
            
            
              
                tail
              
              
                
                â¡
                Î»
                l
                .
                Î»
                c
                .
                Î»
                n
                .
                l
                Â 
                (
                Î»
                h
                .
                Î»
                t
                .
                Î»
                g
                .
                g
                Â 
                h
                Â 
                (
                t
                Â 
                c
                )
                )
                Â 
                (
                Î»
                t
                .
                n
                )
                Â 
                (
                Î»
                h
                .
                Î»
                t
                .
                t
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\operatorname {nil} &\equiv \lambda c.\lambda n.n\\\operatorname {isnil} &\equiv \lambda l.l\ (\lambda h.\lambda t.\operatorname {false} )\ \operatorname {true} \\\operatorname {cons} &\equiv \lambda h.\lambda t.\lambda c.\lambda n.c\ h\ (t\ c\ n)\\\operatorname {head} &\equiv \lambda l.l\ (\lambda h.\lambda t.h)\ \operatorname {false} \\\operatorname {tail} &\equiv \lambda l.\lambda c.\lambda n.l\ (\lambda h.\lambda t.\lambda g.g\ h\ (t\ c))\ (\lambda t.n)\ (\lambda h.\lambda t.t)\end{aligned}}}
  

This list representation can be given type in System F.

Represent the list using Scott encoding[edit]
An alternative representation is Scott encoding, which uses the idea of continuations and can lead to simpler code.[8] (see also MogensenâScott encoding).
In this approach, we use the fact that lists can be observed using pattern matching expression. For example, using Scala notation, if list denotes a value of type List with empty list Nil and constructor Cons(h, t) we can inspect the list and compute nilCode in case the list is empty and consCode(h, t) when the list is not empty:

list match {
  case Nil        => nilCode
  case Cons(h, t) => consCode(h,t)
}

The 'list' is given by how it acts upon 'nilCode' and 'consCode'. We therefore define a list as a function that accepts such 'nilCode' and 'consCode' as arguments, so that instead of the above pattern match we may simply write:


  
    
      
        list
        â¡
        Â 
        nilCode
        â¡
        Â 
        consCode
      
    
    {\displaystyle \operatorname {list} \ \operatorname {nilCode} \ \operatorname {consCode} }
  

Let us denote by 'n' the parameter corresponding to 'nilCode' and by 'c' the parameter corresponding to 'consCode'.
The empty list is the one that returns the nil argument:


  
    
      
        nil
        â¡
        Î»
        n
        .
        Î»
        c
        .
        Â 
        n
      
    
    {\displaystyle \operatorname {nil} \equiv \lambda n.\lambda c.\ n}
  

The non-empty list with head 'h' and tail 't' is given by


  
    
      
        cons
        â¡
        Â 
        h
        Â 
        t
        Â 
        Â 
        â¡
        Â 
        Â 
        Î»
        n
        .
        Î»
        c
        .
        Â 
        c
        Â 
        h
        Â 
        t
      
    
    {\displaystyle \operatorname {cons} \ h\ t\ \ \equiv \ \ \lambda n.\lambda c.\ c\ h\ t}
  

More generally, an algebraic data type with 
  
    
      
        m
      
    
    {\displaystyle m}
  
 alternatives becomes a function with 
  
    
      
        m
      
    
    {\displaystyle m}
  
 parameters. When the 
  
    
      
        i
      
    
    {\displaystyle i}
  
th constructor has 
  
    
      
        
          n
          
            i
          
        
      
    
    {\displaystyle n_{i}}
  
 arguments, the corresponding parameter of the encoding takes 
  
    
      
        
          n
          
            i
          
        
      
    
    {\displaystyle n_{i}}
  
 arguments as well.
Scott encoding can be done in untyped lambda calculus, whereas its use with types requires a type system with recursion and type polymorphism. A list with element type E in this representation that is used to compute values of type C would have the following recursive type definition, where '=>' denotes function type:

type List = 
  C =>                    // nil argument
  (E => List => C) =>     // cons argument
  C                       // result of pattern matching

A list that can be used to compute arbitrary types would have a type that quantifies over C. A list generic[clarification needed] in E would also take E as the type argument.

See also[edit]
Lambda calculus
System F for Church numerals in a typed calculus
MogensenâScott encoding
Von Neumann definition of ordinals â another way to encode natural numbers: as sets
Notes[edit]

^ This formula is the definition of a Church numeral n with f -> m, x -> f.

^ 
.mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Allison, Lloyd. "Lambda Calculus Integers".

^ 
Bauer, Andrej. "Andrej's answer to a question; "Representing negative and complex numbers using lambda calculus"".

^ 
"Exact real arithmetic". Haskell.{{cite web}}:  CS1 maint: url-status (link)

^ 
Bauer, Andrej. "Real number computational software".

^ Pierce, Benjamin C. (2002). Types and Programming Languages. MIT Press. p.Â 500. ISBNÂ 978-0-262-16209-8.

^ Tromp, John (2007). "14. Binary Lambda Calculus and Combinatory Logic".  In Calude, Cristian S (ed.). Randomness And Complexity, From Leibniz To Chaitin. World Scientific. pp.Â 237â262. ISBNÂ 978-981-4474-39-9.As PDF: Tromp, John (14 May 2014). "Binary Lambda Calculus and Combinatory Logic" (PDF). Retrieved 2017-11-24.

^ Jansen, Jan Martin (2013). "Programming in the Î»-Calculus: From Church to Scott and Back". LNCS. 8106: 168â180. doi:10.1007/978-3-642-40355-2_12.


References[edit]
Directly Reflective Meta-Programming
Church numerals and booleans explained by Robert Cartwright at Rice University
Theoretical Foundations For Practical 'Totally Functional Programming' (Chapters 2 and 5) All about Church and other similar encodings, including how to derive them and operations on them, from first principles
Some interactive examples of Church numerals
Lambda Calculus Live Tutorial: Boolean Algebra




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Church_encoding&oldid=1060487318"
		Categories: Lambda calculusHidden categories: CS1 maint: url-statusArticles with short descriptionShort description matches WikidataArticles with specifically marked weasel-worded phrases from September 2021Wikipedia articles needing clarification from December 2019
	
