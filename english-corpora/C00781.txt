
Title:
Fixed-point combinator
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Higher-order function Y for which Y f = f (Y f)
In mathematics and computer science in general, a fixed point of a function is a value that is mapped to itself by the function.
In combinatory logic for computer science, a fixed-point combinator (or fixpoint combinator)[1]:âpage 26â is a higher-order function 
  
    
      
        
          
            fix
          
        
      
    
    {\displaystyle {\textsf {fix}}}
  
 that returns some fixed point of its argument function, if one exists.
Formally, if the function f has one or more fixed points, then


  
    
      
        
          
            fix
          
        
        Â 
        f
        =
        f
        Â 
        (
        
          
            fix
          
        
        Â 
        f
        )
        Â 
        ,
      
    
    {\displaystyle {\textsf {fix}}\ f=f\ ({\textsf {fix}}\ f)\ ,}
  

and hence, by repeated application,


  
    
      
        
          
            fix
          
        
        Â 
        f
        =
        f
        Â 
        (
        f
        Â 
        (
        â¦
        f
        Â 
        (
        
          
            fix
          
        
        Â 
        f
        )
        â¦
        )
        )
        Â 
        .
      
    
    {\displaystyle {\textsf {fix}}\ f=f\ (f\ (\ldots f\ ({\textsf {fix}}\ f)\ldots ))\ .}
  

Contents

1 Y combinator
2 Fixed-point combinator

2.1 Values and domains
2.2 Function versus implementation
2.3 What is a "combinator"?


3 Usage in programming

3.1 The factorial function


4 Fixed-point combinators in lambda calculus

4.1 Equivalent definition of a fixed-point combinator
4.2 Derivation of the Y combinator
4.3 Other fixed-point combinators
4.4 Strict fixed-point combinator
4.5 Non-standard fixed-point combinators


5 Implementation in other languages

5.1 Lazy functional implementation
5.2 Strict functional implementation
5.3 Imperative language implementation


6 Typing

6.1 Type for the Y combinator


7 General information
8 See also
9 Notes
10 References
11 External links



Y combinator[edit]
In the classical untyped lambda calculus, every function has a fixed point.
A particular implementation of fix is Curry's paradoxical combinator Y, represented by


  
    
      
        
          
            Y
          
        
        =
        Î»
        f
        .
        Â 
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        .
      
    
    {\displaystyle {\textsf {Y}}=\lambda f.\ (\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\ .}
  
[2]:â131â[note 1][note 2]
In functional programming, the Y combinator can be used to formally define recursive functions in a programming language that does not support recursion.
This combinator may be used in implementing Curry's paradox.  The heart of Curry's paradox is that untyped lambda calculus is unsound as a deductive system, and the Y combinator demonstrates that by allowing an anonymous expression to represent zero, or even many values.  This is inconsistent in mathematical logic.
Applied to a function with one variable the Y combinator usually does not terminate.  More interesting results are obtained by applying the Y combinator to functions of two or more variables.  The second variable may be used as a counter, or index.  The resulting function behaves like a while or a for loop in an imperative language.
Used in this way the Y combinator implements simple recursion.  In the lambda calculus it is not possible to refer to the definition of a function in a function body.  Recursion may only be achieved by passing in a function as a parameter.  The Y combinator demonstrates this style of programming.

Fixed-point combinator[edit]
The Y combinator is an implementation of a fixed-point combinator in lambda calculus.  Fixed-point combinators may also be easily defined in other functional and imperative languages.  The implementation in lambda calculus is more difficult due to limitations in lambda calculus.
The fixed-point combinator may be used in a number of different areas:

General mathematics
Untyped lambda calculus
Typed lambda calculus
Functional programming
Imperative programming
Fixed-point combinators may be applied to a range of different functions, but normally will not terminate unless there is an extra parameter.  When the function to be fixed refers to its parameter, another call to the function is invoked, so the calculation never gets started.  Instead, the extra parameter is used to trigger the start of the calculation.
The type of the fixed point is the return type of the function being fixed.  This may be a real or a function or any other type.
In the untyped lambda calculus, the function to apply the fixed-point combinator to may be expressed using an encoding, like Church encoding.  In this case particular lambda terms (which define functions) are considered as values.  "Running" (beta reducing) the fixed-point combinator on the encoding gives a lambda term for the result which may then be interpreted as fixed-point value.
Alternately, a function may be considered as a lambda term defined purely in lambda calculus.
These different approaches affect how a mathematician and a programmer may regard a fixed-point combinator.  A lambda calculus mathematician may see the Y combinator applied to a function as being an expression satisfying the fixed-point equation, and therefore a solution.
In contrast, a person only wanting to apply a fixed-point combinator to some general programming task may see it only as a means of implementing recursion.

Values and domains[edit]
Every expression has one value.  This is true in general mathematics and it must be true in lambda calculus.  This means that in lambda calculus, applying a fixed-point combinator to a function gives you an expression whose value is the fixed point of the function.
However, this is a value in the lambda calculus domain, it may not correspond to any value in the domain of the function,  so in a practical sense it is not necessarily a fixed point of the function, and only in the lambda calculus domain is it a fixed point of the equation.
For example, consider


  
    
      
        
          x
          
            2
          
        
        =
        â
        1
        â
        x
        =
        
          
            
              â
              1
            
            x
          
        
        â
        f
        Â 
        x
        =
        
          
            
              â
              1
            
            x
          
        
        â§
        
          
            Y
          
        
        Â 
        f
        =
        x
      
    
    {\displaystyle x^{2}=-1\Rightarrow x={\frac {-1}{x}}\Rightarrow f\ x={\frac {-1}{x}}\land {\mathsf {Y}}\ f=x}
  

Division of signed numbers may be implemented in the Church encoding, so f may be represented by a lambda term.  This equation has no solution in the real numbers.  But in the domain of the complex numbers i and -i are solutions.  This demonstrates that there may be solutions to an equation in another domain.  However, the lambda term for the solution for the above equation is weirder than that.  The lambda term 
  
    
      
        
          
            Y
          
        
        Â 
        f
      
    
    {\displaystyle {\mathsf {Y}}\ f}
  
 represents the state where x could be either i or -i, as one value.  The information distinguishing these two values has been lost, in the change of domain.
For the lambda calculus mathematician, this is a consequence of the definition of lambda calculus.  For the programmer, it means that the beta reduction of the lambda term will loop forever, never reaching a normal form.

Function versus implementation[edit]
The fixed-point combinator may be defined in mathematics and then implemented in other languages. General mathematics defines a function based on its extensional properties.[3] That is, two functions are equal if they perform the same mapping. Lambda calculus and programming languages regard function identity as an intensional property. A function's identity is based on its implementation.
A lambda calculus function (or term) is an implementation of a mathematical function.  In the lambda calculus there are a number of combinator (implementations) that satisfy the mathematical definition of a fixed-point combinator.

What is a "combinator"?[edit]
Combinatory logic is a higher-order functions theory. A combinator is a closed lambda expression, meaning that it has no free variables. The combinators may be combined to direct values to their correct places in the expression without ever naming them as variables.

Usage in programming[edit]
Fixed-point combinators can be used to implement recursive definition of functions. However, they are rarely used in practical programming.[4] Strongly normalizing type systems such as the simply typed lambda calculus disallow non-termination and hence fixed-point combinators often cannot be assigned a type or require complex type system features. Furthermore fixed-point combinators are often inefficient compared to other strategies for implementing recursion, as they require more function reductions and construct and take apart a tuple for each group of mutually recursive definitions.[1]:âpage 232â

The factorial function[edit]
The factorial function provides a good example of how the fixed-point combinator may be applied. The result demonstrates simple recursion, as would be implemented in a single loop in an imperative language.  The definition of numbers used is explained in Church encoding.
The function taking itself as a parameter is


  
    
      
        F
        Â 
        f
        Â 
        n
        =
        (
        IsZero
        â¡
        Â 
        n
        )
        Â 
        1
        Â 
        (
        multiply
        â¡
        Â 
        n
        Â 
        (
        f
        Â 
        (
        pred
        â¡
        Â 
        n
        )
        )
        )
        Â 
        .
      
    
    {\displaystyle F\ f\ n=(\operatorname {IsZero} \ n)\ 1\ (\operatorname {multiply} \ n\ (f\ (\operatorname {pred} \ n)))\ .}
  

This gives Y F n as


  
    
      
        
          
            
              
                
                  
                    fix
                  
                
                Â 
                F
                Â 
                n
              
              
                
                =
                F
                Â 
                (
                
                  
                    fix
                  
                
                Â 
                F
                )
                Â 
                n
              
            
            
              
              
                
                =
                (
                IsZero
                â¡
                Â 
                n
                )
                Â 
                1
                Â 
                (
                multiply
                â¡
                Â 
                n
                Â 
                (
                (
                
                  
                    fix
                  
                
                Â 
                F
                )
                Â 
                (
                pred
                â¡
                Â 
                n
                )
                )
                )
                Â 
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}{\textsf {fix}}\ F\ n&=F\ ({\textsf {fix}}\ F)\ n\\&=(\operatorname {IsZero} \ n)\ 1\ (\operatorname {multiply} \ n\ (({\textsf {fix}}\ F)\ (\operatorname {pred} \ n)))\ .\end{aligned}}}
  

Setting 
  
    
      
        
          
            fix
          
        
        Â 
        F
        =
        fact
      
    
    {\displaystyle {\textsf {fix}}\ F=\operatorname {fact} }
  
 gives


  
    
      
        fact
        â¡
        Â 
        n
        =
        (
        IsZero
        â¡
        Â 
        n
        )
        Â 
        1
        Â 
        (
        multiply
        â¡
        Â 
        n
        Â 
        (
        fact
        â¡
        Â 
        (
        pred
        â¡
        Â 
        n
        )
        )
        )
        Â 
        .
      
    
    {\displaystyle \operatorname {fact} \ n=(\operatorname {IsZero} \ n)\ 1\ (\operatorname {multiply} \ n\ (\operatorname {fact} \ (\operatorname {pred} \ n)))\ .}
  

This definition puts F in the role of the body of a loop to be iterated, and is equivalent to the mathematical definition of factorial:


  
    
      
        fact
        â¡
        Â 
        n
        =
        
          
            {
            
              
                
                  1
                
                
                  
                    if
                  
                  Â 
                  n
                  =
                  0
                
              
              
                
                  n
                  Ã
                  fact
                  â¡
                  Â 
                  (
                  n
                  â
                  1
                  )
                
                
                  
                    otherwise.
                  
                
              
            
            
          
        
      
    
    {\displaystyle \operatorname {fact} \ n={\begin{cases}1&{\text{if}}~n=0\\n\times \operatorname {fact} \ (n-1)&{\text{otherwise.}}\end{cases}}}
  

Fixed-point combinators in lambda calculus[edit]
The Y combinator, discovered by Haskell B. Curry, is defined as


  
    
      
        Y
        =
        Î»
        f
        .
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        .
      
    
    {\displaystyle Y=\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\ .}
  

Beta reduction of this gives:




  
    
      
        Y
        Â 
        g
      
    
    {\displaystyle Y\ g}
  



  
    
      
        =
        (
        Î»
        f
        .
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        Â 
        (
        x
        Â 
        x
        )
        )
        )
        Â 
        g
      
    
    {\displaystyle =(\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)))\ g}
  


(by definition of Y)





  
    
      
        =
        (
        Î»
        x
        .
        g
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        g
        Â 
        (
        x
        Â 
        x
        )
        )
      
    
    {\displaystyle =(\lambda x.g\ (x\ x))\ (\lambda x.g\ (x\ x))}
  


(by Î²-reduction of Î»f: applied Y to g)





  
    
      
        =
        g
        Â 
        (
        (
        Î»
        x
        .
        g
        Â 
        (
        x
        Â 
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        g
        Â 
        (
        x
        Â 
        x
        )
        )
        )
      
    
    {\displaystyle =g\ ((\lambda x.g\ (x\ x))\ (\lambda x.g\ (x\ x)))}
  


(by Î²-reduction of Î»x: applied left function to right function)





  
    
      
        =
        g
        Â 
        (
        Y
        Â 
        g
        )
      
    
    {\displaystyle =g\ (Y\ g)}
  


(by second equality)

Repeatedly applying this equality gives:


  
    
      
        Y
        Â 
        g
        =
        g
        Â 
        (
        Y
        Â 
        g
        )
        =
        g
        Â 
        (
        g
        Â 
        (
        Y
        Â 
        g
        )
        )
        =
        g
        Â 
        (
        â¦
        g
        Â 
        (
        Y
        Â 
        g
        )
        â¦
        )
      
    
    {\displaystyle Y\ g=g\ (Y\ g)=g\ (g\ (Y\ g))=g\ (\ldots g\ (Y\ g)\ldots )}
  

(The equality above should be thought of as a sequence of multi-step Î²-reductions from left to right. The lambda term 
  
    
      
        g
        Â 
        (
        Y
        Â 
        g
        )
      
    
    {\displaystyle g\ (Y\ g)}
  
 may not, in general, Î²-reduce to the term 
  
    
      
        Y
        Â 
        g
      
    
    {\displaystyle Y\ g}
  
. One can interpret the equality signs as Î²-equivalences instead of multi-step Î²-reductions to allow for going in both directions.)

Equivalent definition of a fixed-point combinator[edit]
This fixed-point combinator may be defined as y, as in


  
    
      
        x
        =
        f
        Â 
        x
        â§
        y
        Â 
        f
        =
        x
      
    
    {\displaystyle x=f\ x\land y\ f=x}
  

An expression for y may be derived using rules from the definition of a let expression.  Firstly, using the rule


  
    
      
        (
        â
        x
        E
        â§
        F
        )
        
        âº
        
        let
        â¡
        x
        :
        E
        in
        â¡
        F
      
    
    {\displaystyle (\exists xE\land F)\iff \operatorname {let} x:E\operatorname {in} F}
  

gives


  
    
      
        let
        â¡
        x
        =
        f
        Â 
        x
        in
        â¡
        y
        Â 
        f
        =
        x
        Â 
        .
      
    
    {\displaystyle \operatorname {let} x=f\ x\operatorname {in} y\ f=x\ .}
  

Also, using


  
    
      
        x
        â
        FV
        â¡
        (
        E
        )
        â§
        x
        â
        FV
        â¡
        (
        F
        )
        â
        let
        â¡
        x
        :
        G
        in
        â¡
        E
        Â 
        F
        =
        E
        Â 
        (
        let
        â¡
        x
        :
        G
        in
        â¡
        F
        )
      
    
    {\displaystyle x\not \in \operatorname {FV} (E)\land x\in \operatorname {FV} (F)\to \operatorname {let} x:G\operatorname {in} E\ F=E\ (\operatorname {let} x:G\operatorname {in} F)}
  

gives


  
    
      
        y
        Â 
        f
        =
        let
        â¡
        x
        =
        f
        Â 
        x
        in
        â¡
        x
        Â 
        .
      
    
    {\displaystyle y\ f=\operatorname {let} x=f\ x\operatorname {in} x\ .}
  

And then using the eta reduction rule,


  
    
      
        f
        Â 
        x
        =
        y
        
        âº
        
        f
        =
        Î»
        x
        .
        y
        Â 
        ,
      
    
    {\displaystyle f\ x=y\iff f=\lambda x.y\ ,}
  

gives


  
    
      
        y
        =
        Î»
        f
        .
        let
        â¡
        x
        =
        f
        Â 
        x
        in
        â¡
        x
        Â 
        .
      
    
    {\displaystyle y=\lambda f.\operatorname {let} x=f\ x\operatorname {in} x\ .}
  

Derivation of the Y combinator[edit]
Curry's Y combinator may be readily obtained from the definition of y.[5]
Starting with,


  
    
      
        Î»
        f
        .
        let
        â¡
        x
        =
        f
        Â 
        x
        in
        â¡
        x
        Â 
        ,
      
    
    {\displaystyle \lambda f.\operatorname {let} x=f\ x\operatorname {in} x\ ,}
  

A lambda abstraction does not support reference to the variable name, in the applied expression, so x must be passed in as a parameter to x.  We can think of this as replacing x by x x, but formally this is not correct.  Instead defining y by 
  
    
      
        â
        z
        ,
        y
        Â 
        z
        =
        x
      
    
    {\displaystyle \forall z,y\ z=x}
  
 gives


  
    
      
        Î»
        f
        .
        let
        â¡
        y
        Â 
        z
        =
        f
        Â 
        (
        y
        Â 
        z
        )
        in
        â¡
        y
        Â 
        z
        Â 
        .
      
    
    {\displaystyle \lambda f.\operatorname {let} y\ z=f\ (y\ z)\operatorname {in} y\ z\ .}
  

The let expression may be regarded as the definition of the function y, where z is the parameter.  Instantiation z as y in the call gives


  
    
      
        Î»
        f
        .
        let
        â¡
        y
        Â 
        z
        =
        f
        Â 
        (
        y
        Â 
        z
        )
        in
        â¡
        y
        Â 
        y
        Â 
        .
      
    
    {\displaystyle \lambda f.\operatorname {let} y\ z=f\ (y\ z)\operatorname {in} y\ y\ .}
  

And, because the parameter z always passes the function y,


  
    
      
        Î»
        f
        .
        let
        â¡
        y
        Â 
        z
        =
        f
        Â 
        (
        z
        Â 
        z
        )
        in
        â¡
        y
        Â 
        y
        Â 
        .
      
    
    {\displaystyle \lambda f.\operatorname {let} y\ z=f\ (z\ z)\operatorname {in} y\ y\ .}
  

Using the eta reduction rule,


  
    
      
        f
        Â 
        x
        =
        y
        â¡
        f
        =
        Î»
        x
        .
        y
        Â 
        ,
      
    
    {\displaystyle f\ x=y\equiv f=\lambda x.y\ ,}
  

gives


  
    
      
        Î»
        f
        .
        let
        â¡
        y
        =
        Î»
        z
        .
        f
        Â 
        (
        z
        Â 
        z
        )
        in
        â¡
        y
        Â 
        y
        Â 
        .
      
    
    {\displaystyle \lambda f.\operatorname {let} y=\lambda z.f\ (z\ z)\operatorname {in} y\ y\ .}
  

A let expression may be expressed as a lambda abstraction; using


  
    
      
        n
        â
        F
        V
        (
        E
        )
        â
        (
        let
        â¡
        n
        =
        E
        in
        â¡
        L
        â¡
        (
        Î»
        n
        .
        L
        )
        Â 
        E
        )
      
    
    {\displaystyle n\not \in FV(E)\to (\operatorname {let} n=E\operatorname {in} L\equiv (\lambda n.L)\ E)}
  

gives


  
    
      
        Î»
        f
        .
        (
        Î»
        y
        .
        y
        Â 
        y
        )
        Â 
        (
        Î»
        z
        .
        f
        Â 
        (
        z
        Â 
        z
        )
        )
        Â 
        .
      
    
    {\displaystyle \lambda f.(\lambda y.y\ y)\ (\lambda z.f\ (z\ z))\ .}
  

This is possibly the simplest implementation of a fixed-point combinator in lambda calculus.  However, one beta reduction gives the more symmetrical form of Curry's Y combinator:


  
    
      
        Î»
        f
        .
        (
        Î»
        z
        .
        f
        Â 
        (
        z
        Â 
        z
        )
        )
        Â 
        (
        Î»
        z
        .
        f
        Â 
        (
        z
        Â 
        z
        )
        )
        Â 
        .
      
    
    {\displaystyle \lambda f.(\lambda z.f\ (z\ z))\ (\lambda z.f\ (z\ z))\ .}
  

See also Translating between let and lambda expressions.

Other fixed-point combinators[edit]
In untyped lambda calculus fixed-point combinators are not especially rare. In fact there are infinitely many of them.[6] In 2005 Mayer Goldberg showed that the set of fixed-point combinators of untyped lambda calculus is recursively enumerable.[7]
The Y combinator can be expressed in the SKI-calculus as


  
    
      
        Y
        =
        S
        (
        K
        (
        S
        I
        I
        )
        )
        (
        S
        (
        S
        (
        K
        S
        )
        K
        )
        (
        K
        (
        S
        I
        I
        )
        )
        )
        Â 
        .
      
    
    {\displaystyle Y=S(K(SII))(S(S(KS)K)(K(SII)))\ .}
  

The simplest fixed-point combinator in the SK-calculus, found by John Tromp, is


  
    
      
        
          Y
          â²
        
        =
        S
        S
        K
        (
        S
        (
        K
        (
        S
        S
        (
        S
        (
        S
        S
        K
        )
        )
        )
        )
        K
        )
        Â 
        .
      
    
    {\displaystyle Y'=SSK(S(K(SS(S(SSK))))K)\ .}
  

although note that it is not in normal form, which is longer. This combinator corresponds to the lambda expression


  
    
      
        
          Y
          â²
        
        =
        (
        Î»
        x
        y
        .
        x
        y
        x
        )
        (
        Î»
        y
        x
        .
        y
        (
        x
        y
        x
        )
        )
        Â 
        .
      
    
    {\displaystyle Y'=(\lambda xy.xyx)(\lambda yx.y(xyx))\ .}
  

The following fixed-point combinator is simpler than the Y combinator, and Î²-reduces into the Y combinator; it is sometimes cited as the Y combinator itself:


  
    
      
        X
        =
        Î»
        f
        .
        (
        Î»
        x
        .
        x
        x
        )
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        Â 
        .
      
    
    {\displaystyle X=\lambda f.(\lambda x.xx)(\lambda x.f(xx))\ .}
  

Another common fixed-point combinator is the Turing fixed-point combinator (named after its discoverer, Alan Turing):[8][2]:â132â


  
    
      
        Î
        =
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        .
      
    
    {\displaystyle \Theta =(\lambda xy.y(xxy))\ (\lambda xy.y(xxy))\ .}
  

Its advantage over 
  
    
      
        
          
            Y
          
        
      
    
    {\displaystyle {\textsf {Y}}}
  
 is that 
  
    
      
        Î
        Â 
        f
      
    
    {\displaystyle \Theta \ f}
  
 beta-reduces to 
  
    
      
        f
        Â 
        (
        Î
        f
        )
      
    
    {\displaystyle f\ (\Theta f)}
  
,[note 3]
whereas 
  
    
      
        
          
            Y
          
        
        Â 
        f
      
    
    {\displaystyle {\textsf {Y}}\ f}
  
 and 
  
    
      
        f
        Â 
        (
        
          
            Y
          
        
        f
        )
      
    
    {\displaystyle f\ ({\textsf {Y}}f)}
  
 only beta-reduce to a common term.[note 2]

  
    
      
        Î
      
    
    {\displaystyle \Theta }
  
 also has a simple call-by-value form:


  
    
      
        
          Î
          
            v
          
        
        =
        (
        Î»
        x
        y
        .
        y
        (
        Î»
        z
        .
        x
        x
        y
        z
        )
        )
        Â 
        (
        Î»
        x
        y
        .
        y
        (
        Î»
        z
        .
        x
        x
        y
        z
        )
        )
        Â 
        .
      
    
    {\displaystyle \Theta _{v}=(\lambda xy.y(\lambda z.xxyz))\ (\lambda xy.y(\lambda z.xxyz))\ .}
  

The analog for mutual recursion is a polyvariadic fix-point combinator,[9][10][11] which may be denoted Y*.

Strict fixed-point combinator[edit]
In a strict programming language the Y combinator will expand until stack overflow, or never halt in case of tail call optimization.[12] The Z combinator will work in strict languages (also called eager languages, where applicative evaluation order is applied). The Z combinator has the next argument defined explicitly, preventing the expansion of Z g in the right-hand side of the definition:[13]


  
    
      
        Z
        g
        v
        =
        g
        (
        Z
        g
        )
        v
        Â 
        .
      
    
    {\displaystyle Zgv=g(Zg)v\ .}
  

and in lambda calculus it is an eta-expansion of the Y combinator:


  
    
      
        Z
        =
        Î»
        f
        .
        (
        Î»
        x
        .
        f
        (
        Î»
        v
        .
        x
        x
        v
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        (
        Î»
        v
        .
        x
        x
        v
        )
        )
        Â 
        .
      
    
    {\displaystyle Z=\lambda f.(\lambda x.f(\lambda v.xxv))\ (\lambda x.f(\lambda v.xxv))\ .}
  

Non-standard fixed-point combinators[edit]
In untyped lambda calculus there are terms that have the same BÃ¶hm tree as a fixed-point combinator, that is they have the same infinite extension Î»x.x (x (x ... )). These are called non-standard fixed-point combinators. Any fixed-point combinator is also a non-standard one, but not all non-standard fixed-point combinators are fixed-point combinators because some of them fail to satisfy the equation that defines the "standard" ones. These strange combinators are called strictly non-standard fixed-point combinators; an example is the following combinator:


  
    
      
        N
        =
        B
        M
        (
        B
        (
        B
        M
        )
        B
        )
      
    
    {\displaystyle N=BM(B(BM)B)}
  

where


  
    
      
        B
        =
        Î»
        x
        y
        z
        .
        x
        (
        y
        z
        )
      
    
    {\displaystyle B=\lambda xyz.x(yz)}
  


  
    
      
        M
        =
        Î»
        x
        .
        x
        x
        Â 
        .
      
    
    {\displaystyle M=\lambda x.xx\ .}
  

The set of non-standard fixed-point combinators is not recursively enumerable.[7]

Implementation in other languages[edit]
(The Y combinator is a particular implementation of a fixed-point combinator in lambda calculus.  Its structure is determined by the limitations of lambda calculus.  It is not necessary or helpful to use this structure in implementing the fixed-point combinator in other languages.)
Simple examples of fixed-point combinators implemented in some programming paradigms are given below.

Lazy functional implementation[edit]
In a language that supports lazy evaluation, like in Haskell, it is possible to define a fixed-point combinator using the defining equation of the fixed-point combinator which is conventionally named fix.  Since Haskell has lazy datatypes, this combinator can also be used to define fixed points of data constructors (and not only to implement recursive functions). The definition is given here, followed by some usage examples. In Hackage, the original sample is: [14]

fix, fix' :: (a -> a) -> a
fix f = let x = f x in x         -- Lambda dropped. Sharing.
                                 -- Original definition in Data.Function.
-- alternative:
fix' f = f (fix' f)              -- Lambda lifted. Non-sharing.

fix (\x -> 9)                    -- this evaluates to 9

fix (\x -> 3:x)                  -- evaluates to the lazy infinite list [3,3,3,...]

fact = fix fac                   -- evaluates to the factorial function
  where fac f 0 = 1
        fac f x = x * f (x-1)

fact 5                           -- evaluates to 120

Strict functional implementation[edit]
In a strict functional language, the argument to f is expanded beforehand, yielding an infinite call sequence,


  
    
      
        f
        Â 
        (
        f
        .
        .
        .
        (
        f
        Â 
        (
        
          
            f
            i
            x
          
        
        Â 
        f
        )
        )
        .
        .
        .
        )
        Â 
        x
      
    
    {\displaystyle f\ (f...(f\ ({\mathsf {fix}}\ f))...)\ x}
  
.
This may be resolved by defining fix with an extra parameter.

let rec fix f x = f (fix f) x (* note the extra x; here fix f = \x-> f (fix f) x *)

let factabs fact = function   (* factabs has extra level of lambda abstraction *)
   0 -> 1
 | x -> x * fact (x-1)

let _ = (fix factabs) 5       (* evaluates to "120" *)

Imperative language implementation[edit]
This example is a slightly interpretive implementation of a fixed-point combinator.  A class is used to contain the fix function, called fixer.  The function to be fixed is contained in a class that inherits from fixer.  The fix function accesses the function to be fixed as a virtual function.  As for the strict functional definition, fix is explicitly given an extra parameter x, which means that lazy evaluation is not needed.

template <typename R, typename D>
class fixer
{
public:
    R fix(D x)
    {
        return f(x);
    }
private:
    virtual R f(D) = 0;
};

class fact : public fixer<long, long>
{
    virtual long f(long x)
    {
        if (x == 0)
        {
            return 1;
        }
        return x * fix(x-1);
    }
};

long result = fact().fix(5);

In an imperative-functional language, such as Lisp, Scheme, or Racket, Landin (1963)[full citation needed] suggests the use of a variable assignment to create a fixed-point combinator:

(define Y!
  (lambda (f-maker)
    ((lambda (f)
       (set! f (f-maker (lambda (x) (f x)))) ;; assignment statement
       f)
     'NONE)))

Using a lambda calculus with axioms for assignment statements, it can be shown that Y! satisfies the same fixed-point law as the call-by-value Y combinator:[15][16]


  
    
      
        (
        
          
            
              Y
            
          
          
            !
          
        
        Â 
        Î»
        x
        .
        e
        )
        
          e
          â²
        
        =
        (
        Î»
        x
        .
        e
        )
        Â 
        (
        
          
            
              Y
            
          
          
            !
          
        
        Â 
        Î»
        x
        .
        e
        )
        
          e
          â²
        
      
    
    {\displaystyle ({\textsf {Y}}_{!}\ \lambda x.e)e'=(\lambda x.e)\ ({\textsf {Y}}_{!}\ \lambda x.e)e'}
  

Typing[edit]
In System F (polymorphic lambda calculus) a polymorphic fixed-point combinator has type[citation needed];

âa.(a â a) â a
where a is a type variable.  That is, fix takes a function, which maps a â a and uses it to return a value of type a.
In the simply typed lambda calculus extended with recursive data types, fixed-point operators can be written, but the type of a "useful" fixed-point operator (one whose application always returns) may be restricted.
In the simply typed lambda calculus, the fixed-point combinator Y cannot be assigned a type[17] because at some point it would deal with the self-application sub-term 
  
    
      
        x
        Â 
        x
      
    
    {\displaystyle x~x}
  
 by the application rule:


  
    
      
        
          
            Î
            â¢
            x
            
            :
            
            
              t
              
                1
              
            
            â
            
              t
              
                2
              
            
            
            Î
            â¢
            x
            
            :
            
            
              t
              
                1
              
            
          
        
        
          Î
          â¢
          x
          Â 
          x
          
          :
          
          
            t
            
              2
            
          
        
      
    
    {\displaystyle {\Gamma \vdash x\!:\!t_{1}\to t_{2}\quad \Gamma \vdash x\!:\!t_{1}} \over {\Gamma \vdash x~x\!:\!t_{2}}}
  

where 
  
    
      
        x
      
    
    {\displaystyle x}
  
 has the infinite type 
  
    
      
        
          t
          
            1
          
        
        =
        
          t
          
            1
          
        
        â
        
          t
          
            2
          
        
      
    
    {\displaystyle t_{1}=t_{1}\to t_{2}}
  
. No fixed-point combinator can in fact be typed; in those systems, any support for recursion must be explicitly added to the language.

Type for the Y combinator[edit]
In programming languages that support recursive data types, it is possible to type the Y combinator by appropriately accounting for the recursion at the type level. The need to self-apply the variable x can be managed using a type (Rec a), which is defined so as to be isomorphic to (Rec a -> a).
For example, in the following Haskell code, we have In and out being the names of the two directions of the isomorphism, with types:[18][19]

In :: (Rec a -> a) -> Rec a
out :: Rec a -> (Rec a -> a)

which lets us write:

newtype Rec a = In { out :: Rec a -> a }

y :: (a -> a) -> a
y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))

Or equivalently in OCaml:

type 'a recc = In of ('a recc -> 'a)
let out (In x) = x

let y f = (fun x a -> f (out x x) a) (In (fun x a -> f (out x x) a))

Alternatively:

let y f = (fun x -> f (fun z -> out x x z)) (In (fun x -> f (fun z -> out x x z)))

General information[edit]
Because fixed-point combinators can be used to implement recursion, it is possible to use them to describe specific types of recursive computations, such as those in fixed-point iteration, iterative methods, recursive join in relational databases, data-flow analysis, FIRST and FOLLOW sets of non-terminals in a context-free grammar, transitive closure, and other types of closure operations.
A function for which every input is a fixed point is called an identity function. Formally:


  
    
      
        â
        x
        (
        f
        Â 
        x
        =
        x
        )
      
    
    {\displaystyle \forall x(f\ x=x)}
  

In contrast to universal quantification over all 
  
    
      
        x
      
    
    {\displaystyle x}
  
, a fixed-point combinator constructs one value that is a fixed point of 
  
    
      
        f
      
    
    {\displaystyle f}
  
. The remarkable property of a fixed-point combinator is that it constructs a fixed point for an arbitrary given function 
  
    
      
        f
      
    
    {\displaystyle f}
  
.
Other functions have the special property that, after being applied once, further applications don't have any effect. More formally:


  
    
      
        â
        x
        (
        f
        Â 
        (
        f
        Â 
        x
        )
        =
        f
        Â 
        x
        )
      
    
    {\displaystyle \forall x(f\ (f\ x)=f\ x)}
  

Such functions are called idempotent (see also Projection (mathematics)). An example of such a function is the function that returns 0 for all even integers, and 1 for all odd integers.
In lambda calculus, from a computational point of view, applying a fixed-point combinator to an identity function or an idempotent function typically results in non-terminating computation. For example, we obtain


  
    
      
        (
        Y
        Â 
        Î»
        x
        .
        x
        )
        =
        (
        Î»
        x
        .
        (
        x
        x
        )
        Â 
        Î»
        x
        .
        (
        x
        x
        )
        )
      
    
    {\displaystyle (Y\ \lambda x.x)=(\lambda x.(xx)\ \lambda x.(xx))}
  

where the resulting term can only reduce to itself and represents an infinite loop.
Fixed-point combinators do not necessarily exist in more restrictive models of computation. For instance, they do not exist in simply typed lambda calculus.
The Y combinator allows recursion to be defined as a set of rewrite rules,[20] without requiring native recursion support in the language.[21]
In programming languages that support anonymous functions, fixed-point combinators allow the definition and use of anonymous recursive functions, i.e. without having to bind such functions to identifiers. In this setting, the use of fixed-point combinators is sometimes called anonymous recursion.[note 4][22]

See also[edit]
Anonymous function
Fixed-point iteration
Lambda calculus#Recursion and fixed points
Lambda lifting
Let expression
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Throughout this article, the syntax rules given in Lambda calculus#Notation are used, to save parentheses.

^ Jump up to: a b For an arbitrary lambda term f, the fixed-point property can be validated by beta reducing the left- and the right-hand side:

  
    
      
        
          
            Y
          
        
        Â 
        f
      
    
    {\displaystyle {\textsf {Y}}\ f}
  


  
    
      
        â¡
      
    
    {\displaystyle \equiv }
  


  
    
      
        (
        Î»
        f
        .
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        )
        Â 
        f
      
    
    {\displaystyle (\lambda f.(\lambda x.f(xx))\ (\lambda x.f(xx)))\ f}
  


  
    
      
        â
      
    
    {\displaystyle \to }
  


  
    
      
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
      
    
    {\displaystyle (\lambda x.f(xx))\ (\lambda x.f(xx))}
  


  
    
      
        â
      
    
    {\displaystyle \to }
  


  
    
      
        f
        Â 
        (
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        )
      
    
    {\displaystyle f\ ((\lambda x.f(xx))\ (\lambda x.f(xx)))}
  
,
where 
  
    
      
        â¡
      
    
    {\displaystyle \equiv }
  
 and 
  
    
      
        â
      
    
    {\displaystyle \to }
  
 denote syntactic equality by definition and beta reduction, respectively.

Similarly to the first two steps, one obtains

  
    
      
        f
        Â 
        (
        
          
            Y
          
        
        Â 
        f
        )
      
    
    {\displaystyle f\ ({\textsf {Y}}\ f)}
  


  
    
      
        â
      
    
    {\displaystyle \to }
  


  
    
      
        f
        Â 
        (
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        Â 
        (
        Î»
        x
        .
        f
        (
        x
        x
        )
        )
        )
      
    
    {\displaystyle f\ ((\lambda x.f(xx))\ (\lambda x.f(xx)))}
  
.
Since both terms 
  
    
      
        
          
            Y
          
        
        Â 
        f
      
    
    {\displaystyle {\textsf {Y}}\ f}
  
 and 
  
    
      
        f
        Â 
        (
        
          
            Y
          
        
        Â 
        f
        )
      
    
    {\displaystyle f\ ({\textsf {Y}}\ f)}
  
 could be reduced to the same term, they are equal.

^ 

  
    
      
        Î
        Â 
        f
      
    
    {\displaystyle \Theta \ f}
  


  
    
      
        â¡
      
    
    {\displaystyle \equiv }
  


  
    
      
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        f
      
    
    {\displaystyle (\lambda xy.y(xxy))\ (\lambda xy.y(xxy))\ f}
  


  
    
      
        â
      
    
    {\displaystyle \to }
  


  
    
      
        (
        Î»
        y
        .
        y
        Â 
        (
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        y
        )
        )
        Â 
        f
      
    
    {\displaystyle (\lambda y.y\ ((\lambda xy.y(xxy))\ (\lambda xy.y(xxy))\ y))\ f}
  


  
    
      
        â
      
    
    {\displaystyle \to }
  


  
    
      
        f
        Â 
        (
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        (
        Î»
        x
        y
        .
        y
        (
        x
        x
        y
        )
        )
        Â 
        f
        )
      
    
    {\displaystyle f\ ((\lambda xy.y(xxy))\ (\lambda xy.y(xxy))\ f)}
  


  
    
      
        â¡
      
    
    {\displaystyle \equiv }
  


  
    
      
        f
        Â 
        (
        Î
        Â 
        f
        )
      
    
    {\displaystyle f\ (\Theta \ f)}
  


^ This terminology appears to be largely folklore, but it does appear in the following:
Trey Nash, Accelerated C# 2008, Apress, 2007, .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}ISBNÂ 1-59059-873-3, p. 462â463. Derived substantially from Wes Dyer's blog (see next item).
Wes Dyer Anonymous Recursion in C#, February 02, 2007, contains a substantially similar example found in the book above, but accompanied by more discussion.


References[edit]


^ Jump up to: a b Peyton Jones, Simon L. (1987). The Implementation of Functional Programming. Prentice Hall International.

^ Jump up to: a b Henk Barendregt (1985). The Lambda Calculus â Its Syntax and Semantics. Studies in Logic and the Foundations of Mathematics. Vol.Â 103. Amsterdam: North-Holland. ISBNÂ 0444867481.

^ Selinger, Peter. "Lecture Notes on Lambda Calculus (PDF)". p.Â 6. 

^ "For those of us who don't know what a Y-Combinator is or why it's useful, ..." Hacker News. Retrieved 2 August 2020.

^ "abstract algebra - Can someone explain the Y Combinator?". Mathematics Stack Exchange.

^ BimbÃ³, Katalin (27 July 2011). Combinatory Logic: Pure, Applied and Typed. p.Â 48. ISBNÂ 9781439800010.

^ Jump up to: a b Goldberg, 2005

^ Alan Mathison Turing (December 1937). "The 
  
    
      
        p
      
    
    {\displaystyle p}
  
-function in 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
-
  
    
      
        K
      
    
    {\displaystyle K}
  
-conversion". Journal of Symbolic Logic. 2 (4): 164. JSTORÂ 2268281.

^ "Many faces of the fixed-point combinator". okmij.org.

^ Polyvariadic Y in pure Haskell98 Archived 2016-03-04 at the Wayback Machine, lang.haskell.cafe, October 28, 2003

^ "recursion - Fixed-point combinator for mutually recursive functions?". Stack Overflow.

^ Bene, Adam (17 August 2017). "Fixed-Point Combinators in JavaScript". Bene Studio. Medium. Retrieved 2 August 2020.

^ "CS 6110 S17 Lecture 5. Recursion and Fixed-Point Combinators" (PDF). Cornell University. 4.1 A CBV Fixed-Point Combinator.

^ The original definition in Data.Function.

^ Felleisen, Matthias (1987). The Lambda-v-CS Calculus. Indiana University.

^ Talcott, Carolyn (1985). The Essence of Rum: A theory of the intensional and extensional aspects of Lisp-type computation (Ph.D. thesis). Stanford University.

^ An Introduction to the Lambda Calculus Archived 2014-04-08 at the Wayback Machine

^ Haskell mailing list thread on How to define Y combinator in Haskell, 15 Sep 2006

^ Geuvers, Herman; Verkoelen, Joep. On Fixed point and Looping Combinators in Type Theory. CiteSeerXÂ 10.1.1.158.1478.

^ Daniel P. Friedman, Matthias Felleisen (1986). "Chapter 9 - Lambda The Ultimate". The Little Lisper. Science Research Associates. p.Â 179. "In the chapter we have derived a Y-combinator which allows us to write recursive functions of one argument without using define."

^ Mike Vanier. "The Y Combinator (Slight Return) or: How to Succeed at Recursion Without Really Recursing". Archived from the original on 2011-08-22. "More generally, Y gives us a way to get recursion in a programming language that supports first-class functions but that doesn't have recursion built in to it."

^ The If Works Deriving the Y combinator, January 10th, 2008


Werner Kluge, Abstract computing machines: a lambda calculus perspective, Springer, 2005, ISBNÂ 3-540-21146-2, pp.Â 73â77
Mayer Goldberg, (2005) On the Recursive Enumerability of Fixed-Point Combinators, BRICS Report RS-05-1, University of Aarhus
Matthias Felleisen, A Lecture on the Why of Y.
External links[edit]



Wikibooks has a book on the topic of: Haskell/Fix and recursion

Recursion Theory and Joy, Manfred von Thun, (2002 or earlier)
The Lambda Calculus - notes by Don Blaheta, October 12, 2000
Y Combinator
"A Use of the Y Combinator in Ruby"
"Functional programming in Ada"
Rosetta code - Y combinator




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Fixed-point_combinator&oldid=1065079128"
		Categories: Combinatory logicFixed points (mathematics)Lambda calculusMathematics of computingRecursionHidden categories: Webarchive template wayback linksArticles with short descriptionShort description matches WikidataAll articles with incomplete citationsArticles with incomplete citations from December 2019All articles with unsourced statementsArticles with unsourced statements from August 2019
	
