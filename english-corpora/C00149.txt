
Title:
Lua (programming language)
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Lightweight programming language
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}The article is about the Lua programming language itself. For its use in Wikipedia, see Wikipedia:Lua.


.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}LuaParadigmMulti-paradigm: scripting, imperative (procedural, prototype-based, object-oriented), functionalDesignedÂ byRoberto Ierusalimschy Waldemar Celes Luiz Henrique de FigueiredoFirstÂ appeared1993; 29Â years agoÂ (1993)Stable release5.4.4[1]Â 
   /    26 January 2022; 6 days agoÂ (26 January 2022)
Typing disciplineDynamic, strong, duckImplementation languageANSI COSCross-platformLicenseMIT LicenseFilename extensions.luaWebsitewww.lua.orgMajor implementationsLua, LuaJIT, LuaVela, 
MoonSharp, Luvit, LuaRTDialectsMetalua, Idle, GSL Shell, LuauInfluenced byC++, CLU, Modula, Scheme, SNOBOLInfluencedGameMonkey, Io, JavaScript, Julia, MiniD, Red, Ring,[2] Ruby, Squirrel, MoonScript, C--
Lua (/ËluËÉ/ LOO-É; from Portuguese: lua [Ëlu.(w)É] meaning moon) is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications.[3] Lua is cross-platform, since the interpreter of compiled bytecode is written in ANSI C,[4] and Lua has a relatively simple C API to embed it into applications.[5]
Lua was originally designed in 1993 as a language for extending software applications to meet the increasing demand for customization at the time. It provided the basic facilities of most procedural programming languages, but more complicated or domain-specific features were not included; rather, it included mechanisms for extending the language, allowing programmers to implement such features. As Lua was intended to be a general embeddable extension language, the designers of Lua focused on improving its speed, portability, extensibility, and ease-of-use in development.

Contents

1 History
2 Features

2.1 Syntax
2.2 Control flow
2.3 Functions
2.4 Tables
2.5 Metatables
2.6 Object-oriented programming

2.6.1 Inheritance




3 Implementation
4 C API
5 Applications
6 Derived languages

6.1 Languages that compile to Lua
6.2 Dialects


7 LuaJIT

7.1 History
7.2 Installation
7.3 Performance
7.4 Platforms
7.5 Examples


8 See also
9 References
10 Further reading
11 External links



History[edit]
Lua was created in 1992 by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes, members of the Computer Graphics Technology Group (Tecgraf) at the Pontifical Catholic University of Rio de Janeiro, in Brazil.
From 1977 until 1992, Brazil had a policy of strong trade barriers (called a market reserve) for computer hardware and software. In that atmosphere, Tecgraf's clients could not afford, either politically or financially, to buy customized software from abroad. Those reasons led Tecgraf to implement the basic tools it needed from scratch.[6]
Lua's predecessors were the data-description/configuration languages SOL (Simple Object Language) and DEL (data-entry language).[7] They had been independently developed at Tecgraf in 1992â1993 to add some flexibility into two different projects (both were interactive graphical programs for engineering applications at Petrobras company). There was a lack of any flow-control structures in SOL and DEL, and Petrobras felt a growing need to add full programming power to them.
In The Evolution of Lua, the language's authors wrote:[6]

.mw-parser-output .templatequote{overflow:hidden;margin:1em 0;padding:0 40px}.mw-parser-output .templatequote .templatequotecite{line-height:1.5em;text-align:left;padding-left:1.6em;margin-top:0}In 1993, the only real contender was Tcl, which had been explicitly designed to be embedded into applications. However, Tcl had unfamiliar syntax, did not offer good support for data description, and ran only on Unix platforms. We did not consider LISP or Scheme because of their unfriendly syntax. Python was still in its infancy. In the free, do-it-yourself atmosphere that then reigned in Tecgraf, it was quite natural that we should try to develop our own scripting languageÂ ... Because many potential users of the language were not professional programmers, the language should avoid cryptic syntax and semantics. The implementation of the new language should be highly portable, because Tecgraf's clients had a very diverse collection of computer platforms. Finally, since we expected that other Tecgraf products would also need to embed a scripting language, the new language should follow the example of SOL and be provided as a library with a C API.
Lua 1.0 was designed in such a way that its object constructors, being then slightly different from the current light and flexible style, incorporated the data-description syntax of SOL (hence the name Lua: Sol meaning "Sun" in Portuguese, and Lua meaning "Moon"). Lua syntax for control structures was mostly borrowed from Modula (if, while, repeat/until), but also had taken influence from CLU (multiple assignments and multiple returns from function calls, as a simpler alternative to reference parameters or explicit pointers), C++ ("neat idea of allowing a local variable to be declared only where we need it"[6]), SNOBOL and AWK (associative arrays). In an article published in Dr. Dobb's Journal, Lua's creators also state that LISP and Scheme with their single, ubiquitous data-structure mechanism (the list) were a major influence on their decision to develop the table as the primary data structure of Lua.[8]
Lua semantics have been increasingly influenced by Scheme over time,[6] especially with the introduction of anonymous functions and full lexical scoping. Several features were added in new Lua versions.
Versions of Lua prior to version 5.0 were released under a license similar to the BSD license. From version 5.0 onwards, Lua has been licensed under the MIT License.  Both are permissive free software licences and are almost identical.

Features[edit]



Wikibooks has a book on the topic of: Lua Programming

Lua is commonly described as a "multi-paradigm" language, providing a small set of general features that can be extended to fit different problem types. Lua does not contain explicit support for inheritance, but allows it to be implemented with metatables. Similarly, Lua allows programmers to implement namespaces, classes, and other related features using its single table implementation; first-class functions allow the employment of many techniques from functional programming; and full lexical scoping allows fine-grained information hiding to enforce the principle of least privilege.
In general, Lua strives to provide simple, flexible meta-features that can be extended as needed, rather than supply a feature-set specific to one programming paradigm. As a result, the base language is lightâthe full reference interpreter is only about 247Â kB compiled[4]âand easily adaptable to a broad range of applications.
A dynamically typed language intended for use as an extension language or scripting language, Lua is compact enough to fit on a variety of host platforms. It supports only a small number of atomic data structures such as boolean values, numbers (double-precision floating point and 64-bit integers by default), and strings. Typical data structures such as arrays, sets, lists, and records can be represented using Lua's single native data structure, the table, which is essentially a heterogeneous associative array.
Lua implements a small set of advanced features such as first-class functions, garbage collection, closures, proper tail calls, coercion (automatic conversion between string and number values at run time), coroutines (cooperative multitasking) and dynamic module loading.

Syntax[edit]
The classic "Hello, World!" program can be written as follows:[9]

print("Hello, World!")

or as:

print 'Hello, World!'

A comment in Lua starts with a double-hyphen and runs to the end of the line, similar to Ada, Eiffel, Haskell, SQL and VHDL. Multi-line strings and comments are adorned with double square brackets.
The factorial function is implemented as a function in this example:

function factorial(n)
  local x = 1
  for i = 2, n do
    x = x * i
  end
  return x
end

Control flow[edit]
Lua has one type of conditional test: if then end with optional else and elseif then execution control constructs.
The generic if then end statement requires all three keywords:

if condition then
	--statement body
end

The else keyword may be added with an accompanying statement block to control execution when the if condition evaluates to false:

if condition then
	--statement body
else
	--statement body
end

Execution may also be controlled according to multiple conditions using the elseif then keywords:

if condition then
	--statement body
elseif condition then
	--statement body
else -- optional
	--optional default statement body
end

Lua has four types of conditional loops: the while loop, the repeat loop (similar to a  do while loop), the numeric for loop, and the generic for loop.

--condition = true

while condition do
  --statements
end

repeat
  --statements
until condition

for i = first, last, delta do  --delta may be negative, allowing the for loop to count down or up
  --statements
  --example: print(i)
end

The generic for loop:

for key, value in pairs(_G) do
  print(key, value)
end

would iterate over the table _G using the standard iterator function pairs, until it returns nil.
Loops can also be nested (put inside of another loop).

local grid = {
  { 11, 12, 13 },
  { 21, 22, 23 },
  { 31, 32, 33 }
}

for y, row in ipairs(grid) do
  for x, value in ipairs(row) do
    print(x, y, value)
  end
end

Functions[edit]
Lua's treatment of functions as first-class values is shown in the following example, where the print function's behavior is modified:

do
  local oldprint = print
  -- Store current print function as oldprint
  function print(s)
    --[[ Redefine print function. The usual print function can still be used
      through oldprint. The new one has only one argument.]]
    oldprint(s == "foo" and "bar" or s)
  end
end

Any future calls to print will now be routed through the new function, and because of Lua's lexical scoping, the old print function will only be accessible by the new, modified print.
Lua also supports closures, as demonstrated below:

function addto(x)
  -- Return a new function that adds x to the argument
  return function(y)
    --[=[ When we refer to the variable x, which is outside the current
      scope and whose lifetime would be shorter than that of this anonymous
      function, Lua creates a closure.]=]
    return x + y
  end
end
fourplus = addto(4)
print(fourplus(3))  -- Prints 7

--This can also be achieved by calling the function in the following way:
print(addto(4)(3))
--[[ This is because we are calling the returned function from 'addto(4)' with the argument '3' directly.
  This also helps to reduce data cost and up performance if being called iteratively.
]]

A new closure for the variable x is created every time addto is called, so that each new anonymous function returned will always access its own x parameter. The closure is managed by Lua's garbage collector, just like any other object.

Tables[edit]
Tables are the most important data structures (and, by design, the only built-in composite data type) in Lua and are the foundation of all user-created types. They are associative arrays with addition of automatic numeric key and special syntax.
A table is a collection of key and data pairs, where the data is referenced by key; in other words, it is a hashed heterogeneous associative array.
Tables are created using the {} constructor syntax.

a_table = {} -- Creates a new, empty table

Tables are always passed by reference (see Call by sharing).
A key (index) can be any value except nil and NaN, including functions.

a_table = {x = 10}  -- Creates a new table, with one entry mapping "x" to the number 10.
print(a_table["x"]) -- Prints the value associated with the string key, in this case 10.
b_table = a_table
b_table["x"] = 20   -- The value in the table has been changed to 20.
print(b_table["x"]) -- Prints 20.
print(a_table["x"]) -- Also prints 20, because a_table and b_table both refer to the same table.

A table is often used as structure (or record) by using strings as keys. Because such use is very common, Lua features a special syntax for accessing such fields.[10]

point = { x = 10, y = 20 }   -- Create new table
print(point["x"])            -- Prints 10
print(point.x)               -- Has exactly the same meaning as line above. The easier-to-read dot notation is just syntactic sugar.

By using a table to store related functions, it can act as a namespace.

Point = {}

Point.new = function(x, y)
  return {x = x, y = y}  --  return {["x"] = x, ["y"] = y}
end

Point.set_x = function(point, x)
  point.x = x  --  point["x"] = x;
end

Tables are automatically assigned a numerical key, enabling them to be used as an array data type. The first automatic index is 1 rather than 0 as it is for many other programming languages (though an explicit index of 0 is allowed).
A numeric key 1 is distinct from a string key "1".

array = { "a", "b", "c", "d" }   -- Indices are assigned automatically.
print(array[2])                  -- Prints "b". Automatic indexing in Lua starts at 1.
print(#array)                    -- Prints 4.  # is the length operator for tables and strings.
array[0] = "z"                   -- Zero is a legal index.
print(#array)                    -- Still prints 4, as Lua arrays are 1-based.

The length of a table t is defined to be any integer index n such that t[n] is not nil and t[n+1] is nil; moreover, if t[1] is nil, n can be zero. For a regular array, with non-nil values from 1 to a given n, its length is exactly that n, the index of its last value. If the array has "holes" (that is, nil values between other non-nil values), then #t can be any of the indices that directly precedes a nil value (that is, it may consider any such nil value as the end of the array).[11]

ExampleTable =
{
  {1, 2, 3, 4},
  {5, 6, 7, 8}
}
print(ExampleTable[1][3]) -- Prints "3"
print(ExampleTable[2][4]) -- Prints "8"

A table can be an array of objects.

function Point(x, y)        -- "Point" object constructor
  return { x = x, y = y }   -- Creates and returns a new object (table)
end
array = { Point(10, 20), Point(30, 40), Point(50, 60) }   -- Creates array of points
                        -- array = { { x = 10, y = 20 }, { x = 30, y = 40 }, { x = 50, y = 60 } };
print(array[2].y)                                         -- Prints 40

Using a hash map to emulate an array is normally slower than using an actual array; however, Lua tables are optimized for use as arrays to help avoid this issue.[12]

Metatables[edit]
Extensible semantics is a key feature of Lua, and the metatable concept allows powerful customization of tables. The following example demonstrates an "infinite" table. For any n, fibs[n] will give the n-th Fibonacci number using dynamic programming and memoization.

fibs = { 1, 1 }                                -- Initial values for fibs[1] and fibs[2].
setmetatable(fibs, {
  __index = function(values, n)                --[[__index is a function predefined by Lua, 
                                                   it is called if key "n" does not exist.]]
    values[n] = values[n - 1] + values[n - 2]  -- Calculate and memorize fibs[n].
    return values[n]
  end
})

Object-oriented programming[edit]
Although Lua does not have a built-in concept of classes, object-oriented programming can be emulated using functions and tables. An object is formed by putting methods and fields in a table. Inheritance (both single and multiple) can be implemented with metatables, delegating nonexistent methods and fields to a parent object.
There is no such concept as "class" with these techniques; rather, prototypes are used, similar to Self or JavaScript. New objects are created either with a factory method (that constructs new objects from scratch) or by cloning an existing object.
Creating a basic vector object:

local Vector = {}
local VectorMeta = { __index = Vector}

function Vector.new(x, y, z)    -- The constructor
  return setmetatable({x = x, y = y, z = z}, VectorMeta)
end

function Vector.magnitude(self)     -- Another method
  return math.sqrt(self.x^2 + self.y^2 + self.z^2)
end

local vec = Vector.new(0, 1, 0) -- Create a vector
print(vec.magnitude(vec))       -- Call a method (output: 1)
print(vec.x)                    -- Access a member variable (output: 0)

Here, setmetatable tells Lua to look for an element in the Vector table if it is not present in the vec table. vec.magnitude, which is equivalent to vec["magnitude"], first looks in the vec table for the magnitude element. The vec table does not have a magnitude element, but its metatable delegates to the Vector table for the magnitude element when it's not found in the vec table.
Lua provides some syntactic sugar to facilitate object orientation. To declare member functions inside a prototype table, one can use function table:func(args), which is equivalent to function table.func(self, args). Calling class methods also makes use of the colon: object:func(args) is equivalent to object.func(object, args).
That in mind, here is a corresponding class with : syntactic sugar:

local Vector = {}
Vector.__index = Vector

function Vector:new(x, y, z)    -- The constructor
  -- Since the function definition uses a colon, 
  -- its first argument is "self" which refers
  -- to "Vector"
  return setmetatable({x = x, y = y, z = z}, self)
end

function Vector:magnitude()     -- Another method
  -- Reference the implicit object using self
  return math.sqrt(self.x^2 + self.y^2 + self.z^2)
end

local vec = Vector:new(0, 1, 0) -- Create a vector
print(vec:magnitude())          -- Call a method (output: 1)
print(vec.x)                    -- Access a member variable (output: 0)

Inheritance[edit]
Lua supports using metatables to give Lua class inheritance.[13] In this example, we allow vectors to have their values multiplied by a constant in a derived class.

local Vector = {}
Vector.__index = Vector

function Vector:new(x, y, z)    -- The constructor
  -- Here, self refers to whatever class's "new"
  -- method we call.  In a derived class, self will
  -- be the derived class; in the Vector class, self
  -- will be Vector
  return setmetatable({x = x, y = y, z = z}, self)
end

function Vector:magnitude()     -- Another method
  -- Reference the implicit object using self
  return math.sqrt(self.x^2 + self.y^2 + self.z^2)
end

-- Example of class inheritance
local VectorMult = {}
VectorMult.__index = VectorMult
setmetatable(VectorMult, Vector) -- Make VectorMult a child of Vector

function VectorMult:multiply(value) 
  self.x = self.x * value
  self.y = self.y * value
  self.z = self.z * value
  return self
end

local vec = VectorMult:new(0, 1, 0) -- Create a vector
print(vec:magnitude())          -- Call a method (output: 1)
print(vec.y)                    -- Access a member variable (output: 1)
vec:multiply(2)                 -- Multiply all components of vector by 2
print(vec.y)                    -- Access member again (output: 2)

Lua also supports multiple inheritance; __index can either be a function or a table.[14] Operator overloading can also be done; Lua metatables can have elements such as __add, __sub, and so on.[15]

Implementation[edit]
Lua programs are not interpreted directly from the textual Lua file, but are compiled into bytecode, which is then run on the Lua virtual machine. The compilation process is typically invisible to the user and is performed during run-time, especially when a JIT compiler is used, but it can be done offline in order to increase loading performance or reduce the memory footprint of the host environment by leaving out the compiler. Lua bytecode can also be produced and executed from within Lua, using the dump function from the string library and the load/loadstring/loadfile functions. Lua version 5.3.4 is implemented in approximately 24,000 lines of C code.[3][4]
Like most CPUs, and unlike most virtual machines (which are stack-based), the Lua VM is register-based, and therefore more closely resembles an actual hardware design. The register architecture both avoids excessive copying of values and reduces the total number of instructions per function. The virtual machine of Lua 5 is one of the first register-based pure VMs to have a wide use.[16] Parrot and Android's Dalvik are two other well-known register-based VMs.  PCScheme's VM was also register-based.[17]
This example is the bytecode listing of the factorial function defined above (as shown by the luac 5.1 compiler):[18] 

function <factorial.lua:1,7> (9 instructions, 36 bytes at 0x8063c60)
1 param, 6 slots, 0 upvalues, 6 locals, 2 constants, 0 functions
	1	[2]	LOADK    	1 -1	; 1
	2	[3]	LOADK    	2 -2	; 2
	3	[3]	MOVE     	3 0
	4	[3]	LOADK    	4 -1	; 1
	5	[3]	FORPREP  	2 1	; to 7
	6	[4]	MUL      	1 1 5
	7	[3]	FORLOOP  	2 -2	; to 6
	8	[6]	RETURN   	1 2
	9	[7]	RETURN   	0 1

C API[edit]
Lua is intended to be embedded into other applications, and provides a C API for this purpose. The API is divided into two parts: the Lua core and the Lua auxiliary library.[19] The Lua API's design eliminates the need for manual reference management in C code, unlike Python's API. The API, like the language, is minimalistic. Advanced functionality is provided by the auxiliary library, which consists largely of preprocessor macros which assist with complex table operations.
The Lua C API is stack based. Lua provides functions to push and pop most simple C data types (integers, floats, etc.) to and from the stack, as well as functions for manipulating tables through the stack. The Lua stack is somewhat different from a traditional stack; the stack can be indexed directly, for example. Negative indices indicate offsets from the top of the stack. For example, â1 is the top (most recently pushed value), while positive indices indicate offsets from the bottom (oldest value). Marshalling data between C and Lua functions is also done using the stack. To call a Lua function, arguments are pushed onto the stack, and then the lua_call is used to call the actual function. When writing a C function to be directly called from Lua, the arguments are read from the stack.
Here is an example of calling a Lua function from C:

#include <stdio.h>
#include <lua.h> // Lua main library (lua_*)
#include <lauxlib.h> // Lua auxiliary library (luaL_*)

int main(void)
{
    // create a Lua state
    lua_State *L = luaL_newstate();

    // load and execute a string
    if (luaL_dostring(L, "function foo (x,y) return x+y end")) {
        lua_close(L);
        return -1;
    }

    // push value of global "foo" (the function defined above)
    // to the stack, followed by integers 5 and 3
    lua_getglobal(L, "foo");
    lua_pushinteger(L, 5);
    lua_pushinteger(L, 3);
    lua_call(L, 2, 1); // call a function with two arguments and one return value
    printf("Result: %d\n", lua_tointeger(L, -1)); // print integer value of item at stack top
    lua_pop(L, 1); // return stack to original state
    lua_close(L); // close Lua state
    return 0;
}

Running this example gives:

$ cc -o example example.c -llua
$ ./example
Result: 8

The C API also provides some special tables, located at various "pseudo-indices" in the Lua stack. At LUA_GLOBALSINDEX prior to Lua 5.2[20] is the globals table, _G from within Lua, which is the main namespace. There is also a registry located at LUA_REGISTRYINDEX where C programs can store Lua values for later retrieval.
It is possible to write extension modules using the Lua API. Extension modules are shared objects which can be used to extend the functionality of the interpreter by providing native facilities to Lua scripts. From the Lua side, such a module appears as a namespace table holding its functions and variables. Lua scripts may load extension modules using require,[19] just like modules written in Lua itself. A growing collection of modules known as rocks are available through a package management system called LuaRocks,[21] in the spirit of CPAN, RubyGems and Python eggs. Prewritten Lua bindings exist for most popular programming languages, including other scripting languages.[22] For C++, there are a number of template-based approaches and some automatic binding generators.

Applications[edit]
Main article: List of applications using Lua
In video game development, Lua is widely used as a scripting language by programmers, mainly due to its perceived easiness to embed, fast execution, and short learning curve.[23] One of the notable gaming platforms is Roblox in which their own dialect, Luau, is used for scripting quick development of games.[24]  Another is World of Warcraft which also uses a scaled down version of Lua. [25]
In 2003, a poll conducted by GameDev.net showed Lua was the most popular scripting language for game programming.[26] On 12 January 2012, Lua was announced as a winner of the Front Line Award 2011 from the magazine Game Developer in the category Programming Tools.[27]
A large number of non-game applications also use Lua for extensibility, such as LuaTeX, an implementation of the TeX type-setting language, Redis, a key-value database, Neovim, a text editor, and Nginx, a web server.
Through the Scribunto extension, Lua is available as a server-side scripting language in the MediaWiki software that powers Wikipedia and other wikis.[28] Among its uses are allowing the integration of data from Wikidata into articles,[29] and powering the automated taxobox system.

Derived languages[edit]
Languages that compile to Lua[edit]
MoonScript is a dynamic, whitespace-sensitive scripting language inspired by CoffeeScript, which is compiled into Lua. This means that instead of using do and end (or { and }) to delimit sections of code it uses line breaks and indentation style.[30][31][32] A notable usage of MoonScript is a video game distribution website Itch.io.
Haxe supports compilation to a Lua target, supporting Lua 5.1-5.3 as well as LuaJIT 2.0 and 2.1.
Fennel, a Lisp dialect that targets Lua.[32]
Urn, a Lisp dialect that is built on Lua.[33]
Amulet, an ML-like functional language, whose compiler outputs Lua files.[34]
Dialects[edit]
LuaJIT (see below), JIT-enabled Lua 5.1 language with goto (from Lua 5.2) and a C FFI.
Luau from Roblox, Lua 5.1 language with gradual typing and ergonomic additions.[35]
Ravi, JIT-enabled Lua 5.3 language with optional static typing. JIT is guided by type information.[36]
Shine, a fork of LuaJIT with many extensions, including a module system and a macro system.[37]
In addition, the Lua users community provides some power patches on top of the reference C implementation.[38]

LuaJIT[edit]
LuaJITDeveloper(s)Mike PallStable release2.0.5
   / MayÂ 1, 2017; 4 years agoÂ (2017-05-01)
Repositoryrepo.or.cz/w/luajit-2.0.gitWritten inC, LuaOperating systemsee listTypeJust in time compilerLicenseMIT License[39]Websiteluajit.org
LuaJIT is a just in time compiler for Lua. It has been used for embedding or for general purposes. In version 2.0 of LuaJIT, the project has been rewritten for better optimizations for performance.[40]

History[edit]
The LuaJIT project has started in 2005 by developer Mike Pall, released under the MIT open source license.[41] The latest release, 2.0.5 is released in 2017. Since then, the project is not currently maintained by developers other than contributors.[42]

Installation[edit]
LuaJIT is open source and the project has to be compiled in order for it to be used. The repository will have to be download with Git or other methods of downloading repositories.[42] Then it is compiled with any C compiler, usually with GNU make, but other options are available.[43] Finally, the LuaJIT executable and the Lua 5.1 DLL have to be in the same directory in order for the LuaJIT compiler to be used.
There is a guide on using the LuaJIT compiler which includes command line options.[44]

Performance[edit]
When compared to other Lua run-times, LuaJIT is often the fastest Lua compiler.[45]

Platforms[edit]
LuaJIT can be used in:[46]

Windows
Xbox 360
Linux
Android
BSD
Sony PlayStation:
PS3
PS4
PS Vita
macOS
iOS
It can be compiled using either GCC, Clang, or MSVC.[46]

Examples[edit]
The FFi Library can be used to call C functions and use C data structures from Lua Code.[47] There is a guide provided from LuaJIT about using this library.[48] As such, there are multiple LuaJIT bindings to C libraries that use the FFI Library. This example would call a C function, printf from pure Lua code and will output Hello world!.

local ffi = require("ffi")
ffi.cdef[[
int printf(const char *fmt, ...);
]]
ffi.C.printf("Hello world!\n")

The LuaJIT compiler has also added some extensions to Lua's C API.[49] This example written in C++ would be used for debugging purposes.

#include <exception>
#include "lua.hpp"

// Catch C++ exceptions and convert them to Lua error messages.
// Customize as needed for your own exception classes.
static int wrap_exceptions(lua_State *L, lua_CFunction f)
{
  try {
    return f(L);  // Call wrapped function and return result.
  } catch (const char *s) {  // Catch and convert exceptions.
    lua_pushstring(L, s);
  } catch (std::exception& e) {
    lua_pushstring(L, e.what());
  } catch (...) {
    lua_pushliteral(L, "caught (...)");
  }
  return lua_error(L);  // Rethrow as a Lua error.
}

static int myinit(lua_State *L)
{
  ...
  // Define wrapper function and enable it.
  lua_pushlightuserdata(L, (void *)wrap_exceptions);
  luaJIT_setmode(L, -1, LUAJIT_MODE_WRAPCFUNC|LUAJIT_MODE_ON);
  lua_pop(L, 1);
  ...
}

See also[edit]
Comparison of programming languages
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Lua 5.4.4 now available". 26 January 2022. Retrieved 28 January 2022.

^ Ring Team (5 December 2017). "The Ring programming language and other languages". ring-lang.net.

^ Jump up to: a b Ierusalimschy, Roberto; de Figueiredo, Luiz Henrique; Filho, Waldemar Celes (June 1996). "LuaâAn Extensible Extension Language". Software: Practice and Experience. 26 (6): 635â652. doi:10.1002/(SICI)1097-024X(199606)26:6<635::AID-SPE26>3.0.CO;2-P. Retrieved 24 October 2015.

^ Jump up to: a b c "About Lua". Lua.org. Retrieved 11 August 2011.

^ Yuri Takhteyev (21 April 2013). "From Brazil to Wikipedia". Foreign Affairs. Retrieved 25 April 2013.

^ Jump up to: a b c d Ierusalimschy, R.; Figueiredo, L. H.; Celes, W. (2007). "The evolution of Lua" (PDF). Proc. of ACM HOPL III. pp.Â 2â1â2â26. doi:10.1145/1238844.1238846. ISBNÂ 978-1-59593-766-7. S2CIDÂ 475143.[dead link]

^ "The evolution of an extension language: a history of Lua". 2001. Retrieved 18 December 2008.


^ Figueiredo, L. H.; Ierusalimschy, R.; Celes, W. (December 1996). "Lua: an Extensible Embedded Language. A few metamechanisms replace a host of features". Dr. Dobb's Journal. Vol.Â 21, no.Â 12. pp.Â 26â33.

^ "Programming in LuaÂ : 1".

^ "Lua 5.1 Reference Manual". 2014. Retrieved 27 February 2014.

^ "Lua 5.1 Reference Manual". 2012. Retrieved 16 October 2012.

^ "Lua 5.1 Source Code". 2006. Retrieved 24 March 2011.

^ Roberto Ierusalimschy. Programming in Lua, 4th Edition. p.Â 165.

^ "Programming in LuaÂ : 16.3". www.lua.org. Retrieved 16 September 2021.

^ "lua-users wiki: Metamethods Tutorial". lua-users.org. Retrieved 16 September 2021.

^ Ierusalimschy, R.; Figueiredo, L. H.; Celes, W. (2005). "The implementation of Lua 5.0". J. Of Universal Comp. Sci. 11 (7): 1159â1176.

^ Texas Instruments (1990). PC Scheme: Users Guide and Language Reference Manual, Trade Edition. ISBNÂ 0-262-70040-9.

^ Kein-Hong Man (2006). "A No-Frills Introduction to Lua 5.1 VM Instructions" (PDF).

^ Jump up to: a b "Lua 5.2 Reference Manual". Lua.org. Retrieved 23 October 2012.

^ "Changes in the API". Lua 5.2 Reference Manual. Lua.org. Retrieved 9 May 2014.

^ "LuaRocks". LuaRocks wiki. Retrieved 24 May 2009.

^ "Binding Code To Lua". Lua-users wiki. Retrieved 24 May 2009.

^ "Why is Lua considered a game language?". Archived from the original on 20 August 2013. Retrieved 22 April 2017.{{cite web}}:  CS1 maint: bot: original URL status unknown (link)

^ "Why Luau?". Luau. Retrieved 10 February 2021.

^ "Lua Functions". wow.gamepedia.com. Retrieved 1 March 2021.

^ "Poll Results". Archived from the original on 7 December 2003. Retrieved 22 April 2017.{{cite web}}:  CS1 maint: bot: original URL status unknown (link)

^ "Front Line Award Winners Announced". Archived from the original on 15 June 2013. Retrieved 22 April 2017.{{cite web}}:  CS1 maint: bot: original URL status unknown (link)

^ "Extension:Scribunto - MediaWiki". MediaWiki.org. Retrieved 21 February 2019.

^ "Wikidata:Infobox Tutorial - Wikidata". www.wikidata.org. Retrieved 21 December 2018.

^ "Language Guide - MoonScript 0.5.0". moonscript.org. Retrieved 25 September 2020.

^ leaf (23 September 2020), leafo/moonscript, retrieved 25 September 2020

^ Jump up to: a b Andre Alves Garzia. "Languages that compile to Lua". AndreGarzia.com. Retrieved 25 September 2020.

^ "Urn: A Lisp implementation for Lua | Urn". urn-lang.com. Retrieved 12 January 2021.

^ "Amulet ML". amulet.works. Retrieved 12 January 2021.

^ "Luau". Roblox.GitHub.io.

^ "Ravi Programming Language". GitHub.

^ Hundt, Richard (22 April 2021). "richardhundt/shine". GitHub.

^ "Lua Power Patches". lua-users.org.

^ "LuaJIT/COPYRIGHT at v2.1 Â· LuaJIT/LuaJIT". GitHub. 7 January 2022.

^ "LuaJIT".

^ https://luajit.org

^ Jump up to: a b "Download".

^ "Installation".

^ "Running LuaJIT".

^ "LuaJIT Performance".

^ Jump up to: a b "LuaJIT".

^ "FFI Library".

^ "FFI Tutorial".

^ "Lua/C API Extensions".


Further reading[edit]
Ierusalimschy, R. (2013). Programming in Lua (3rdÂ ed.). Lua.org. ISBNÂ 978-85-903798-5-0. (The 1st ed. is available online.)
Gutschmidt, T. (2003). Game Programming with Python, Lua, and Ruby. Course Technology PTR. ISBNÂ 978-1-59200-077-7.
Schuytema, P.; Manyen, M. (2005). Game Development with Lua. Charles River Media. ISBNÂ 978-1-58450-404-7.
Jung, K.; Brown, A. (2007). Beginning Lua Programming. Wrox Press. ISBNÂ 978-0-470-06917-2. Archived from the original on 8 July 2018. Retrieved 7 July 2018.
Figueiredo, L. H.; Celes, W.; Ierusalimschy, R., eds. (2008). Lua Programming Gems. Lua.org. ISBNÂ 978-85-903798-4-3.
Takhteyev, Yuri (2012). Coding Places: Software Practice in a South American City. The MIT Press. ISBNÂ 978-0-262-01807-4. Archived from the original on 2 November 2012. Chapters 6 and 7 are dedicated to Lua, while others look at software in Brazil more broadly.
Varma, Jayant (2012). Learn Lua for iOS Game Development. Apress. ISBNÂ 978-1-4302-4662-6.
Matheson, Ash (29 April 2003). "An Introduction to Lua". GameDev.net. Archived from the original on 18 December 2012. Retrieved 3 January 2013.
Fieldhouse, Keith (16 February 2006). "Introducing Lua". ONLamp.com. O'Reilly Media. Archived from the original on 12 March 2006. Retrieved 28 February 2006.
Streicher, Martin (28 April 2006). "Embeddable scripting with Lua". developerWorks. IBM. Archived from the original on 2 July 2009. Retrieved 7 July 2018.
Quigley, Joseph (1 June 2007). "A Look at Lua". Linux Journal.
Hamilton, Naomi (11 September 2008). "The A-Z of Programming Languages: Lua". Computerworld. IDG. Archived from the original on 8 July 2018. Retrieved 7 July 2018. Interview with Roberto Ierusalimschy.
Ierusalimschy, Roberto; de Figueiredo, Luiz Henrique; Celes, Waldemar (12 May 2011). "Passing a Language through the Eye of a Needle". ACM Queue. 9 (5): 20â29. doi:10.1145/1978862.1983083. S2CIDÂ 19484689. How the embeddability of Lua impacted its design.
Ierusalimschy, Roberto; de Figueiredo, Luiz Henrique; Celes, Waldemar (November 2018). "A Look at the Design of Lua". Communications of the ACM. 61 (11): 114â123. doi:10.1145/3186277. S2CIDÂ 53114923.[permanent dead link]
Lua papers and theses
External links[edit]
.mw-parser-output .sister-box{border:1px solid #aaa;padding:0;background:#f9f9f9}.mw-parser-output .sister-box>div{padding:0.75em 0;text-align:center}.mw-parser-output .sister-box>div>b{display:block}.mw-parser-output .sister-box>ul{border-top:1px solid #aaa;padding:0.75em 0;width:217px;margin:0 auto}.mw-parser-output .sister-box>ul>li{min-height:31px}.mw-parser-output .sister-logo{display:inline-block;width:31px;line-height:31px;vertical-align:middle;text-align:center}.mw-parser-output .sister-link{display:inline-block;margin-left:4px;width:182px;vertical-align:middle}.mw-parser-output .sister-bar{display:flex;justify-content:center;align-items:baseline;font-size:88%;background-color:#fdfdfd;border:1px solid #a2a9b1;clear:both;margin:1em 0 0;padding:0 2em}.mw-parser-output .sister-bar-header{margin:0 1em 0 0.5em;padding:0.2em 0;flex:0 0 auto;min-height:24px;line-height:22px}.mw-parser-output .sister-bar-content{display:flex;flex-flow:row wrap;flex:0 1 auto;align-items:baseline;padding:0.2em 0;column-gap:1em}.mw-parser-output .sister-bar-item{display:flex;align-items:baseline;margin:0.15em 0;min-height:24px;text-align:left}.mw-parser-output .sister-bar-logo{width:22px;line-height:22px;margin:0 0.2em;text-align:right}.mw-parser-output .sister-bar-link{margin:0 0.2em;text-align:left}@media screen and (max-width:960px){.mw-parser-output .sister-bar{display:flex;flex-flow:column wrap;font-size:88%;background-color:#fdfdfd;clear:both;margin:1em auto 0;padding:0 2em}.mw-parser-output .sister-bar-header{padding:0.2em 0;flex:0 1}.mw-parser-output .sister-bar-content{display:flex;flex-flow:row wrap;flex:1;align-items:baseline;padding:0.2em 0;border-top:1px solid #a2a9b1}.mw-parser-output .sister-bar-item{display:flex;align-items:baseline;flex:0 0 20em;min-width:20em;margin:0.15em 0;min-height:24px}}.mw-parser-output .navbox+link+.sister-bar{margin-top:-1px}.mw-parser-output .navbox+style+.sister-bar{margin-top:-1px}.mw-parser-output .portal-bar+link+.sister-bar{margin-top:-1px}.mw-parser-output .portal-bar+style+.sister-bar{margin-top:-1px}.mw-parser-output .sister-bar+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .sister-bar+.navbox-styles+.portal-bar{margin-top:-1px}Luaat Wikipedia's sister projectsNews from WikinewsTextbooks from WikibooksResources from Wikiversity
Official website
Lua Users, Community
Lua Forum
Lua Rocks - Package manager
Projects in Lua
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteLua programming languagePackage manager
LuaRocks
Ports and distributions
Plua
LÃVE
Solar2D
IDEs
Decoda
SciTE
Applications and frameworks
OpenResty
Prosody
Torch
Tarantool
IUP
List of applications using Lua

vteFree and open-source softwareGeneral
Alternative terms for free software
Comparison of open-source and closed-source software
Comparison of source-code-hosting facilities
Free software
Free software project directories
Gratis versus libre
Long-term support
Open-source software
Open-source software development
Outline
Timeline
Softwarepackages
Audio
Bioinformatics
Codecs
Configuration management
Drivers
Graphics
Wireless
Geophysics
Health
Mathematics
Office Suites
Operating systems
Programming languages
Routing
Television
Video games
Web applications
E-commerce
Android apps
iOS apps
Commercial
Trademarked
Formerly proprietary
Formerly open-source
Community
Free software movement
History
Open-source-software movement
Events
Organisations
Free Software Movement of India
Free Software Foundation
Licenses
AFL
Apache
APSL
Artistic
Beerware
BSD
Creative Commons
CDDL
EPL
Free Software Foundation
GNU GPL
GNU LGPL
ISC
MIT
MPL
Python
Python Software Foundation License
Shared Source Initiative
Sleepycat
Unlicense
WTFPL
zlib
Types and standards
Comparison of licenses
Contributor License Agreement
Copyleft
Debian Free Software Guidelines
Definition of Free Cultural Works
Free license
The Free Software Definition
The Open Source Definition
Open-source license
Permissive software license
Public domain
Viral license

Challenges
Digital rights management
Hardware restrictions
License proliferation
Mozilla software rebranding
Proprietary device drivers
Proprietary firmware
Proprietary software
SCO/Linux controversies
Software patents
Software security
Trusted Computing
Related topics
Forking
GNU Manifesto
Microsoft Open Specification Promise
Open-core model
Open-source hardware
Shared Source Initiative
Source-available software
The Cathedral and the Bazaar
Revolution OS

 Portal
 Category

vteProgramming languages
Comparison
Timeline
History

Ada
ALGOL
APL
Assembly
BASIC
C
C++
C#
COBOL
Erlang
Forth
Fortran
Go
Haskell
Java
JavaScript
Kotlin
Lisp
Lua
ML
Pascal
Perl
PHP
Prolog
Python
R
Ruby
Rust
SQL
Shell
Simula
Smalltalk
Swift
more...

 Category
 Lists: Alphabetical
Categorical
Generational
Non-English-based

Authority control General
Integrated Authority File (Germany)
National libraries
France (data)
United States

.mw-parser-output .portal-bar{font-size:88%;font-weight:bold;display:flex;justify-content:center;align-items:baseline}.mw-parser-output .portal-bar-bordered{padding:0 2em;background-color:#fdfdfd;border:1px solid #a2a9b1;clear:both;margin:1em auto 0}.mw-parser-output .portal-bar-unbordered{padding:0 1.7em;margin-left:0}.mw-parser-output .portal-bar-header{margin:0 1em 0 0.5em;padding:0.2em 0;flex:0 0 auto;min-height:24px;line-height:22px}.mw-parser-output .portal-bar-content{display:flex;flex-flow:row wrap;align-items:baseline;flex:0 1 auto;padding:0.15em 0;column-gap:1em}.mw-parser-output .portal-bar-item{display:flex;align-items:baseline;margin:0.15em 0;min-height:24px;text-align:left}.mw-parser-output .portal-bar-logo{width:22px;line-height:22px;margin:0 0.2em;text-align:right}.mw-parser-output .portal-bar-link{margin:0 0.2em;text-align:left}@media screen and (max-width:768px){.mw-parser-output .portal-bar{font-size:88%;font-weight:bold;display:flex;flex-flow:column wrap}.mw-parser-output .portal-bar-header{text-align:center;flex:0;padding-left:0.5em;margin:0 auto}.mw-parser-output .portal-bar-content{display:flex;flex-flow:row wrap;align-items:baseline;flex:0;margin:0 auto;column-gap:1em;border-top:1px solid #a2a9b1}}.mw-parser-output .navbox+link+.portal-bar-bordered{margin-top:-1px}.mw-parser-output .navbox+style+.portal-bar-bordered{margin-top:-1px}.mw-parser-output .portal-bar+.navbox-styles+.navbox{margin-top:-1px}Portals:Free and open-source softwareComputer programming




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Lua_(programming_language)&oldid=1066025637"
		Categories: Lua (programming language)Brazilian inventionsCross-platform free softwareCross-platform softwareDynamic programming languagesDynamically typed programming languagesEmbedded systemsFree compilers and interpretersFree computer librariesFree software programmed in CObject-oriented programming languagesPontifical Catholic University of Rio de JaneiroProgramming languagesProgramming languages created in 1993Prototype-based programming languagesRegister-based virtual machinesScripting languagesSoftware using the MIT licenseHidden categories: All articles with dead external linksArticles with dead external links from July 2018CS1 maint: bot: original URL status unknownArticles with short descriptionShort description matches WikidataUse dmy dates from February 2021Articles containing Portuguese-language textArticles with dead external links from June 2020Articles with permanently dead external linksPages using Sister project links with hidden wikidataPages using Sister project links with default searchOfficial website different in Wikidata and WikipediaArticles with GND identifiersArticles with BNF identifiersArticles with LCCN identifiersArticles with example C code
	
