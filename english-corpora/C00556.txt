
Title:
Feature selection
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Procedure in machine learning and statistics
This article includes a list of general references, but it remains largely unverified because it lacks sufficient corresponding inline citations. Please help to improve this article by introducing more precise citations.  (July 2010) (Learn how and when to remove this template message)
.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Part of a series onMachine learningand data mining
showProblems
Classification
Clustering
Regression
Anomaly detection
Data Cleaning
AutoML
Association rules
Reinforcement learning
Structured prediction
Feature engineering
Feature learning
Online learning
Semi-supervised learning
Unsupervised learning
Learning to rank
Grammar induction

showSupervised learning.mw-parser-output .nobold{font-weight:normal}(classificationÂ â¢ regression) 
Decision trees
Ensembles
Bagging
Boosting
Random forest
k-NN
Linear regression
Naive Bayes
Artificial neural networks
Logistic regression
Perceptron
Relevance vector machine (RVM)
Support vector machine (SVM)

showClustering
BIRCH
CURE
Hierarchical
k-means
Expectationâmaximization (EM)
DBSCAN
OPTICS
Mean shift

showDimensionality reduction
Factor analysis
CCA
ICA
LDA
NMF
PCA
PGD
t-SNE

showStructured prediction
Graphical models
Bayes net
Conditional random field
Hidden Markov

showAnomaly detection
k-NN
Local outlier factor

showArtificial neural network
Autoencoder
Cognitive computing
Deep learning
DeepDream
Multilayer perceptron
RNN
LSTM
GRU
ESN
Restricted Boltzmann machine
GAN
SOM
Convolutional neural network
U-Net
Transformer
Vision
Spiking neural network
Memtransistor
Electrochemical RAM (ECRAM)

showReinforcement learning
Q-learning
SARSA
Temporal difference (TD)

showTheory
Kernel machines
Biasâvariance tradeoff
Computational learning theory
Empirical risk minimization
Occam learning
PAC learning
Statistical learning
VC theory

showMachine-learning venues
NeurIPS
ICML
ML
JMLR
ArXiv:cs.LG

showRelated articles
Glossary of artificial intelligence
List of datasets for machine-learning research
Outline of machine learning
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
In machine learning and statistics, feature selection, also known as variable selection, attribute selection or variable subset selection, is the process of selecting a subset of relevant features (variables, predictors) for use in model construction. Feature selection techniques are used for several reasons:

simplification of models to make them easier to interpret by researchers/users,[1]
shorter training times,[2]
to avoid the curse of dimensionality,[3]
improve data's compatibility with a learning model class,[4]
encode inherent symmetries present in the input space.[5][6][7][8]
The central premise when using a feature selection technique is that the data contains some features that are either redundant or irrelevant, and can thus be removed without incurring much loss of information.[9] Redundant and irrelevant are two distinct notions, since one relevant feature may be redundant in the presence of another relevant feature with which it is strongly correlated.[10]
Feature selection techniques should be distinguished from feature extraction.[11] Feature extraction creates new features from functions of the original features, whereas feature selection returns a subset of the features. Feature selection techniques are often used in domains where there are many features and comparatively few samples (or data points). Archetypal cases for the application of feature selection include the analysis of written texts and DNA microarray data, where there are many thousands of features, and a few tens to hundreds of samples.

Contents

1 Introduction
2 Subset selection
3 Optimality criteria
4 Structure learning
5 Information Theory Based Feature Selection Mechanisms

5.1 Minimum-redundancy-maximum-relevance (mRMR) feature selection
5.2 Quadratic programming feature selection
5.3 Conditional mutual information
5.4 Joint mutual information


6 Hilbert-Schmidt Independence Criterion Lasso based feature selection
7 Correlation feature selection
8 Regularized trees
9 Overview on metaheuristics methods

9.1 Main principles

9.1.1 Filter method
9.1.2 Wrapper method
9.1.3 Embedded method


9.2 Application of feature selection metaheuristics


10 Feature selection embedded in learning algorithms
11 See also
12 References
13 Further reading
14 External links



Introduction[edit]
A feature selection algorithm can be seen as the combination of a search technique for proposing new feature subsets, along with an evaluation measure which scores the different feature subsets. The simplest algorithm is to test each possible subset of features finding the one which minimizes the error rate. This is an exhaustive search of the space, and is computationally intractable for all but the smallest of feature sets. The choice of evaluation metric heavily influences the algorithm, and it is these evaluation metrics which distinguish between the three main categories of feature selection algorithms: wrappers, filters and embedded methods.[10]

Wrapper methods use a predictive model to score feature subsets. Each new subset is used to train a model, which is tested on a hold-out set. Counting the number of mistakes made on that hold-out set (the error rate of the model) gives the score for that subset. As wrapper methods train a new model for each subset, they are very computationally intensive, but usually provide the best performing feature set for that particular type of model or typical problem.
Filter methods use a proxy measure instead of the error rate to score a feature subset. This measure is chosen to be fast to compute, while still capturing the usefulness of the feature set. Common measures include the mutual information,[10] the pointwise mutual information,[12] Pearson product-moment correlation coefficient, Relief-based algorithms,[13] and inter/intra class distance or the scores of significance tests for each class/feature combinations.[12][14] Filters are usually less computationally intensive than wrappers, but they produce a feature set which is not tuned to a specific type of predictive model.[15] This lack of tuning means a feature set from a filter is more general than the set from a wrapper, usually giving lower prediction performance than a wrapper. However the feature set doesn't contain the assumptions of a prediction model, and so is more useful for exposing the relationships between the features. Many filters provide a feature ranking rather than an explicit best feature subset, and the cut off point in the ranking is chosen via cross-validation. Filter methods have also been used as a preprocessing step for wrapper methods, allowing a wrapper to be used on larger problems. One other popular approach is the Recursive Feature Elimination algorithm,[16] commonly used with Support Vector Machines to repeatedly construct a model and remove features with low weights.
Embedded methods are a catch-all group of techniques which perform feature selection as part of the model construction process. The exemplar of this approach is the LASSO method for constructing a linear model, which penalizes the regression coefficients with an L1 penalty, shrinking many of them to zero. Any features which have non-zero regression coefficients are 'selected' by the LASSO algorithm. Improvements to the LASSO include Bolasso which bootstraps samples;[17] Elastic net regularization, which combines the L1 penalty of LASSO with the L2 penalty of ridge regression; and FeaLect which scores all the features based on combinatorial analysis of regression coefficients.[18] AEFS further extends LASSO to nonlinear scenario with autoencoders.[19] These approaches tend to be between filters and wrappers in terms of computational complexity.
In traditional regression analysis, the most popular form of feature selection is stepwise regression, which is a wrapper technique.  It is a greedy algorithm that adds the best feature (or deletes the worst feature) at each round.  The main control issue is deciding when to stop the algorithm.  In machine learning, this is typically done by cross-validation.  In statistics, some criteria are optimized.  This leads to the inherent problem of nesting. More robust methods have been explored, such as branch and bound and piecewise linear network.

Subset selection[edit]
Subset selection evaluates a subset of features as a group for suitability. Subset selection algorithms can be broken up into wrappers, filters, and embedded methods. Wrappers use a search algorithm to search through the space of possible features and evaluate each subset by running a model on the subset. Wrappers can be computationally expensive and have a risk of over fitting to the model. Filters are similar to wrappers in the search approach, but instead of evaluating against a model, a simpler filter is evaluated. Embedded techniques are embedded in, and specific to, a model.
Many popular search approaches use greedy hill climbing, which iteratively evaluates a candidate subset of features, then modifies the subset and evaluates if the new subset is an improvement over the old. Evaluation of the subsets requires a scoring metric that grades a subset of features.  Exhaustive search is generally impractical, so at some implementor (or operator) defined stopping point, the subset of features with the highest score discovered up to that point is selected as the satisfactory feature subset.  The stopping criterion varies by algorithm; possible criteria include: a subset score exceeds a threshold, a program's maximum allowed run time has been surpassed, etc.
Alternative search-based techniques are based on targeted projection pursuit which finds low-dimensional projections of the data that score highly: the features that have the largest projections in the lower-dimensional space are then selected.
Search approaches include:

Exhaustive[20]
Best first
Simulated annealing
Genetic algorithm[21]
Greedy forward selection[22][23][24]
Greedy backward elimination
Particle swarm optimization[25]
Targeted projection pursuit
Scatter search[26][27]
Variable neighborhood search[28][29]
Two popular filter metrics for classification problems are correlation and mutual information, although neither are true metrics or 'distance measures' in the mathematical sense, since they fail to obey the triangle inequality and thus do not compute any actual 'distance' â they should rather be regarded as 'scores'.  These scores are computed between a candidate feature (or set of features) and the desired output category.  There are, however, true metrics that are a simple function of the mutual information;[30] see here.
Other available filter metrics include:

Class separability
Error probability
Inter-class distance
Probabilistic distance
Entropy
Consistency-based feature selection
Correlation-based feature selection
Optimality criteria[edit]
The choice of optimality criteria is difficult as there are multiple objectives in a feature selection task. Many common criteria incorporate a measure of accuracy, penalised by the number of features selected. Examples include Akaike information criterion (AIC) and Mallows's Cp, which have a penalty of 2 for each added feature. AIC is based on information theory, and is effectively derived via the maximum entropy principle.[31][32]
Other criteria are Bayesian information criterion (BIC), which uses a penalty of 
  
    
      
        
          
            log
            â¡
            
              n
            
          
        
      
    
    {\displaystyle {\sqrt {\log {n}}}}
  
 for each added feature, minimum description length (MDL) which asymptotically uses 
  
    
      
        
          
            log
            â¡
            
              n
            
          
        
      
    
    {\displaystyle {\sqrt {\log {n}}}}
  
, Bonferroni / RIC which use 
  
    
      
        
          
            2
            log
            â¡
            
              p
            
          
        
      
    
    {\displaystyle {\sqrt {2\log {p}}}}
  
, maximum dependency feature selection, and a variety of new criteria that are motivated by false discovery rate (FDR), which use something close to 
  
    
      
        
          
            2
            log
            â¡
            
              
                p
                q
              
            
          
        
      
    
    {\displaystyle {\sqrt {2\log {\frac {p}{q}}}}}
  
. A maximum entropy rate criterion may also be used to select the most relevant subset of features.[33]

Structure learning[edit]
Filter feature selection is a specific case of a more general paradigm called structure learning. Feature selection finds the relevant feature set for a specific target variable whereas structure learning finds the relationships between all the variables, usually by expressing these relationships as a graph. The most common structure learning algorithms assume the data is generated by a Bayesian Network, and so the structure is a directed graphical model. The optimal solution to the filter feature selection problem is the Markov blanket of the target node, and in a Bayesian Network, there is a unique Markov Blanket for each node.[34]

Information Theory Based Feature Selection Mechanisms[edit]
There are different Feature Selection mechanisms around that utilize mutual information for scoring the different features. They usually use all the same algorithm:

Calculate the mutual information as score for between all features (
  
    
      
        
          f
          
            i
          
        
        â
        F
      
    
    {\displaystyle f_{i}\in F}
  
) and the target class (c)
Select the feature with the largest score (e.g. 
  
    
      
        
          
            argmax
            
              
                f
                
                  i
                
              
              â
              F
            
          
        
        (
        I
        (
        
          f
          
            i
          
        
        ,
        c
        )
        )
      
    
    {\displaystyle {\underset {f_{i}\in F}{\operatorname {argmax} }}(I(f_{i},c))}
  
) and add it to the set of selected features (S)
Calculate the score which might be derived from the mutual information
Select the feature with the largest score and add it to the set of select features (e.g. 
  
    
      
        
          
            argmax
            
              
                f
                
                  i
                
              
              â
              F
            
          
        
        (
        
          I
          
            d
            e
            r
            i
            v
            e
            d
          
        
        (
        
          f
          
            i
          
        
        ,
        c
        )
        )
      
    
    {\displaystyle {\underset {f_{i}\in F}{\operatorname {argmax} }}(I_{derived}(f_{i},c))}
  
)
Repeat 3. and 4. until a certain number of features is selected (e.g. 
  
    
      
        
          |
        
        S
        
          |
        
        =
        l
      
    
    {\displaystyle |S|=l}
  
)
The simplest approach uses the mutual information as the "derived" score.[35]
However, there are different approaches, that try to reduce the redundancy between features.

Minimum-redundancy-maximum-relevance (mRMR) feature selection[edit]
Peng et al.[36] proposed a feature selection method that can use either mutual information, correlation, or distance/similarity scores to select features. The aim is to penalise a feature's relevancy by its redundancy in the presence of the other selected features. The relevance of a feature set S for the class c is defined by the average value of all mutual information values between the individual feature fi and the class c as follows:


  
    
      
        D
        (
        S
        ,
        c
        )
        =
        
          
            1
            
              
                |
              
              S
              
                |
              
            
          
        
        
          â
          
            
              f
              
                i
              
            
            â
            S
          
        
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle D(S,c)={\frac {1}{|S|}}\sum _{f_{i}\in S}I(f_{i};c)}
  
.
The redundancy of all features in the set S is the average value of all mutual information values between the feature fi and the feature fj:


  
    
      
        R
        (
        S
        )
        =
        
          
            1
            
              
                |
              
              S
              
                
                  |
                
                
                  2
                
              
            
          
        
        
          â
          
            
              f
              
                i
              
            
            ,
            
              f
              
                j
              
            
            â
            S
          
        
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
      
    
    {\displaystyle R(S)={\frac {1}{|S|^{2}}}\sum _{f_{i},f_{j}\in S}I(f_{i};f_{j})}
  

The mRMR criterion is a combination of two measures given above and is defined as follows:


  
    
      
        
          m
          R
          M
          R
        
        =
        
          max
          
            S
          
        
        
          [
          
            
              
                1
                
                  
                    |
                  
                  S
                  
                    |
                  
                
              
            
            
              â
              
                
                  f
                  
                    i
                  
                
                â
                S
              
            
            I
            (
            
              f
              
                i
              
            
            ;
            c
            )
            â
            
              
                1
                
                  
                    |
                  
                  S
                  
                    
                      |
                    
                    
                      2
                    
                  
                
              
            
            
              â
              
                
                  f
                  
                    i
                  
                
                ,
                
                  f
                  
                    j
                  
                
                â
                S
              
            
            I
            (
            
              f
              
                i
              
            
            ;
            
              f
              
                j
              
            
            )
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {mRMR} =\max _{S}\left[{\frac {1}{|S|}}\sum _{f_{i}\in S}I(f_{i};c)-{\frac {1}{|S|^{2}}}\sum _{f_{i},f_{j}\in S}I(f_{i};f_{j})\right].}
  

Suppose that there are n full-set features. Let xi be the set membership indicator function for feature fi, so that xi=1 indicates presence and xi=0 indicates absence of the feature fi in the globally optimal feature set. Let 
  
    
      
        
          c
          
            i
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle c_{i}=I(f_{i};c)}
  
 and 
  
    
      
        
          a
          
            i
            j
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
      
    
    {\displaystyle a_{ij}=I(f_{i};f_{j})}
  
. The above may then be written as an optimization problem:


  
    
      
        
          m
          R
          M
          R
        
        =
        
          max
          
            x
            â
            {
            0
            ,
            1
            
              }
              
                n
              
            
          
        
        
          [
          
            
              
                
                  
                    â
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    c
                    
                      i
                    
                  
                  
                    x
                    
                      i
                    
                  
                
                
                  
                    â
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    x
                    
                      i
                    
                  
                
              
            
            â
            
              
                
                  
                    â
                    
                      i
                      ,
                      j
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    a
                    
                      i
                      j
                    
                  
                  
                    x
                    
                      i
                    
                  
                  
                    x
                    
                      j
                    
                  
                
                
                  (
                  
                    â
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    x
                    
                      i
                    
                  
                  
                    )
                    
                      2
                    
                  
                
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {mRMR} =\max _{x\in \{0,1\}^{n}}\left[{\frac {\sum _{i=1}^{n}c_{i}x_{i}}{\sum _{i=1}^{n}x_{i}}}-{\frac {\sum _{i,j=1}^{n}a_{ij}x_{i}x_{j}}{(\sum _{i=1}^{n}x_{i})^{2}}}\right].}
  

The mRMR algorithm is an approximation of the theoretically optimal maximum-dependency feature selection algorithm that maximizes the mutual information between the joint distribution of the selected features and the classification variable. As mRMR approximates the combinatorial estimation problem with a series of much smaller problems, each of which only involves two variables, it thus uses pairwise joint probabilities which are more robust. In certain situations the algorithm may underestimate the usefulness of features as it has no way to measure interactions between features which can increase relevancy. This can lead to poor performance[35] when the features are individually useless, but are useful when combined (a pathological case is found when the class is a parity function of the features). Overall the algorithm is more efficient (in terms of the amount of data required) than the theoretically optimal max-dependency selection, yet produces a feature set with little pairwise redundancy.
mRMR is an instance of a large class of filter methods which trade off between relevancy and redundancy in different ways.[35][37]

Quadratic programming feature selection[edit]
mRMR is a typical example of an incremental greedy strategy for feature selection: once a feature has been selected, it cannot be deselected at a later stage. While mRMR could be optimized using floating search to reduce some features, it might also be reformulated as a global quadratic programming optimization problem as follows:[38]


  
    
      
        
          Q
          P
          F
          S
        
        :
        
          min
          
            
              x
            
          
        
        
          {
          
            Î±
            
              
                x
              
              
                T
              
            
            H
            
              x
            
            â
            
              
                x
              
              
                T
              
            
            F
          
          }
        
        
        
          
            s.t.
          
        
        Â 
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          x
          
            i
          
        
        =
        1
        ,
        
          x
          
            i
          
        
        â¥
        0
      
    
    {\displaystyle \mathrm {QPFS} :\min _{\mathbf {x} }\left\{\alpha \mathbf {x} ^{T}H\mathbf {x} -\mathbf {x} ^{T}F\right\}\quad {\mbox{s.t.}}\ \sum _{i=1}^{n}x_{i}=1,x_{i}\geq 0}
  

where 
  
    
      
        
          F
          
            n
            Ã
            1
          
        
        =
        [
        I
        (
        
          f
          
            1
          
        
        ;
        c
        )
        ,
        â¦
        ,
        I
        (
        
          f
          
            n
          
        
        ;
        c
        )
        
          ]
          
            T
          
        
      
    
    {\displaystyle F_{n\times 1}=[I(f_{1};c),\ldots ,I(f_{n};c)]^{T}}
  
 is the vector of feature relevancy assuming there are n features in total, 
  
    
      
        
          H
          
            n
            Ã
            n
          
        
        =
        [
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
        
          ]
          
            i
            ,
            j
            =
            1
            â¦
            n
          
        
      
    
    {\displaystyle H_{n\times n}=[I(f_{i};f_{j})]_{i,j=1\ldots n}}
  
 is the matrix of feature pairwise redundancy, and 
  
    
      
        
          
            x
          
          
            n
            Ã
            1
          
        
      
    
    {\displaystyle \mathbf {x} _{n\times 1}}
  
 represents relative feature weights. QPFS is solved via quadratic programming. It is recently shown that QFPS is biased towards features with smaller entropy,[39] due to its placement of the feature self redundancy term 
  
    
      
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            i
          
        
        )
      
    
    {\displaystyle I(f_{i};f_{i})}
  
 on the diagonal of H.

Conditional mutual information[edit]
Another score derived for the mutual information is based on the conditional relevancy:[39]


  
    
      
        
          S
          P
          E
          
            C
            
              C
              M
              I
            
          
        
        :
        
          max
          
            
              x
            
          
        
        
          {
          
            
              
                x
              
              
                T
              
            
            Q
            
              x
            
          
          }
        
        
        
          
            s.t.
          
        
        Â 
        â
        
          x
        
        â
        =
        1
        ,
        
          x
          
            i
          
        
        â¥
        0
      
    
    {\displaystyle \mathrm {SPEC_{CMI}} :\max _{\mathbf {x} }\left\{\mathbf {x} ^{T}Q\mathbf {x} \right\}\quad {\mbox{s.t.}}\ \|\mathbf {x} \|=1,x_{i}\geq 0}
  

where 
  
    
      
        
          Q
          
            i
            i
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle Q_{ii}=I(f_{i};c)}
  
 and 
  
    
      
        
          Q
          
            i
            j
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        
          |
        
        
          f
          
            j
          
        
        )
        ,
        i
        â 
        j
      
    
    {\displaystyle Q_{ij}=I(f_{i};c|f_{j}),i\neq j}
  
.
An advantage of SPECCMI is that it can be solved simply via finding the dominant eigenvector of Q, thus is very scalable. SPECCMI also handles second-order feature interaction.

Joint mutual information[edit]
In a study of different scores Brown et al.[35]  recommended the joint mutual information[40] as a good score for feature selection. The score tries to find the feature, that adds the most new information to the already selected features, in order to avoid redundancy. The score is formulated as follows:


  
    
      
        
          
            
              
                J
                M
                I
                (
                
                  f
                  
                    i
                  
                
                )
              
              
                
                =
                
                  â
                  
                    
                      f
                      
                        j
                      
                    
                    â
                    S
                  
                
                (
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                )
                +
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                
                  |
                
                
                  f
                  
                    j
                  
                
                )
                )
              
            
            
              
              
                
                =
                
                  â
                  
                    
                      f
                      
                        j
                      
                    
                    â
                    S
                  
                
                
                  
                    [
                  
                
                I
                (
                
                  f
                  
                    j
                  
                
                ;
                c
                )
                +
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                )
                â
                
                  
                    (
                  
                
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                
                  f
                  
                    j
                  
                
                )
                â
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                
                  f
                  
                    j
                  
                
                
                  |
                
                c
                )
                
                  
                    )
                  
                
                
                  
                    ]
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}JMI(f_{i})&=\sum _{f_{j}\in S}(I(f_{i};c)+I(f_{i};c|f_{j}))\\&=\sum _{f_{j}\in S}{\bigl [}I(f_{j};c)+I(f_{i};c)-{\bigl (}I(f_{i};f_{j})-I(f_{i};f_{j}|c){\bigr )}{\bigr ]}\end{aligned}}}
  

The score uses the conditional mutual information and the mutual information to estimate the redundancy between the already selected features (
  
    
      
        
          f
          
            j
          
        
        â
        S
      
    
    {\displaystyle f_{j}\in S}
  
) and the feature under investigation (
  
    
      
        
          f
          
            i
          
        
      
    
    {\displaystyle f_{i}}
  
).

Hilbert-Schmidt Independence Criterion Lasso based feature selection[edit]
For high-dimensional and small sample data (e.g., dimensionality > 105 and the number of samples < 103), the Hilbert-Schmidt Independence Criterion Lasso (HSIC Lasso) is useful.[41] HSIC Lasso optimization problem is given as


  
    
      
        
          H
          S
          I
          
            C
            
              L
              a
              s
              s
              o
            
          
        
        :
        
          min
          
            
              x
            
          
        
        
          
            1
            2
          
        
        
          â
          
            k
            ,
            l
            =
            1
          
          
            n
          
        
        
          x
          
            k
          
        
        
          x
          
            l
          
        
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        
          f
          
            l
          
        
        )
        â
        
          â
          
            k
            =
            1
          
          
            n
          
        
        
          x
          
            k
          
        
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        c
        )
        +
        Î»
        â
        
          x
        
        
          â
          
            1
          
        
        ,
        
        
          
            s.t.
          
        
        Â 
        
          x
          
            1
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        â¥
        0
        ,
      
    
    {\displaystyle \mathrm {HSIC_{Lasso}} :\min _{\mathbf {x} }{\frac {1}{2}}\sum _{k,l=1}^{n}x_{k}x_{l}{\mbox{HSIC}}(f_{k},f_{l})-\sum _{k=1}^{n}x_{k}{\mbox{HSIC}}(f_{k},c)+\lambda \|\mathbf {x} \|_{1},\quad {\mbox{s.t.}}\ x_{1},\ldots ,x_{n}\geq 0,}
  

where 
  
    
      
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        c
        )
        =
        
          
            tr
          
        
        (
        
          
            
              
                
                  K
                
                Â¯
              
            
          
          
            (
            k
            )
          
        
        
          
            
              
                L
              
              Â¯
            
          
        
        )
      
    
    {\displaystyle {\mbox{HSIC}}(f_{k},c)={\mbox{tr}}({\bar {\mathbf {K} }}^{(k)}{\bar {\mathbf {L} }})}
  
 is a kernel-based independence measure called the (empirical) Hilbert-Schmidt independence criterion (HSIC), 
  
    
      
        
          
            tr
          
        
        (
        â
        )
      
    
    {\displaystyle {\mbox{tr}}(\cdot )}
  
 denotes the trace, 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 is the regularization parameter, 
  
    
      
        
          
            
              
                
                  K
                
                Â¯
              
            
          
          
            (
            k
            )
          
        
        =
        
          Î
        
        
          
            K
          
          
            (
            k
            )
          
        
        
          Î
        
      
    
    {\displaystyle {\bar {\mathbf {K} }}^{(k)}=\mathbf {\Gamma } \mathbf {K} ^{(k)}\mathbf {\Gamma } }
  
 and 
  
    
      
        
          
            
              
                L
              
              Â¯
            
          
        
        =
        
          Î
        
        
          L
        
        
          Î
        
      
    
    {\displaystyle {\bar {\mathbf {L} }}=\mathbf {\Gamma } \mathbf {L} \mathbf {\Gamma } }
  
 are input and output centered Gram matrices, 
  
    
      
        
          K
          
            i
            ,
            j
          
          
            (
            k
            )
          
        
        =
        K
        (
        
          u
          
            k
            ,
            i
          
        
        ,
        
          u
          
            k
            ,
            j
          
        
        )
      
    
    {\displaystyle K_{i,j}^{(k)}=K(u_{k,i},u_{k,j})}
  
 and 
  
    
      
        
          L
          
            i
            ,
            j
          
        
        =
        L
        (
        
          c
          
            i
          
        
        ,
        
          c
          
            j
          
        
        )
      
    
    {\displaystyle L_{i,j}=L(c_{i},c_{j})}
  
 are Gram matrices, 
  
    
      
        K
        (
        u
        ,
        
          u
          â²
        
        )
      
    
    {\displaystyle K(u,u')}
  
 and 
  
    
      
        L
        (
        c
        ,
        
          c
          â²
        
        )
      
    
    {\displaystyle L(c,c')}
  
 are kernel functions, 
  
    
      
        
          Î
        
        =
        
          
            I
          
          
            m
          
        
        â
        
          
            1
            m
          
        
        
          
            1
          
          
            m
          
        
        
          
            1
          
          
            m
          
          
            T
          
        
      
    
    {\displaystyle \mathbf {\Gamma } =\mathbf {I} _{m}-{\frac {1}{m}}\mathbf {1} _{m}\mathbf {1} _{m}^{T}}
  
 is the centering matrix, 
  
    
      
        
          
            I
          
          
            m
          
        
      
    
    {\displaystyle \mathbf {I} _{m}}
  
 is the m-dimensional identity matrix (m: the number of samples), 
  
    
      
        
          
            1
          
          
            m
          
        
      
    
    {\displaystyle \mathbf {1} _{m}}
  
 is the m-dimensional vector with all ones, and  
  
    
      
        â
        â
        
          â
          
            1
          
        
      
    
    {\displaystyle \|\cdot \|_{1}}
  
 is the 
  
    
      
        
          â
          
            1
          
        
      
    
    {\displaystyle \ell _{1}}
  
-norm.  HSIC always takes a non-negative value, and is zero if and only if two random variables are statistically independent when a universal reproducing kernel such as the Gaussian kernel is used.
The HSIC Lasso can be written as


  
    
      
        
          H
          S
          I
          
            C
            
              L
              a
              s
              s
              o
            
          
        
        :
        
          min
          
            
              x
            
          
        
        
          
            1
            2
          
        
        
          
            â
            
              
                
                  
                    
                      L
                    
                    Â¯
                  
                
              
              â
              
                â
                
                  k
                  =
                  1
                
                
                  n
                
              
              
                x
                
                  k
                
              
              
                
                  
                    
                      
                        K
                      
                      Â¯
                    
                  
                
                
                  (
                  k
                  )
                
              
            
            â
          
          
            F
          
          
            2
          
        
        +
        Î»
        â
        
          x
        
        
          â
          
            1
          
        
        ,
        
        
          
            s.t.
          
        
        Â 
        
          x
          
            1
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        â¥
        0
        ,
      
    
    {\displaystyle \mathrm {HSIC_{Lasso}} :\min _{\mathbf {x} }{\frac {1}{2}}\left\|{\bar {\mathbf {L} }}-\sum _{k=1}^{n}x_{k}{\bar {\mathbf {K} }}^{(k)}\right\|_{F}^{2}+\lambda \|\mathbf {x} \|_{1},\quad {\mbox{s.t.}}\ x_{1},\ldots ,x_{n}\geq 0,}
  

where 
  
    
      
        â
        â
        
          â
          
            F
          
        
      
    
    {\displaystyle \|\cdot \|_{F}}
  
 is the Frobenius norm. The optimization problem is a Lasso problem, and thus it can be efficiently solved with a state-of-the-art Lasso solver such as the dual augmented Lagrangian method.

Correlation feature selection[edit]
The correlation feature selection (CFS) measure evaluates subsets of features on the basis of the following hypothesis: "Good feature subsets contain features highly correlated with the classification, yet uncorrelated to each other".[42][43] The following equation gives the merit of a feature subset S consisting of k features:


  
    
      
        
          
            M
            e
            r
            i
            t
          
          
            
              S
              
                k
              
            
          
        
        =
        
          
            
              k
              
                
                  
                    r
                    
                      c
                      f
                    
                  
                  Â¯
                
              
            
            
              k
              +
              k
              (
              k
              â
              1
              )
              
                
                  
                    r
                    
                      f
                      f
                    
                  
                  Â¯
                
              
            
          
        
        .
      
    
    {\displaystyle \mathrm {Merit} _{S_{k}}={\frac {k{\overline {r_{cf}}}}{\sqrt {k+k(k-1){\overline {r_{ff}}}}}}.}
  

Here, 
  
    
      
        
          
            
              r
              
                c
                f
              
            
            Â¯
          
        
      
    
    {\displaystyle {\overline {r_{cf}}}}
  
 is the average value of all feature-classification correlations, and 
  
    
      
        
          
            
              r
              
                f
                f
              
            
            Â¯
          
        
      
    
    {\displaystyle {\overline {r_{ff}}}}
  
 is the average value of all feature-feature correlations. The CFS criterion is defined as follows:


  
    
      
        
          C
          F
          S
        
        =
        
          max
          
            
              S
              
                k
              
            
          
        
        
          [
          
            
              
                
                  r
                  
                    c
                    
                      f
                      
                        1
                      
                    
                  
                
                +
                
                  r
                  
                    c
                    
                      f
                      
                        2
                      
                    
                  
                
                +
                â¯
                +
                
                  r
                  
                    c
                    
                      f
                      
                        k
                      
                    
                  
                
              
              
                k
                +
                2
                (
                
                  r
                  
                    
                      f
                      
                        1
                      
                    
                    
                      f
                      
                        2
                      
                    
                  
                
                +
                â¯
                +
                
                  r
                  
                    
                      f
                      
                        i
                      
                    
                    
                      f
                      
                        j
                      
                    
                  
                
                +
                â¯
                +
                
                  r
                  
                    
                      f
                      
                        k
                      
                    
                    
                      f
                      
                        k
                        â
                        1
                      
                    
                  
                
                )
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {CFS} =\max _{S_{k}}\left[{\frac {r_{cf_{1}}+r_{cf_{2}}+\cdots +r_{cf_{k}}}{\sqrt {k+2(r_{f_{1}f_{2}}+\cdots +r_{f_{i}f_{j}}+\cdots +r_{f_{k}f_{k-1}})}}}\right].}
  

The 
  
    
      
        
          r
          
            c
            
              f
              
                i
              
            
          
        
      
    
    {\displaystyle r_{cf_{i}}}
  
 and 
  
    
      
        
          r
          
            
              f
              
                i
              
            
            
              f
              
                j
              
            
          
        
      
    
    {\displaystyle r_{f_{i}f_{j}}}
  
 variables are referred to as correlations, but are not necessarily Pearson's correlation coefficient or Spearman's Ï. Hall's dissertation uses neither of these, but uses three different measures of relatedness, minimum description length (MDL), symmetrical uncertainty, and relief.
Let xi be the set membership indicator function for feature fi; then the above can be rewritten as an optimization problem:


  
    
      
        
          C
          F
          S
        
        =
        
          max
          
            x
            â
            {
            0
            ,
            1
            
              }
              
                n
              
            
          
        
        
          [
          
            
              
                (
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  a
                  
                    i
                  
                
                
                  x
                  
                    i
                  
                
                
                  )
                  
                    2
                  
                
              
              
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  x
                  
                    i
                  
                
                +
                
                  â
                  
                    i
                    â 
                    j
                  
                
                2
                
                  b
                  
                    i
                    j
                  
                
                
                  x
                  
                    i
                  
                
                
                  x
                  
                    j
                  
                
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {CFS} =\max _{x\in \{0,1\}^{n}}\left[{\frac {(\sum _{i=1}^{n}a_{i}x_{i})^{2}}{\sum _{i=1}^{n}x_{i}+\sum _{i\neq j}2b_{ij}x_{i}x_{j}}}\right].}
  

The combinatorial problems above are, in fact, mixed 0â1 linear programming problems that can be solved by using branch-and-bound algorithms.[44]

Regularized trees[edit]
The features from a decision tree or a tree ensemble are shown to be redundant. A recent method called regularized tree[45] can be used for feature subset selection. Regularized trees penalize using a variable similar to the variables selected at previous tree nodes for splitting the current node. Regularized trees only need build one tree model (or one tree ensemble model) and thus are computationally efficient.
Regularized trees naturally handle numerical and categorical features, interactions and nonlinearities. They are invariant to attribute scales (units) and insensitive to outliers, and thus, require little data preprocessing such as normalization. Regularized random forest (RRF)[46] is one type of regularized trees. The guided RRF is an enhanced RRF which is guided by the importance scores from an ordinary random forest.

Overview on metaheuristics methods[edit]
A metaheuristic is a general description of an algorithm dedicated to solve difficult (typically NP-hard problem) optimization problems for which there is no classical solving methods. Generally, a metaheuristic is a stochastic algorithm tending to reach a global optimum. There are many metaheuristics, from a simple local search to a complex global search algorithm.

Main principles[edit]
The feature selection methods are typically presented in three classes based on how they combine the selection algorithm and the model building.

Filter method[edit]
  Filter Method for feature selection
Filter type methods select variables regardless of the model. They are based only on general features like the correlation with the variable to predict. Filter methods suppress the least interesting variables. The other variables will be part of a classification or a regression model used to classify or to predict data. These methods are particularly effective in computation time and robust to overfitting.[47]
Filter methods tend to select redundant variables when they do not consider the relationships between variables. However, more elaborate features try to minimize this problem by removing variables highly correlated to each other, such as the Fast Correlation Based Filter (FCBF) algorithm.[48]

Wrapper method[edit]
  Wrapper Method for Feature selection
Wrapper methods evaluate subsets of variables which allows, unlike filter approaches, to detect the possible interactions amongst variables.[49] The two main disadvantages of these methods are: 

The increasing overfitting risk when the number of observations is insufficient.
The significant computation time when the number of variables is large.
Embedded method[edit]
  Embedded method for Feature selection
Embedded methods have been recently proposed that try to combine the advantages of both previous methods. A learning algorithm takes advantage of its own variable selection process and performs feature selection and classification simultaneously, such as the FRMT algorithm.[50]

Application of feature selection metaheuristics[edit]
This is a survey of the application of feature selection metaheuristics lately used in the literature. This survey was realized by J. Hammon in her 2013 thesis.[47]




Application
Algorithm
Approach
Classifier
Evaluation Function
Reference


SNPs
Feature Selection using Feature Similarity
Filter

r2
Phuong 2005[49]


SNPs
Genetic algorithm
Wrapper
Decision Tree
Classification accuracy (10-fold)
Shah 2004[51]


SNPs
Hill climbing
Filter + Wrapper
Naive Bayesian
Predicted residual sum of squares
Long 2007[52]


SNPs
Simulated annealing

Naive bayesian
Classification accuracy (5-fold)
Ustunkar 2011[53]


Segments parole
Ant colony
Wrapper
Artificial Neural Network
MSE
Al-ani 2005[citation needed]


Marketing
Simulated annealing
Wrapper
Regression
AIC, r2
Meiri 2006[54]


Economics
Simulated annealing, genetic algorithm
Wrapper
Regression
BIC
Kapetanios 2007[55]


Spectral Mass
Genetic algorithm
Wrapper
Multiple Linear Regression, Partial Least Squares
root-mean-square error of prediction
Broadhurst et al. 1997[56]


Spam
Binary PSO + Mutation
Wrapper
Decision tree
weighted cost
Zhang 2014[25]


Microarray
Tabu search + PSO
Wrapper
Support Vector Machine, K Nearest Neighbors
Euclidean Distance
Chuang 2009[57]


Microarray
PSO + Genetic algorithm
Wrapper
Support Vector Machine
Classification accuracy (10-fold)
Alba 2007[58]


Microarray
Genetic algorithm + Iterated Local Search
Embedded
Support Vector Machine
Classification accuracy (10-fold)
Duval 2009[59]


Microarray
Iterated local search
Wrapper
Regression
Posterior Probability
Hans 2007[60]


Microarray
Genetic algorithm
Wrapper
K Nearest Neighbors
Classification accuracy (Leave-one-out cross-validation)
Jirapech-Umpai 2005[61]


Microarray
Hybrid genetic algorithm
Wrapper
K Nearest Neighbors
Classification accuracy (Leave-one-out cross-validation)
Oh 2004[62]


Microarray
Genetic algorithm
Wrapper
Support Vector Machine
Sensitivity and specificity
Xuan 2011[63]


Microarray
Genetic algorithm
Wrapper
All paired Support Vector Machine
Classification accuracy (Leave-one-out cross-validation)
Peng 2003[64]


Microarray
Genetic algorithm
Embedded
Support Vector Machine
Classification accuracy (10-fold)
Hernandez 2007[65]


Microarray
Genetic algorithm
Hybrid
Support Vector Machine
Classification accuracy (Leave-one-out cross-validation)
Huerta 2006[66]


Microarray
Genetic algorithm

Support Vector Machine
Classification accuracy (10-fold)
Muni 2006[67]


Microarray
Genetic algorithm
Wrapper
Support Vector Machine
EH-DIALL, CLUMP
Jourdan 2005[68]


Alzheimer's disease
Welch's t-test
Filter
Support vector machine
Classification accuracy (10-fold)
Zhang 2015[69]


Computer vision

Infinite Feature Selection

Filter

Independent

Average Precision, ROC AUC

Roffo 2015[70]


Microarrays

Eigenvector Centrality FS

Filter

Independent

Average Precision, Accuracy, ROC AUC

Roffo & Melzi 2016[71]


XML

Symmetrical Tau (ST)

Filter

Structural Associative Classification

Accuracy, Coverage

Shaharanee & Hadzic 2014

Feature selection embedded in learning algorithms[edit]
Some learning algorithms perform feature selection as part of their overall operation. These include:


  
    
      
        
          l
          
            1
          
        
      
    
    {\displaystyle l_{1}}
  
-regularization techniques, such as sparse regression, LASSO, and 
  
    
      
        
          l
          
            1
          
        
      
    
    {\displaystyle l_{1}}
  
-SVM
Regularized trees,[45] e.g. regularized random forest implemented in the RRF package[46]
Decision tree[72]
Memetic algorithm
Random multinomial logit (RMNL)
Auto-encoding networks with a bottleneck-layer
Submodular feature selection[73][74][75]
Local learning based feature selection.[76] Compared with traditional methods, it does not involve any heuristic search, can easily handle multi-class problems, and works for both linear and nonlinear problems. It is also supported by a strong theoretical foundation. Numeric experiments showed that the method can achieve a close-to-optimal solution even when data contains >1M irrelevant features.
Recommender system based on feature selection.[77] The feature selection methods are introduced into recommender system research.
See also[edit]
Cluster analysis
Data mining
Dimensionality reduction
Feature extraction
Hyperparameter optimization
Model selection
Relief (feature selection)
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Gareth James; Daniela Witten; Trevor Hastie; Robert Tibshirani (2013). An Introduction to Statistical Learning. Springer. p.Â 204.

^ Brank, Janez; MladeniÄ, Dunja; Grobelnik, Marko; Liu, Huan; MladeniÄ, Dunja; Flach, Peter A.; Garriga, Gemma C.; Toivonen, Hannu; Toivonen, Hannu (2011), "Feature Selection",  in Sammut, Claude; Webb, Geoffrey I. (eds.), Encyclopedia of Machine Learning, Boston, MA: Springer US, pp.Â 402â406, doi:10.1007/978-0-387-30164-8_306, ISBNÂ 978-0-387-30768-8, retrieved 2021-07-13

^ Kramer, Mark A. (1991). "Nonlinear principal component analysis using autoassociative neural networks". AIChE Journal. 37 (2): 233â243. doi:10.1002/aic.690370209. ISSNÂ 1547-5905.

^ Kratsios, Anastasis; Hyndman, Cody (2021). "NEU: A Meta-Algorithm for Universal UAP-Invariant Feature Representation". Journal of Machine Learning Research. 22 (92): 1â51. ISSNÂ 1533-7928.

^ Persello, Claudio; Bruzzone, Lorenzo (July 2014). "Relevant and invariant feature selection of hyperspectral images for domain generalization". 2014 IEEE Geoscience and Remote Sensing Symposium. IEEE: 3562â3565. doi:10.1109/igarss.2014.6947252. ISBNÂ 978-1-4799-5775-0. S2CIDÂ 8368258.

^ Hinkle, Jacob; Muralidharan, Prasanna; Fletcher, P. Thomas; Joshi, Sarang (2012).  Fitzgibbon, Andrew; Lazebnik, Svetlana; Perona, Pietro; Sato, Yoichi; Schmid, Cordelia (eds.). "Polynomial Regression on Riemannian Manifolds". Computer Vision â ECCV 2012. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer. 7574: 1â14. arXiv:1201.2395. doi:10.1007/978-3-642-33712-3_1. ISBNÂ 978-3-642-33712-3. S2CIDÂ 8849753.

^ Yarotsky, Dmitry (2021-04-30). "Universal Approximations of Invariant Maps by Neural Networks". Constructive Approximation. arXiv:1804.10306. doi:10.1007/s00365-021-09546-1. ISSNÂ 1432-0940. S2CIDÂ 13745401.

^ Hauberg, SÃ¸ren; Lauze, FranÃ§ois; Pedersen, Kim Steenstrup (2013-05-01). "Unscented Kalman Filtering on Riemannian Manifolds". Journal of Mathematical Imaging and Vision. 46 (1): 103â120. doi:10.1007/s10851-012-0372-9. ISSNÂ 1573-7683. S2CIDÂ 8501814.

^ Kratsios, Anastasis; Hyndman, Cody (June 8, 2021). "NEU: A Meta-Algorithm for Universal UAP-Invariant Feature Representation". JMLR. 22: 1â51. Bibcode:2015NatSR...510312B.

^ Jump up to: a b c Guyon, Isabelle; Elisseeff, AndrÃ© (2003). "An Introduction to Variable and Feature Selection". JMLR. 3.

^ Sarangi, Susanta; Sahidullah, Md; Saha, Goutam (September 2020). "Optimization of data-driven filterbank for automatic speaker verification". Digital Signal Processing. 104: 102795. arXiv:2007.10729. doi:10.1016/j.dsp.2020.102795. S2CIDÂ 220665533.

^ Jump up to: a b Yang, Yiming; Pedersen, Jan O. (1997). A comparative study on feature selection in text categorization (PDF). ICML.

^ Urbanowicz, Ryan J.; Meeker, Melissa; LaCava, William; Olson, Randal S.; Moore, Jason H. (2018). "Relief-Based Feature Selection: Introduction and Review". Journal of Biomedical Informatics. 85: 189â203. arXiv:1711.08421. doi:10.1016/j.jbi.2018.07.014. PMCÂ 6299836. PMIDÂ 30031057.

^ Forman, George (2003). "An extensive empirical study of feature selection metrics for text classification" (PDF). Journal of Machine Learning Research. 3: 1289â1305.

^ Yishi Zhang; Shujuan Li; Teng Wang; Zigang Zhang (2013). "Divergence-based feature selection for separate classes". Neurocomputing. 101 (4): 32â42. doi:10.1016/j.neucom.2012.06.036.

^ Guyon I.; Weston J.; Barnhill S.; Vapnik V. (2002). "Gene selection for cancer classification using support vector machines". Machine Learning. 46 (1â3): 389â422. doi:10.1023/A:1012487302797.

^ Bach, Francis R (2008). Bolasso: model consistent lasso estimation through the bootstrap. Proceedings of the 25th International Conference on Machine Learning. pp.Â 33â40. doi:10.1145/1390156.1390161. ISBNÂ 9781605582054. S2CIDÂ 609778.

^ Zare, Habil (2013). "Scoring relevancy of features based on combinatorial analysis of Lasso with application to lymphoma diagnosis". BMC Genomics. 14: S14. doi:10.1186/1471-2164-14-S1-S14. PMCÂ 3549810. PMIDÂ 23369194.

^ Kai Han; Yunhe Wang; Chao Zhang; Chao Li; Chao Xu (2018). Autoencoder inspired unsupervised feature selection. IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP).

^ Hazimeh, Hussein; Mazumder, Rahul; Saab, Ali (2020). "Sparse Regression at Scale: Branch-and-Bound rooted in First-Order Optimization". arXiv:2004.06152 [stat.CO].

^ Soufan, Othman; Kleftogiannis, Dimitrios; Kalnis, Panos; Bajic, Vladimir B. (2015-02-26). "DWFS: A Wrapper Feature Selection Tool Based on a Parallel Genetic Algorithm". PLOS ONE. 10 (2): e0117988. Bibcode:2015PLoSO..1017988S. doi:10.1371/journal.pone.0117988. ISSNÂ 1932-6203. PMCÂ 4342225. PMIDÂ 25719748.

^ Figueroa, Alejandro (2015). "Exploring effective features for recognizing the user intent behind web queries". Computers in Industry. 68: 162â169. doi:10.1016/j.compind.2015.01.005.

^ Figueroa, Alejandro; Guenter Neumann (2013). Learning to Rank Effective Paraphrases from Query Logs for Community Question Answering. AAAI.

^ Figueroa, Alejandro; Guenter Neumann (2014). "Category-specific models for ranking effective paraphrases in community Question Answering". Expert Systems with Applications. 41 (10): 4730â4742. doi:10.1016/j.eswa.2014.02.004. hdl:10533/196878.

^ Jump up to: a b Zhang, Y.; Wang, S.; Phillips, P. (2014). "Binary PSO with Mutation Operator for Feature Selection using Decision Tree applied to Spam Detection". Knowledge-Based Systems. 64: 22â31. doi:10.1016/j.knosys.2014.03.015.

^ F.C. Garcia-Lopez, M. Garcia-Torres, B. Melian, J.A. Moreno-Perez, J.M. Moreno-Vega. Solving feature subset selection problem by a Parallel Scatter Search, European Journal of Operational Research, vol. 169, no. 2, pp. 477â489, 2006.

^ GarcÃ­a-Torres, Miguel; GÃ³mez-Vela, Francisco; Divina, Federico; Pinto-Roa, Diego P.; Noguera, JosÃ© Luis VÃ¡zquez; RomÃ¡n, Julio C. Mello (2021). "Scatter search for high-dimensional feature selection using feature grouping". Proceedings of the Genetic and Evolutionary Computation Conference Companion. pp.Â 149â150. doi:10.1145/3449726.3459481. ISBNÂ 9781450383516. S2CIDÂ 235770316.

^ F.C. Garcia-Lopez, M. Garcia-Torres, B. Melian, J.A. Moreno-Perez, J.M. Moreno-Vega. Solving Feature Subset Selection Problem by a Hybrid Metaheuristic. In First International Workshop on Hybrid Metaheuristics, pp. 59â68, 2004.

^ M. Garcia-Torres, F. Gomez-Vela, B. Melian, J.M. Moreno-Vega. High-dimensional feature selection via feature grouping: A Variable Neighborhood Search approach, Information Sciences, vol. 326, pp. 102-118, 2016.

^ Kraskov, Alexander; StÃ¶gbauer, Harald; Andrzejak, Ralph G; Grassberger, Peter (2003). "Hierarchical Clustering Based on Mutual Information". arXiv:q-bio/0311039. Bibcode:2003q.bio....11039K. {{cite journal}}: Cite journal requires |journal= (help)

^ Akaike, H. (1985), "Prediction and entropy",  in Atkinson, A. C.; Fienberg, S. E. (eds.), A Celebration of Statistics (PDF), Springer, pp.Â 1â24.

^ Burnham, K. P.; Anderson, D. R. (2002), Model Selection and Multimodel Inference: A practical information-theoretic approach (2ndÂ ed.), Springer-Verlag, ISBNÂ 9780387953649.

^ Einicke, G. A. (2018). "Maximum-Entropy Rate Selection of Features for Classifying Changes in Knee and Ankle Dynamics During Running". IEEE Journal of Biomedical and Health Informatics. 28 (4): 1097â1103. doi:10.1109/JBHI.2017.2711487. PMIDÂ 29969403. S2CIDÂ 49555941.

^ Aliferis, Constantin (2010). "Local causal and markov blanket induction for causal discovery and feature selection for classification part I: Algorithms and empirical evaluation" (PDF). Journal of Machine Learning Research. 11: 171â234.

^ Jump up to: a b c d Brown, Gavin; Pocock, Adam; Zhao, Ming-Jie; LujÃ¡n, Mikel (2012). "Conditional Likelihood Maximisation: A Unifying Framework for Information Theoretic Feature Selection". Journal of Machine Learning Research. 13: 27â66.[1]

^ Peng, H. C.; Long, F.; Ding, C. (2005). "Feature selection based on mutual information: criteria of max-dependency, max-relevance, and min-redundancy". IEEE Transactions on Pattern Analysis and Machine Intelligence. 27 (8): 1226â1238. CiteSeerXÂ 10.1.1.63.5765. doi:10.1109/TPAMI.2005.159. PMIDÂ 16119262. S2CIDÂ 206764015. Program

^ Nguyen, H., Franke, K., Petrovic, S. (2010). "Towards a Generic Feature-Selection Measure for Intrusion Detection", In Proc. International Conference on Pattern Recognition (ICPR), Istanbul, Turkey. [2]

^ Rodriguez-Lujan, I.; Huerta, R.; Elkan, C.; Santa Cruz, C. (2010). "Quadratic programming feature selection" (PDF). JMLR. 11: 1491â1516.

^ Jump up to: a b Nguyen X. Vinh, Jeffrey Chan, Simone Romano and James Bailey, "Effective Global Approaches for Mutual Information based Feature Selection". Proceedings of the 20th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD'14), August 24â27, New York City, 2014. "[3]"

^ Yang, Howard Hua; Moody, John (2000). "Data visualization and feature selection: New algorithms for nongaussian data" (PDF). Advances in Neural Information Processing Systems: 687â693.

^ Yamada, M.; Jitkrittum, W.; Sigal, L.; Xing, E. P.; Sugiyama, M. (2014). "High-Dimensional Feature Selection by Feature-Wise Non-Linear Lasso". Neural Computation. 26 (1): 185â207. arXiv:1202.0515. doi:10.1162/NECO_a_00537. PMIDÂ 24102126. S2CIDÂ 2742785.

^ Hall, M. (1999). Correlation-based Feature Selection for Machine Learning (PDF) (PhD thesis). University of Waikato.

^ Senliol, Baris;  etÂ al. (2008). "Fast Correlation Based Filter (FCBF) with a different search strategy". 2008 23rd International Symposium on Computer and Information Sciences: 1â4. doi:10.1109/ISCIS.2008.4717949. ISBNÂ 978-1-4244-2880-9. S2CIDÂ 8398495.

^ Nguyen, Hai; Franke, Katrin; Petrovic, Slobodan (December 2009). "Optimizing a class of feature selection measures". Proceedings of the NIPS 2009 Workshop on Discrete Optimization in Machine Learning: Submodularity, Sparsity & Polyhedra (DISCML). Vancouver, Canada.

^ Jump up to: a b H. Deng, G. Runger, "Feature Selection via Regularized Trees", Proceedings of the 2012 International Joint Conference on Neural Networks (IJCNN), IEEE, 2012

^ Jump up to: a b RRF: Regularized Random Forest, R package on CRAN

^ Jump up to: a b Hamon, Julie (November 2013). Optimisation combinatoire pour la sÃ©lection de variables en rÃ©gression en grande dimensionÂ : Application en gÃ©nÃ©tique animale (Thesis) (in French). Lille University of Science and Technology.

^ Yu, Lei; Liu, Huan (August 2003). "Feature selection for high-dimensional data: a fast correlation-based filter solution" (PDF). ICML'03: Proceedings of the Twentieth International Conference on International Conference on Machine Learning: 856â863.

^ Jump up to: a b T. M. Phuong, Z. Lin et R. B. Altman. Choosing SNPs using feature selection. Archived 2016-09-13 at the Wayback Machine Proceedings / IEEE Computational Systems Bioinformatics Conference, CSB. IEEE Computational Systems Bioinformatics Conference, pages 301-309, 2005. PMIDÂ 16447987.

^ Saghapour, E.; Kermani, S.; Sehhati, M. (2017). "A novel feature ranking method for prediction of cancer stages using proteomics data". PLOS ONE. 12 (9): e0184203. Bibcode:2017PLoSO..1284203S. doi:10.1371/journal.pone.0184203. PMCÂ 5608217. PMIDÂ 28934234.

^ Shah, S. C.; Kusiak, A. (2004). "Data mining and genetic algorithm based gene/SNP selection". Artificial Intelligence in Medicine. 31 (3): 183â196. doi:10.1016/j.artmed.2004.04.002. PMIDÂ 15302085.

^ Long, N.; Gianola, D.; Weigel, K. A (2011). "Dimension reduction and variable selection for genomic selectionÂ : application to predicting milk yield in Holsteins". Journal of Animal Breeding and Genetics. 128 (4): 247â257. doi:10.1111/j.1439-0388.2011.00917.x. PMIDÂ 21749471.

^ ÃstÃ¼nkar, GÃ¼rkan; ÃzÃ¶ÄÃ¼r-AkyÃ¼z, SÃ¼reyya; Weber, Gerhard W.; Friedrich, Christoph M.; AydÄ±n Son, YeÅim (2012). "Selection of representative SNP sets for genome-wide association studies: A metaheuristic approach". Optimization Letters. 6 (6): 1207â1218. doi:10.1007/s11590-011-0419-7. S2CIDÂ 8075318.

^ Meiri, R.; Zahavi, J. (2006). "Using simulated annealing to optimize the feature selection problem in marketing applications". European Journal of Operational Research. 171 (3): 842â858. doi:10.1016/j.ejor.2004.09.010.

^ Kapetanios, G. (2007). "Variable Selection in Regression Models using Nonstandard Optimisation of Information Criteria". Computational Statistics & Data Analysis. 52 (1): 4â15. doi:10.1016/j.csda.2007.04.006.

^ Broadhurst, D.; Goodacre, R.; Jones, A.; Rowland, J. J.; Kell, D. B. (1997). "Genetic algorithms as a method for variable selection in multiple linear regression and partial least squares regression, with applications to pyrolysis mass spectrometry". Analytica Chimica Acta. 348 (1â3): 71â86. doi:10.1016/S0003-2670(97)00065-2.

^ Chuang, L.-Y.; Yang, C.-H. (2009). "Tabu search and binary particle swarm optimization for feature selection using microarray data". Journal of Computational Biology. 16 (12): 1689â1703. doi:10.1089/cmb.2007.0211. PMIDÂ 20047491.

^ E. Alba, J. Garia-Nieto, L. Jourdan et E.-G. Talbi. Gene Selection in Cancer Classification using PSO-SVM and GA-SVM Hybrid Algorithms. Congress on Evolutionary Computation, SingaporÂ : Singapore (2007), 2007

^ B. Duval, J.-K. Hao et J. C. Hernandez Hernandez. A memetic algorithm for gene selection and molecular classification of an cancer. In Proceedings of the 11th Annual conference on Genetic and evolutionary computation, GECCO '09, pages 201-208, New York, NY, USA, 2009. ACM.

^ C. Hans, A. Dobra et M. West. Shotgun stochastic search for 'large p' regression. Journal of the American Statistical Association, 2007.

^ Aitken, S. (2005). "Feature selection and classification for microarray data analysisÂ : Evolutionary methods for identifying predictive genes". BMC Bioinformatics. 6 (1): 148. doi:10.1186/1471-2105-6-148. PMCÂ 1181625. PMIDÂ 15958165.

^ Oh, I. S.; Moon, B. R. (2004). "Hybrid genetic algorithms for feature selection". IEEE Transactions on Pattern Analysis and Machine Intelligence. 26 (11): 1424â1437. CiteSeerXÂ 10.1.1.467.4179. doi:10.1109/tpami.2004.105. PMIDÂ 15521491.

^ Xuan, P.; Guo, M. Z.; Wang, J.; Liu, X. Y.; Liu, Y. (2011). "Genetic algorithm-based efficient feature selection for classification of pre-miRNAs". Genetics and Molecular Research. 10 (2): 588â603. doi:10.4238/vol10-2gmr969. PMIDÂ 21491369.

^ Peng, S. (2003). "Molecular classification of cancer types from microarray data using the combination of genetic algorithms and support vector machines". FEBS Letters. 555 (2): 358â362. doi:10.1016/s0014-5793(03)01275-4. PMIDÂ 14644442.

^ Hernandez, J. C. H.; Duval, B.; Hao, J.-K. (2007). "A Genetic Embedded Approach for Gene Selection and Classification of Microarray Data". Evolutionary Computation,Machine Learning and Data Mining in Bioinformatics. EvoBIO 2007. Lecture Notes in Computer Science. Vol.Â 4447. Berlin: Springer Verlag. pp.Â 90â101. doi:10.1007/978-3-540-71783-6_9. ISBNÂ 978-3-540-71782-9.

^ Huerta, E. B.; Duval, B.; Hao, J.-K. (2006). "A Hybrid GA/SVM Approach for Gene Selection and Classification of Microarray Data". Applications of Evolutionary Computing. EvoWorkshops 2006. Lecture Notes in Computer Science. Vol.Â 3907. pp.Â 34â44. doi:10.1007/11732242_4. ISBNÂ 978-3-540-33237-4.

^ Muni, D. P.; Pal, N. R.; Das, J. (2006). "Genetic programming for simultaneous feature selection and classifier design". IEEE Transactions on Systems, Man, and Cybernetics - Part B: CyberneticsÂ : Cybernetics. 36 (1): 106â117. doi:10.1109/TSMCB.2005.854499. PMIDÂ 16468570. S2CIDÂ 2073035.

^ Jourdan, L.; Dhaenens, C.; Talbi, E.-G. (2005). "Linkage disequilibrium study with a parallel adaptive GA". International Journal of Foundations of Computer Science. 16 (2): 241â260. doi:10.1142/S0129054105002978.

^ Zhang, Y.; Dong, Z.; Phillips, P.; Wang, S. (2015). "Detection of subjects and brain regions related to Alzheimer's disease using 3D MRI scans based on eigenbrain and machine learning". Frontiers in Computational Neuroscience. 9: 66. doi:10.3389/fncom.2015.00066. PMCÂ 4451357. PMIDÂ 26082713.

^ Roffo, G.; Melzi, S.; Cristani, M. (2015-12-01). Infinite Feature Selection. 2015 IEEE International Conference on Computer Vision (ICCV). pp.Â 4202â4210. doi:10.1109/ICCV.2015.478. ISBNÂ 978-1-4673-8391-2. S2CIDÂ 3223980.

^ Roffo, Giorgio; Melzi, Simone (September 2016). "Features Selection via Eigenvector Centrality" (PDF). NFmcp2016. Retrieved 12 November 2016.

^ R. Kohavi and G. John, "Wrappers for feature subset selection", Artificial intelligence 97.1-2 (1997): 273-324

^ Das, Abhimanyu; Kempe, David (2011). "Submodular meets Spectral: Greedy Algorithms for Subset Selection, Sparse Approximation and Dictionary Selection". arXiv:1102.3975 [stat.ML].

^ Liu et al., Submodular feature selection for high-dimensional acoustic score spaces Archived 2015-10-17 at the Wayback Machine

^ Zheng et al., Submodular Attribute Selection for Action Recognition in Video Archived 2015-11-18 at the Wayback Machine

^ Sun, Y.; Todorovic, S.; Goodison, S. (2010). "[https://ieeexplore.ieee.org/abstract/document/5342431/ Local-Learning-Based Feature Selection for High-Dimensional Data Analysis]". IEEE Transactions on Pattern Analysis and Machine Intelligence. 32 (9): 1610â1626. doi:10.1109/tpami.2009.190. PMCÂ 3445441. PMIDÂ 20634556. {{cite journal}}: External link in |title= (help)

^ D.H. Wang, Y.C. Liang, D.Xu, X.Y. Feng, R.C. Guan(2018), "A content-based recommender system for computer science publications", Knowledge-Based Systems, 157: 1-9


Further reading[edit]
Guyon, Isabelle; Elisseeff, Andre (2003). "An Introduction to Variable and Feature Selection". Journal of Machine Learning Research. 3: 1157â1182.
Harrell, F. (2001). Regression Modeling Strategies. Springer. ISBNÂ 0-387-95232-2.
Liu, Huan; Motoda, Hiroshi (1998). Feature Selection for Knowledge Discovery and Data Mining. Springer. ISBNÂ 0-7923-8198-X.
Liu, Huan; Yu, Lei (2005). "Toward Integrating Feature Selection Algorithms for Classification and Clustering". IEEE Transactions on Knowledge and Data Engineering. 17 (4): 491â502. doi:10.1109/TKDE.2005.66. S2CIDÂ 1607600.
External links[edit]
Feature Selection Package, Arizona State University (Matlab Code)
NIPS challenge 2003 (see also NIPS)
Naive Bayes implementation with feature selection in Visual Basic (includes executable and source code)
Minimum-redundancy-maximum-relevance (mRMR) feature selection program
FEAST (Open source Feature Selection algorithms in C and MATLAB)




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Feature_selection&oldid=1068725507"
		Categories: Model selectionDimension reductionHidden categories: CS1 errors: missing periodicalCS1 French-language sources (fr)Webarchive template wayback linksCS1 errors: external linksArticles with short descriptionShort description matches WikidataArticles lacking in-text citations from July 2010All articles lacking in-text citationsAll articles with unsourced statementsArticles with unsourced statements from March 2016
	
