
Title:
Context-free language
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		In formal language theory, a  context-free language (CFL) is a language generated by a context-free grammar (CFG).
Context-free languages have many applications in programming languages, in particular, most arithmetic expressions are generated by context-free grammars.

Contents

1 Background

1.1 Context-free grammar
1.2 Automata


2 Examples

2.1 Dyck language


3 Properties

3.1 Context-free parsing
3.2 Closure

3.2.1 Nonclosure under intersection, complement, and difference


3.3 Decidability
3.4 Languages that are not context-free


4 Notes
5 References

5.1 Works cited


6 Further reading



Background[edit]
Context-free grammar[edit]
Different context-free grammars can generate the same context-free language. Intrinsic properties of the language can be distinguished from extrinsic properties of a particular grammar by comparing multiple grammars that describe the language.

Automata[edit]
The set of all context-free languages is identical to the set of languages accepted by pushdown automata, which makes these languages amenable to parsing. Further, for a given CFG, there is a direct way to produce a pushdown automaton for the grammar (and thereby the corresponding language), though going the other way (producing a grammar given an automaton) is not as direct.

Examples[edit]
An example context-free language is 
  
    
      
        L
        =
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        :
        n
        â¥
        1
        }
      
    
    {\displaystyle L=\{a^{n}b^{n}:n\geq 1\}}
  
, the language of all non-empty even-length strings, the entire first halves of which are a's, and the entire second halves of which are b's. L is generated by the grammar 
  
    
      
        S
        â
        a
        S
        b
        Â 
        
          |
        
        Â 
        a
        b
      
    
    {\displaystyle S\to aSb~|~ab}
  
.
This language is not regular.
It is accepted by the pushdown automaton 
  
    
      
        M
        =
        (
        {
        
          q
          
            0
          
        
        ,
        
          q
          
            1
          
        
        ,
        
          q
          
            f
          
        
        }
        ,
        {
        a
        ,
        b
        }
        ,
        {
        a
        ,
        z
        }
        ,
        Î´
        ,
        
          q
          
            0
          
        
        ,
        z
        ,
        {
        
          q
          
            f
          
        
        }
        )
      
    
    {\displaystyle M=(\{q_{0},q_{1},q_{f}\},\{a,b\},\{a,z\},\delta ,q_{0},z,\{q_{f}\})}
  
 where 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 is defined as follows:[note 1]


  
    
      
        
          
            
              
                Î´
                (
                
                  q
                  
                    0
                  
                
                ,
                a
                ,
                z
                )
              
              
                
                =
                (
                
                  q
                  
                    0
                  
                
                ,
                a
                z
                )
              
            
            
              
                Î´
                (
                
                  q
                  
                    0
                  
                
                ,
                a
                ,
                a
                )
              
              
                
                =
                (
                
                  q
                  
                    0
                  
                
                ,
                a
                a
                )
              
            
            
              
                Î´
                (
                
                  q
                  
                    0
                  
                
                ,
                b
                ,
                a
                )
              
              
                
                =
                (
                
                  q
                  
                    1
                  
                
                ,
                Îµ
                )
              
            
            
              
                Î´
                (
                
                  q
                  
                    1
                  
                
                ,
                b
                ,
                a
                )
              
              
                
                =
                (
                
                  q
                  
                    1
                  
                
                ,
                Îµ
                )
              
            
            
              
                Î´
                (
                
                  q
                  
                    1
                  
                
                ,
                Îµ
                ,
                z
                )
              
              
                
                =
                (
                
                  q
                  
                    f
                  
                
                ,
                Îµ
                )
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}\delta (q_{0},a,z)&=(q_{0},az)\\\delta (q_{0},a,a)&=(q_{0},aa)\\\delta (q_{0},b,a)&=(q_{1},\varepsilon )\\\delta (q_{1},b,a)&=(q_{1},\varepsilon )\\\delta (q_{1},\varepsilon ,z)&=(q_{f},\varepsilon )\end{aligned}}}
  

Unambiguous CFLs are a proper subset of all CFLs: there are inherently ambiguous CFLs. An example of an inherently ambiguous CFL is the union of 
  
    
      
        {
        
          a
          
            n
          
        
        
          b
          
            m
          
        
        
          c
          
            m
          
        
        
          d
          
            n
          
        
        
          |
        
        n
        ,
        m
        >
        0
        }
      
    
    {\displaystyle \{a^{n}b^{m}c^{m}d^{n}|n,m>0\}}
  
 with 
  
    
      
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        
          c
          
            m
          
        
        
          d
          
            m
          
        
        
          |
        
        n
        ,
        m
        >
        0
        }
      
    
    {\displaystyle \{a^{n}b^{n}c^{m}d^{m}|n,m>0\}}
  
. This set is context-free, since the union of two context-free languages is always context-free. But there is no way to unambiguously parse strings in the (non-context-free) subset 
  
    
      
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        
          c
          
            n
          
        
        
          d
          
            n
          
        
        
          |
        
        n
        >
        0
        }
      
    
    {\displaystyle \{a^{n}b^{n}c^{n}d^{n}|n>0\}}
  
 which is the intersection of these two languages.[1]

Dyck language[edit]
The language of all properly matched parentheses is generated by the grammar 
  
    
      
        S
        â
        S
        S
        Â 
        
          |
        
        Â 
        (
        S
        )
        Â 
        
          |
        
        Â 
        Îµ
      
    
    {\displaystyle S\to SS~|~(S)~|~\varepsilon }
  
.

Properties[edit]
Context-free parsing[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Parsing
The context-free nature of the language makes it simple to parse with a pushdown automaton.
Determining an instance of the membership problem; i.e. given a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
, determine whether 
  
    
      
        w
        â
        L
        (
        G
        )
      
    
    {\displaystyle w\in L(G)}
  
 where 
  
    
      
        L
      
    
    {\displaystyle L}
  
 is the language generated by a given grammar 
  
    
      
        G
      
    
    {\displaystyle G}
  
; is also known as recognition. Context-free recognition for Chomsky normal form grammars was shown by Leslie G. Valiant to be reducible to boolean matrix multiplication, thus inheriting its complexity upper bound of O(n2.3728639).[2][note 2]
Conversely, Lillian Lee has shown O(n3âÎµ) boolean matrix multiplication to be reducible to O(n3â3Îµ) CFG parsing, thus establishing some kind of lower bound for the latter.[3]
Practical uses of context-free languages require also to produce a derivation tree that exhibits the  structure that the grammar associates with the given string. The process of producing this tree is called parsing. Known parsers have a time complexity that is cubic in the size of the string that is parsed.
Formally, the set of all context-free languages is identical to the set of languages accepted by pushdown automata (PDA). Parser algorithms for context-free languages include the CYK algorithm and Earley's Algorithm.
A special subclass of context-free languages are the deterministic context-free languages which are defined as the set of languages accepted by a deterministic pushdown automaton and can be parsed by a LR(k) parser.[4]
See also parsing expression grammar as an alternative approach to grammar and parser.

Closure[edit]
The class of context-free languages is closed under the following operations. That is, if L and P are context-free languages, the following languages are context-free as well:

the union 
  
    
      
        L
        âª
        P
      
    
    {\displaystyle L\cup P}
  
 of L and P[5]
the reversal of L[6]
the concatenation 
  
    
      
        L
        â
        P
      
    
    {\displaystyle L\cdot P}
  
 of L and P[5]
the Kleene star 
  
    
      
        
          L
          
            â
          
        
      
    
    {\displaystyle L^{*}}
  
 of L[5]
the image 
  
    
      
        Ï
        (
        L
        )
      
    
    {\displaystyle \varphi (L)}
  
 of L under a homomorphism 
  
    
      
        Ï
      
    
    {\displaystyle \varphi }
  
[7]
the image 
  
    
      
        
          Ï
          
            â
            1
          
        
        (
        L
        )
      
    
    {\displaystyle \varphi ^{-1}(L)}
  
 of L under an inverse homomorphism 
  
    
      
        
          Ï
          
            â
            1
          
        
      
    
    {\displaystyle \varphi ^{-1}}
  
[8]
the circular shift of L (the language 
  
    
      
        {
        v
        u
        :
        u
        v
        â
        L
        }
      
    
    {\displaystyle \{vu:uv\in L\}}
  
)[9]
the prefix closure of L (the set of all prefixes of strings from L)[10]
the quotient L/R of L by a regular language R[11]
Nonclosure under intersection, complement, and difference[edit]
The context-free languages are not closed under intersection.  This can be seen by taking the languages 
  
    
      
        A
        =
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        
          c
          
            m
          
        
        â£
        m
        ,
        n
        â¥
        0
        }
      
    
    {\displaystyle A=\{a^{n}b^{n}c^{m}\mid m,n\geq 0\}}
  
 and 
  
    
      
        B
        =
        {
        
          a
          
            m
          
        
        
          b
          
            n
          
        
        
          c
          
            n
          
        
        â£
        m
        ,
        n
        â¥
        0
        }
      
    
    {\displaystyle B=\{a^{m}b^{n}c^{n}\mid m,n\geq 0\}}
  
, which are both context-free.[note 3] Their intersection is 
  
    
      
        A
        â©
        B
        =
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        
          c
          
            n
          
        
        â£
        n
        â¥
        0
        }
      
    
    {\displaystyle A\cap B=\{a^{n}b^{n}c^{n}\mid n\geq 0\}}
  
, which can be shown to be non-context-free by the pumping lemma for context-free languages. As a consequence, context-free languages cannot be closed under complementation, as for any languages A and B, their intersection can be expressed by union and complement:  
  
    
      
        A
        â©
        B
        =
        
          
            
              
                
                  A
                  Â¯
                
              
              âª
              
                
                  B
                  Â¯
                
              
            
            Â¯
          
        
      
    
    {\displaystyle A\cap B={\overline {{\overline {A}}\cup {\overline {B}}}}}
  
. In particular, context-free language cannot be closed under difference, since complement can be expressed by difference: 
  
    
      
        
          
            L
            Â¯
          
        
        =
        
          Î£
          
            â
          
        
        â
        L
      
    
    {\displaystyle {\overline {L}}=\Sigma ^{*}\setminus L}
  
.[12]
However, if L is a context-free language and D is a regular language then both their intersection 
  
    
      
        L
        â©
        D
      
    
    {\displaystyle L\cap D}
  
 and their difference 
  
    
      
        L
        â
        D
      
    
    {\displaystyle L\setminus D}
  
 are context-free languages.[13]

Decidability[edit]
In formal language theory, questions about regular languages are usually decidable, but ones about context-free languages are often not. It is decidable whether such a language is finite, but not whether it contains every possible string, is regular, is unambiguous, or is equivalent to a language with a different grammar.
The following problems are undecidable for arbitrarily given context-free grammars A and B:

Equivalence: is 
  
    
      
        L
        (
        A
        )
        =
        L
        (
        B
        )
      
    
    {\displaystyle L(A)=L(B)}
  
?[14]
Disjointness: is 
  
    
      
        L
        (
        A
        )
        â©
        L
        (
        B
        )
        =
        â
      
    
    {\displaystyle L(A)\cap L(B)=\emptyset }
  
Â ?[15] However, the intersection of a context-free language and a regular language is context-free,[16][17] hence the variant of the problem where B is a regular grammar is decidable (see "Emptiness" below).
Containment: is 
  
    
      
        L
        (
        A
        )
        â
        L
        (
        B
        )
      
    
    {\displaystyle L(A)\subseteq L(B)}
  
Â ?[18] Again, the variant of the problem where B is a regular grammar is decidable,[citation needed] while that where A is regular is generally not.[19]
Universality: is 
  
    
      
        L
        (
        A
        )
        =
        
          Î£
          
            â
          
        
      
    
    {\displaystyle L(A)=\Sigma ^{*}}
  
?[20]
Regularity: is 
  
    
      
        L
        (
        A
        )
      
    
    {\displaystyle L(A)}
  
 a regular language?[21]
Ambiguity: is every grammar for 
  
    
      
        L
        (
        A
        )
      
    
    {\displaystyle L(A)}
  
 ambiguous?[22]
The following problems are decidable for arbitrary context-free languages:

Emptiness: Given a context-free grammar A, is 
  
    
      
        L
        (
        A
        )
        =
        â
      
    
    {\displaystyle L(A)=\emptyset }
  
Â ?[23]
Finiteness: Given a context-free grammar A, is 
  
    
      
        L
        (
        A
        )
      
    
    {\displaystyle L(A)}
  
 finite?[24]
Membership: Given a context-free grammar G, and  a word 
  
    
      
        w
      
    
    {\displaystyle w}
  
, does 
  
    
      
        w
        â
        L
        (
        G
        )
      
    
    {\displaystyle w\in L(G)}
  
Â ? Efficient polynomial-time algorithms for the membership problem are the CYK algorithm and Earley's Algorithm.
According to Hopcroft, Motwani, Ullman (2003),[25] 
many of the fundamental closure and (un)decidability properties of context-free languages were shown in the 1961 paper of Bar-Hillel, Perles, and Shamir[26]

Languages that are not context-free[edit]
The set 
  
    
      
        {
        
          a
          
            n
          
        
        
          b
          
            n
          
        
        
          c
          
            n
          
        
        
          d
          
            n
          
        
        
          |
        
        n
        >
        0
        }
      
    
    {\displaystyle \{a^{n}b^{n}c^{n}d^{n}|n>0\}}
  
 is a context-sensitive language, but there does not exist a context-free grammar generating this language.[27] So there exist context-sensitive languages which are not context-free. To prove that a given language is not context-free, one may employ the pumping lemma for context-free languages[26] or a number of other methods, such as Ogden's lemma or Parikh's theorem.[28]

Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ meaning of 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
's arguments and results: 
  
    
      
        Î´
        (
        
          
            s
            t
            a
            t
            e
          
          
            1
          
        
        ,
        
          r
          e
          a
          d
        
        ,
        
          p
          o
          p
        
        )
        =
        (
        
          
            s
            t
            a
            t
            e
          
          
            2
          
        
        ,
        
          p
          u
          s
          h
        
        )
      
    
    {\displaystyle \delta (\mathrm {state} _{1},\mathrm {read} ,\mathrm {pop} )=(\mathrm {state} _{2},\mathrm {push} )}
  


^ In Valiant's paper, O(n2.81) was the then-best known upper bound. See Matrix multiplication#Computational complexity for bound improvements since then.

^ A context-free grammar for the language A is given by the following production rules, taking S as the start symbol: S â Sc | aTb | Îµ; T â aTb | Îµ. The grammar for B is analogous.


References[edit]


^ Hopcroft & Ullman 1979, p.Â 100, Theorem 4.7.

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Valiant, Leslie G. (April 1975). "General context-free recognition in less than cubic time". Journal of Computer and System Sciences. 10 (2): 308â315. doi:10.1016/s0022-0000(75)80046-8.

^ Lee, Lillian (January 2002). "Fast Context-Free Grammar Parsing Requires Fast Boolean Matrix Multiplication" (PDF). J ACM. 49 (1): 1â15. arXiv:cs/0112018. doi:10.1145/505241.505242. S2CIDÂ 1243491.

^ Knuth, D. E. (July 1965). "On the translation of languages from left to right". Information and Control. 8 (6): 607â639. doi:10.1016/S0019-9958(65)90426-2.

^ Jump up to: a b c Hopcroft & Ullman 1979, p.Â 131, Corollary of Theorem 6.1.

^ Hopcroft & Ullman 1979, p.Â 142, Exercise 6.4d.

^ Hopcroft & Ullman 1979, p.Â 131-132, Corollary of Theorem 6.2.

^ Hopcroft & Ullman 1979, p.Â 132, Theorem 6.3.

^ Hopcroft & Ullman 1979, p.Â 142-144, Exercise 6.4c.

^ Hopcroft & Ullman 1979, p.Â 142, Exercise 6.4b.

^ Hopcroft & Ullman 1979, p.Â 142, Exercise 6.4a.

^ Stephen Scheinberg (1960). "Note on the Boolean Properties of Context Free Languages" (PDF). Information and Control. 3 (4): 372â375. doi:10.1016/s0019-9958(60)90965-7.

^ Beigel, Richard; Gasarch, William. "A Proof that if L = L1 â© L2 where L1 is CFL and L2 is Regular then L is Context Free Which Does Not use PDA's" (PDF). University of Maryland Department of Computer Science. Retrieved June 6, 2020.

^ Hopcroft & Ullman 1979, p.Â 203, Theorem 8.12(1).

^ Hopcroft & Ullman 1979, p.Â 202, Theorem 8.10.

^ Salomaa (1973), p. 59, Theorem 6.7

^ Hopcroft & Ullman 1979, p.Â 135, Theorem 6.5.

^ Hopcroft & Ullman 1979, p.Â 203, Theorem 8.12(2).

^ Hopcroft & Ullman 1979, p.Â 203, Theorem 8.12(4).

^ Hopcroft & Ullman 1979, p.Â 203, Theorem 8.11.

^ Hopcroft & Ullman 1979, p.Â 205, Theorem 8.15.

^ Hopcroft & Ullman 1979, p.Â 206, Theorem 8.16.

^ Hopcroft & Ullman 1979, p.Â 137, Theorem 6.6(a).

^ Hopcroft & Ullman 1979, p.Â 137, Theorem 6.6(b).

^ John E. Hopcroft; Rajeev Motwani; Jeffrey D. Ullman (2003). Introduction to Automata Theory, Languages, and Computation. Addison Wesley. Here: Sect.7.6, p.304, and Sect.9.7, p.411

^ Jump up to: a b Yehoshua Bar-Hillel; Micha Asher Perles; Eli Shamir (1961). "On Formal Properties of Simple Phrase-Structure Grammars". Zeitschrift fÃ¼r Phonetik, Sprachwissenschaft und Kommunikationsforschung. 14 (2): 143â172.

^ Hopcroft & Ullman 1979.

^ "How to prove that a language is not context-free?".


Works cited[edit]
.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li{margin-left:0;padding-left:3.2em;text-indent:-3.2em}.mw-parser-output .refbegin-hanging-indents ul,.mw-parser-output .refbegin-hanging-indents ul li{list-style:none}@media(max-width:720px){.mw-parser-output .refbegin-hanging-indents>ul>li{padding-left:1.6em;text-indent:-1.6em}}.mw-parser-output .refbegin-columns{margin-top:0.3em}.mw-parser-output .refbegin-columns ul{margin-top:0}.mw-parser-output .refbegin-columns li{page-break-inside:avoid;break-inside:avoid-column}
Hopcroft, John E.; Ullman, Jeffrey D. (1979). Introduction to Automata Theory, Languages, and Computation (1stÂ ed.). Addison-Wesley. ISBNÂ 9780201029888.
Salomaa, Arto (1973). Formal Languages. ACM Monograph Series.

Further reading[edit]
Autebert, Jean-Michel; Berstel, Jean; Boasson, Luc (1997). "Context-Free Languages and Push-Down Automata".  In G. Rozenberg; A. Salomaa (eds.). Handbook of Formal Languages (PDF). Vol.Â 1. Springer-Verlag. pp.Â 111â174.
Ginsburg, Seymour (1966). The Mathematical Theory of Context-Free Languages. New York, NY, USA: McGraw-Hill.
Sipser, Michael (1997). "2: Context-Free Languages". Introduction to the Theory of Computation. PWS Publishing. pp.Â 91â122. ISBNÂ 0-534-94728-X.
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hide.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteAutomata theory: formal languages and formal grammarsChomsky hierarchyGrammarsLanguagesAbstract machines
Type-0
â
Type-1
â
â
â
â
â
Type-2
â
â
Type-3
â
â

Unrestricted
(no common name)
Context-sensitive
Positive range concatenation
Indexed
â
Linear context-free rewriting systems
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
â
Non-recursive

Recursively enumerable
Decidable
Context-sensitive
Positive range concatenation*
Indexed*
â
Linear context-free rewriting language
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
Star-free
Finite

Turing machine
Decider
Linear-bounded
PTIME Turing Machine
Nested stack
Thread automaton
restricted Tree stack automaton
Embedded pushdown
Nondeterministic pushdown
Deterministic pushdown
Visibly pushdown
Finite
Counter-free (with aperiodic finite monoid)
Acyclic finite
Each category of languages, except those marked by a *, is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line.




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Context-free_language&oldid=1065546969"
		Categories: Formal languagesSyntaxHidden categories: All articles with unsourced statementsArticles with unsourced statements from December 2015
	
