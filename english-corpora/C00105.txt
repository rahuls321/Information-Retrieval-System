
Title:
Finite-state machine
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Mathematical model of computation
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}"State machine" redirects here. For infinite-state machines, see Transition system. For Fault-tolerance methodology, see State machine replication.
"SFSM" redirects here. For the Italian railway company, see Circumvesuviana.
"Finite automata" redirects here. For the electro-industrial group, see Finite Automata (band).



Classes of automata (Clicking on each layer gets an article on that subject)
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.[1] An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition. Finite-state machines are of two typesâdeterministic finite-state machines and non-deterministic finite-state machines.[2] A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.
The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Simple examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of a sequence of numbers in the proper order.
The finite-state machine has less computational power than some other models of computation such as the Turing machine.[3] The computational power distinction means there are computational tasks that a Turing machine can do but an FSM cannot. This is because an FSM's memory is limited by the number of states it has. A finite-state machine has the same computational power as a Turing machine that is restricted such that its head may only perform "read" operations, and always has to move from left to right. FSMs are studied in the more general field of automata theory.

Contents

1 Example: coin-operated turnstile
2 Concepts and terminology
3 Representations

3.1 State/Event table
3.2 UML state machines
3.3 SDL state machines
3.4 Other state diagrams


4 Usage
5 Classification

5.1 Acceptors
5.2 Classifiers
5.3 Transducers
5.4 Sequencers
5.5 Determinism


6 Alternative semantics
7 Mathematical model
8 Optimization
9 Implementation

9.1 Hardware applications
9.2 Software applications
9.3 Finite-state machines and compilers


10 See also
11 References
12 Further reading

12.1 General
12.2 Finite-state machines (automata theory) in theoretical computer science
12.3 Abstract state machines in theoretical computer science
12.4 Machine learning using finite-state algorithms
12.5 Hardware engineering: state minimization and synthesis of sequential circuits
12.6 Finite Markov chain processes


13 External links



Example: coin-operated turnstile[edit]
  State diagram for a turnstile
  A turnstile
An example of a simple mechanism that can be modeled by a state machine is a turnstile.[4][5] A turnstile, used to control access to subways and amusement park rides, is a gate with three rotating arms at waist height, one across the entryway. Initially the arms are locked, blocking the entry, preventing patrons from passing through. Depositing a coin or token in a slot on the turnstile unlocks the arms, allowing a single customer to push through. After the customer passes through, the arms are locked again until another coin is inserted.
Considered as a state machine, the turnstile has two possible states: Locked and Unlocked.[4] There are two possible inputs that affect its state: putting a coin in the slot (coin) and pushing the arm (push). In the locked state, pushing on the arm has no effect; no matter how many times the input push is given, it stays in the locked state. Putting a coin in â that is, giving the machine a coin input â shifts the state from Locked to Unlocked. In the unlocked state, putting additional coins in has no effect; that is, giving additional coin inputs does not change the state. However, a customer pushing through the arms, giving a push input, shifts the state back to Locked.
The turnstile state machine can be represented by a state-transition table, showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input:



Current State

Input

Next State

Output


Locked

coin
Unlocked
Unlocks the turnstile so that the customer can push through.


push
Locked
None


Unlocked

coin
Unlocked
None


push
Locked
When the customer has pushed through, locks the turnstile.

The turnstile state machine can also be represented by a directed graph called a state diagram (above). Each state is represented by a node (circle). Edges (arrows) show the transitions from one state to another. Each arrow is labeled with the input that triggers that transition. An input that doesn't cause a change of state (such as a coin input in the Unlocked state) is represented by a circular arrow returning to the original state. The arrow into the Locked node from the black dot indicates it is the initial state.

Concepts and terminology[edit]
A state is a description of the status of a system that is waiting to execute a transition. A transition is a set of actions to be executed when a condition is fulfilled or when an event is received.
For example, when using an audio system to listen to the radio (the system is in the "radio" state), receiving a "next" stimulus results in moving to the next station. When the system is in the "CD" state, the "next" stimulus results in moving to the next track. Identical stimuli trigger different actions depending on the current state.
In some finite-state machine representations, it is also possible to associate actions with a state:

an entry action: performed when entering the state, and
an exit action: performed when exiting the state.
Representations[edit]
  Fig. 1 UML state chart example (a toaster oven)
  Fig. 2 SDL state machine example
  Fig. 3 Example of a simple finite-state machine
For an introduction, see State diagram.
State/Event table[edit]
Several state-transition table types are used. The most common representation is shown below: the combination of current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes.[further explanation needed] An FSM definition including the full action's information is possible using state tables (see also virtual finite-state machine).


State-transition table


Â  CurrentstateInput
State A
State B
State C


Input X

...
...
...


Input Y

...
State C
...


Input Z

...
...
...

UML state machines[edit]
The Unified Modeling Language has a notation for describing state machines. UML state machines overcome the limitations[citation needed] of traditional finite-state machines while retaining their main benefits. UML state machines introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML state machines have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both the state of the system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.[citation needed]

SDL state machines[edit]
The Specification and Description Language is a standard from ITU that includes graphical symbols to describe actions in the transition:

send an event
receive an event
start a timer
cancel a timer
start another concurrent state machine
decision
SDL embeds basic data types called "Abstract Data Types", an action language, and an execution semantic in order to make the finite-state machine executable.[citation needed]

Other state diagrams[edit]
There are a large number of variants to represent an FSM such as the one in figure 3.

Usage[edit]
In addition to their use in modeling reactive systems presented here, finite-state machines are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, video game programming, and logic. Finite-state machines are a class of automata studied in automata theory and the theory of computation.
In computer science, finite-state machines are widely used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, and the study of computation and languages.

Classification[edit]
Finite-state machines can be subdivided into acceptors, classifiers, transducers and sequencers.[6]

Acceptors[edit]
  Fig. 4: Acceptor FSM: parsing the string "nice".
  Fig. 5: Representation of an acceptor; this example shows one that determines whether a binary number has an even number of 0s, where S1 is an accepting state and S2 is a non accepting state.
Acceptors (also called detectors or recognizers) produce binary output, indicating whether or not the received input is accepted. Each state of an acceptor is either accepting or non accepting. Once all input has been received, if the current state is an accepting state, the input is accepted; otherwise it is rejected. As a rule, input is a sequence of symbols (characters); actions are not used. The start state can also be an accepting state, in which case the acceptor accepts the empty string. The example in figure 4 shows an acceptor that accepts the string "nice". In this acceptor, the only accepting state is state 7.
A (possibly infinite) set of symbol sequences, called a formal language, is a regular language if there is some acceptor that accepts exactly that set. For example, the set of binary strings with an even number of zeroes is a regular language (cf. Fig. 5), while the set of all strings whose length is a prime number is not.[7]:â18,â71â
An acceptor could also be described as defining a language that would contain every string accepted by the acceptor but none of the rejected ones; that language is accepted by the acceptor. By definition, the languages accepted by acceptors are the regular languages.
The problem of determining the language accepted by a given acceptor is an instance of the algebraic path problemâitself a generalization of the shortest path problem to graphs with edges weighted by the elements of an (arbitrary) semiring.[8][9][jargon]
An example of an accepting state appears in Fig. 5: a deterministic finite automaton (DFA) that detects whether the binary input string contains an even number of 0s.
S1 (which is also the start state) indicates the state at which an even number of 0s has been input. S1 is therefore an accepting state. This acceptor will finish in an accept state, if the binary string contains an even number of 0s (including any binary string containing no 0s). Examples of strings accepted by this acceptor are Îµ (the empty string), 1, 11, 11..., 00, 010, 1010, 10110, etc.

Classifiers[edit]
Classifiers are a generalization of acceptors that produce n-ary output where n is strictly greater than two.[10]

Transducers[edit]
Main article: Finite-state transducer
  Fig. 6 Transducer FSM: Moore model example
  Fig. 7 Transducer FSM: Mealy model example
Transducers produce output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.
In control applications, two types are distinguished:

Moore machine
The FSM uses only entry actions, i.e., output depends only on state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: "command_open" and "command_close", which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: "door is open" or "door is closed".
Mealy machine
The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in figure 7 shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): "start motor to close the door if command_close arrives" and "start motor in the other direction to open the door if command_open arrives". The "opening" and "closing" intermediate states are not shown.
Sequencers[edit]
Sequencers (also called generators) are a subclass of acceptors and transducers that have a single-letter input alphabet. They produce only one sequence which can be seen as an output sequence of acceptor or transducer outputs.[6]

Determinism[edit]
A further distinction is between deterministic (DFA) and non-deterministic (NFA, GNFA) automata. In a deterministic automaton, every state has exactly one transition for each possible input. In a non-deterministic automaton, an input can lead to one, more than one, or no transition for a given state. The powerset construction algorithm can transform any nondeterministic automaton into a (usually more complex) deterministic automaton with identical functionality.
A finite-state machine with only one state is called a "combinatorial FSM". It only allows actions upon transition into a state. This concept is useful in cases where a number of finite-state machines are required to work together, and when it is convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.[11]

Alternative semantics[edit]
There are other sets of semantics available to represent state machines. For example, there are tools for modeling and designing logic for embedded controllers.[12] They combine hierarchical state machines (which usually have more than one current state), flow graphs, and truth tables into one language, resulting in a different formalism and set of semantics.[13]  These charts, like Harel's original state machines,[14] support hierarchically nested states, orthogonal regions, state actions, and transition actions.[15]

Mathematical model[edit]
In accordance with the general classification, the following formal definitions are found.
A deterministic finite-state machine or deterministic finite-state acceptor is a quintuple 
  
    
      
        (
        Î£
        ,
        S
        ,
        
          s
          
            0
          
        
        ,
        Î´
        ,
        F
        )
      
    
    {\displaystyle (\Sigma ,S,s_{0},\delta ,F)}
  
, where:


  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
 is the input alphabet (a finite non-empty set of symbols);

  
    
      
        S
      
    
    {\displaystyle S}
  
 is a finite non-empty set of states;

  
    
      
        
          s
          
            0
          
        
      
    
    {\displaystyle s_{0}}
  
 is an initial state, an element of 
  
    
      
        S
      
    
    {\displaystyle S}
  
;

  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 is the state-transition function: 
  
    
      
        Î´
        :
        S
        Ã
        Î£
        â
        S
      
    
    {\displaystyle \delta :S\times \Sigma \rightarrow S}
  
 (in a nondeterministic finite automaton it would be 
  
    
      
        Î´
        :
        S
        Ã
        Î£
        â
        
          
            P
          
        
        (
        S
        )
      
    
    {\displaystyle \delta :S\times \Sigma \rightarrow {\mathcal {P}}(S)}
  
, i.e. 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 would return a set of states);

  
    
      
        F
      
    
    {\displaystyle F}
  
 is the set of final states, a (possibly empty) subset of 
  
    
      
        S
      
    
    {\displaystyle S}
  
.
For both deterministic and non-deterministic FSMs, it is conventional to allow 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 to be a partial function, i.e. 
  
    
      
        Î´
        (
        s
        ,
        x
        )
      
    
    {\displaystyle \delta (s,x)}
  
 does not have to be defined for every combination of 
  
    
      
        s
        â
        S
      
    
    {\displaystyle s\in S}
  
 and 
  
    
      
        x
        â
        Î£
      
    
    {\displaystyle x\in \Sigma }
  
. If an FSM 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is in a state 
  
    
      
        s
      
    
    {\displaystyle s}
  
, the next symbol is 
  
    
      
        x
      
    
    {\displaystyle x}
  
 and 
  
    
      
        Î´
        (
        s
        ,
        x
        )
      
    
    {\displaystyle \delta (s,x)}
  
 is not defined, then 
  
    
      
        M
      
    
    {\displaystyle M}
  
 can announce an error (i.e. reject the input). This is useful in definitions of general state machines, but less useful when transforming the machine. Some algorithms in their default form may require total functions.
A finite-state machine has the same computational power as a Turing machine that is restricted such that its head may only perform "read" operations, and always has to move from left to right. That is, each formal language accepted by a finite-state machine is accepted by such a kind of restricted Turing machine, and vice versa.[16]
A finite-state transducer is a sextuple 
  
    
      
        (
        Î£
        ,
        Î
        ,
        S
        ,
        
          s
          
            0
          
        
        ,
        Î´
        ,
        Ï
        )
      
    
    {\displaystyle (\Sigma ,\Gamma ,S,s_{0},\delta ,\omega )}
  
, where:


  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
 is the input alphabet (a finite non-empty set of symbols);

  
    
      
        Î
      
    
    {\displaystyle \Gamma }
  
 is the output alphabet (a finite non-empty set of symbols);

  
    
      
        S
      
    
    {\displaystyle S}
  
 is a finite non-empty set of states;

  
    
      
        
          s
          
            0
          
        
      
    
    {\displaystyle s_{0}}
  
 is the initial state, an element of 
  
    
      
        S
      
    
    {\displaystyle S}
  
;

  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 is the state-transition function: 
  
    
      
        Î´
        :
        S
        Ã
        Î£
        â
        S
      
    
    {\displaystyle \delta :S\times \Sigma \rightarrow S}
  
;

  
    
      
        Ï
      
    
    {\displaystyle \omega }
  
 is the output function.
If the output function depends on the state and input symbol (
  
    
      
        Ï
        :
        S
        Ã
        Î£
        â
        Î
      
    
    {\displaystyle \omega :S\times \Sigma \rightarrow \Gamma }
  
) that definition corresponds to the Mealy model, and can be modelled as a Mealy machine. If the output function depends only on the state (
  
    
      
        Ï
        :
        S
        â
        Î
      
    
    {\displaystyle \omega :S\rightarrow \Gamma }
  
) that definition corresponds to the Moore model, and can be modelled as a Moore machine. A finite-state machine with no output function at all is known as a semiautomaton or transition system.
If we disregard the first output symbol of a Moore machine, 
  
    
      
        Ï
        (
        
          s
          
            0
          
        
        )
      
    
    {\displaystyle \omega (s_{0})}
  
, then it can be readily converted to an output-equivalent Mealy machine by setting the output function of every Mealy transition (i.e. labeling every edge) with the output symbol given of the destination Moore state. The converse transformation is less straightforward because a Mealy machine state may have different output labels on its incoming transitions (edges). Every such state needs to be split in multiple Moore machine states, one for every incident output symbol.[17]

Optimization[edit]
Main article: DFA minimization
Optimizing an FSM means finding a machine with the minimum number of states that performs the same function. The fastest known algorithm doing this is the Hopcroft minimization algorithm.[18][19] Other techniques include using an implication table, or the Moore reduction procedure.[20] Additionally, acyclic FSAs can be minimized in linear time.[21]

Implementation[edit]
Hardware applications[edit]
  Fig. 9 The circuit diagram for a 4-bit TTL counter, a type of state machine
In a digital circuit, an FSM may be built using a programmable logic device, a programmable logic controller, logic gates and flip flops or relays. More specifically, a hardware implementation requires a register to store state variables, a block of combinational logic that determines the state transition, and a second block of combinational logic that determines the output of an FSM. One of the classic hardware implementations is the Richards controller.
In a Medvedev machine, the output is directly connected to the state flip-flops minimizing the time delay between flip-flops and output.[22][23]
Through state encoding for low power state machines may be optimized to minimize power consumption.

Software applications[edit]
The following concepts are commonly used to build software applications with finite-state machines:

Automata-based programming
Event-driven finite-state machine
Virtual finite-state machine
State design pattern
Finite-state machines and compilers[edit]
Finite automata are often used in the frontend of programming language compilers. Such a frontend may comprise several finite-state machines that implement a lexical analyzer and a parser.
Starting from a sequence of characters, the lexical analyzer builds a sequence of language tokens (such as reserved words, literals, and identifiers) from which the parser builds a syntax tree. The lexical analyzer and the parser handle the regular and context-free parts of the programming language's grammar.[24]

See also[edit]
.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}
Abstract state machines (ASM)
Artificial intelligence (AI)
Abstract State Machine Language (AsmL)
Behavior model
Communicating finite-state machine
Control system
Control table
Decision tables
DEVS: Discrete Event System Specification
Extended finite-state machine (EFSM)
Finite-state machine with datapath
Gezel
Hidden Markov model
Homing sequence
Low-power FSM synthesis
Petri net
Pushdown automaton
Quantum finite automata (QFA)
Recognizable language
SCXML
Semiautomaton
Semigroup action
Sequential logic
Specification and Description Language
State diagram
State pattern
Synchronizing sequence
Transformation monoid
Transition monoid
Transition system
Tree automaton
Turing machine
UML state machine
Unique input/output sequence (UIO)

References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Wang, Jiacun (2019). Formal Methods in Computer Science. CRC Press. p.Â 34. ISBNÂ 978-1-4987-7532-8.

^ "Finite State Machines â Brilliant Math & Science Wiki". brilliant.org. Retrieved 2018-04-14.

^ Belzer, Jack; Holzman, Albert George; Kent, Allen (1975). Encyclopedia of Computer Science and Technology. Vol.Â 25. USA: CRC Press. p.Â 73. ISBNÂ 978-0-8247-2275-3.

^ Jump up to: a b Koshy, Thomas (2004). Discrete Mathematics With Applications. Academic Press. p.Â 762. ISBNÂ 978-0-12-421180-3.

^ Wright, David R. (2005). "Finite State Machines" (PDF). CSC215 Class Notes. David R. Wright website, N. Carolina State Univ. Archived from the original (PDF) on 2014-03-27. Retrieved 2012-07-14.

^ Jump up to: a b Keller, Robert M. (2001). "Classifiers, Acceptors, Transducers, and Sequencers" (PDF). Computer Science: Abstraction to Implementation (PDF). Harvey Mudd College. p.Â 480.

^ John E. Hopcroft and Jeffrey D. Ullman (1979). Introduction to Automata Theory, Languages, and Computation. Reading/MA: Addison-Wesley. ISBNÂ 978-0-201-02988-8.

^ Pouly, Marc; Kohlas, JÃ¼rg (2011). Generic Inference: A Unifying Theory for Automated Reasoning. John Wiley & Sons. Chapter 6. Valuation Algebras for Path Problems, p. 223 in particular. ISBNÂ 978-1-118-01086-0.

^ Jacek Jonczy (Jun 2008). "Algebraic path problems" (PDF). Archived from the original (PDF) on 2014-08-21. Retrieved 2014-08-20., p. 34

^ Felkin, M. (2007).  Guillet, Fabrice; Hamilton, Howard J. (eds.). Quality Measures in Data Mining - Studies in Computational Intelligence. Vol.Â 43. Springer, Berlin, Heidelberg. pp.Â 277â278. doi:10.1007/978-3-540-44918-8_12. ISBNÂ 978-3-540-44911-9.

^ Brutscheck, M., Berger, S., Franke, M., Schwarzbacher, A., Becker, S.: Structural Division Procedure for Efficient IC Analysis. IET Irish
Signals and Systems Conference, (ISSC 2008), pp.18â23. Galway, Ireland, 18â19 June 2008. [1]

^ "Tiwari, A. (2002). Formal Semantics and Analysis Methods for Simulink Stateflow Models" (PDF). sri.com. Retrieved 2018-04-14.

^ Hamon, G. (2005). A Denotational Semantics for Stateflow. International Conference on Embedded Software. Jersey City, NJ: ACM. pp.Â 164â172. CiteSeerXÂ 10.1.1.89.8817.

^ "Harel, D. (1987). A Visual Formalism for Complex Systems. Science of Computer Programming, 231â274" (PDF). Archived from the original (PDF) on 2011-07-15. Retrieved 2011-06-07.

^ "Alur, R., Kanade, A., Ramesh, S., & Shashidhar, K. C. (2008). Symbolic analysis for improving simulation coverage of Simulink/Stateflow models. International Conference on Embedded Software (pp. 89â98). Atlanta, GA: ACM" (PDF). Archived from the original (PDF) on 2011-07-15.

^ Black, Paul E (12 May 2008). "Finite State Machine". Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. Archived from the original on 13 October 2018. Retrieved 2 November 2016.

^ Anderson, James Andrew; Head, Thomas J. (2006). Automata theory with modern applications. Cambridge University Press. pp.Â 105â108. ISBNÂ 978-0-521-84887-9.

^ Hopcroft, John E. (1971). An n log n algorithm for minimizing states in a finite automaton (PDF) (Technical Report). Vol.Â CS-TR-71-190. Stanford Univ.[permanent dead link]

^ Almeida, Marco; Moreira, Nelma; Reis, Rogerio (2007). On the performance of automata minimization algorithms (PDF) (Technical Report). Vol.Â DCC-2007-03. Porto Univ. Archived from the original (PDF) on 17 January 2009. Retrieved 25 June 2008.

^ Edward F. Moore (1956).  C.E. Shannon and J. McCarthy (ed.). "Gedanken-Experiments on Sequential Machines". Annals of Mathematics Studies. Princeton University Press. 34: 129â153. Here: Theorem 4, p.142.

^ Revuz, D. (1992). "Minimization of Acyclic automata in Linear Time". Theoretical Computer Science. 92: 181â189. doi:10.1016/0304-3975(92)90142-3.

^ Kaeslin, Hubert (2008). "Mealy, Moore, Medvedev-type and combinatorial output bits". Digital Integrated Circuit Design: From VLSI Architectures to CMOS Fabrication. Cambridge University Press. p.Â 787. ISBNÂ 978-0-521-88267-5.

^ Slides Archived 18 January 2017 at the Wayback Machine, Synchronous Finite State Machines; Design and Behaviour, University of Applied Sciences Hamburg, p.18

^ Aho, Alfred V.; Sethi, Ravi; Ullman, Jeffrey D. (1986). Compilers: Principles, Techniques, and Tools (1stÂ ed.). Addison-Wesley. ISBNÂ 978-0-201-10088-4.


Further reading[edit]
General[edit]
Sakarovitch, Jacques (2009). Elements of automata theory. Translated from the French by Reuben Thomas. Cambridge University Press. ISBNÂ 978-0-521-84425-3. ZblÂ 1188.68177.
Wagner, F., "Modeling Software with Finite State Machines: A Practical Approach", Auerbach Publications, 2006, ISBNÂ 0-8493-8086-3.
ITU-T, Recommendation Z.100 Specification and Description Language (SDL)
Samek, M., Practical Statecharts in C/C++, CMP Books, 2002, ISBNÂ 1-57820-110-1.
Samek, M., Practical UML Statecharts in C/C++, 2nd Edition, Newnes, 2008, ISBNÂ 0-7506-8706-1.
Gardner, T., Advanced State Management, 2007
Cassandras, C., Lafortune, S., "Introduction to Discrete Event Systems". Kluwer, 1999, ISBNÂ 0-7923-8609-4.
Timothy Kam, Synthesis of Finite State Machines: Functional Optimization. Kluwer Academic Publishers, Boston 1997, ISBNÂ 0-7923-9842-4
Tiziano Villa, Synthesis of Finite State Machines: Logic Optimization. Kluwer Academic Publishers, Boston 1997, ISBNÂ 0-7923-9892-0
Carroll, J., Long, D., Theory of Finite Automata with an Introduction to Formal Languages. Prentice Hall, Englewood Cliffs, 1989.
Kohavi, Z., Switching and Finite Automata Theory. McGraw-Hill, 1978.
Gill, A., Introduction to the Theory of Finite-state Machines. McGraw-Hill, 1962.
Ginsburg, S., An Introduction to Mathematical Machine Theory. Addison-Wesley, 1962.
Finite-state machines (automata theory) in theoretical computer science[edit]
Arbib, Michael A. (1969). Theories of Abstract Automata (1stÂ ed.). Englewood Cliffs, N.J.: Prentice-Hall, Inc. ISBNÂ 978-0-13-913368-8.
Bobrow, Leonard S.; Arbib, Michael A. (1974). Discrete Mathematics: Applied Algebra for Computer and Information Science (1stÂ ed.). Philadelphia: W. B. Saunders Company, Inc. ISBNÂ 978-0-7216-1768-8.
Booth, Taylor L. (1967). Sequential Machines and Automata Theory (1stÂ ed.). New York: John Wiley and Sons, Inc. Library of Congress Card Catalog Number 67-25924.
Boolos, George; Jeffrey, Richard (1999) [1989]. Computability and Logic (3rdÂ ed.). Cambridge, England: Cambridge University Press. ISBNÂ 978-0-521-20402-6.
Brookshear, J. Glenn (1989). Theory of Computation: Formal Languages, Automata, and Complexity. Redwood City, California: Benjamin/Cummings Publish Company, Inc. ISBNÂ 978-0-8053-0143-4.
Davis, Martin; Sigal, Ron; Weyuker, Elaine J. (1994). Computability, Complexity, and Languages and Logic: Fundamentals of Theoretical Computer Science (2ndÂ ed.). San Diego: Academic Press, Harcourt, Brace & Company. ISBNÂ 978-0-12-206382-4.
Hopcroft, John; Ullman, Jeffrey (1979). Introduction to Automata Theory, Languages, and Computation (1stÂ ed.). Reading Mass: Addison-Wesley. ISBNÂ 978-0-201-02988-8.
Hopcroft, John E.; Motwani, Rajeev; Ullman, Jeffrey D. (2001). Introduction to Automata Theory, Languages, and Computation (2ndÂ ed.). Reading Mass: Addison-Wesley. ISBNÂ 978-0-201-44124-6.
Hopkin, David; Moss, Barbara (1976). Automata. New York: Elsevier North-Holland. ISBNÂ 978-0-444-00249-5.
Kozen, Dexter C. (1997). Automata and Computability (1stÂ ed.). New York: Springer-Verlag. ISBNÂ 978-0-387-94907-9.
Lewis, Harry R.; Papadimitriou, Christos H. (1998). Elements of the Theory of Computation (2ndÂ ed.). Upper Saddle River, New Jersey: Prentice-Hall. ISBNÂ 978-0-13-262478-7.
Linz, Peter (2006). Formal Languages and Automata (4thÂ ed.). Sudbury, MA: Jones and Bartlett. ISBNÂ 978-0-7637-3798-6.
Minsky, Marvin (1967). Computation: Finite and Infinite Machines (1stÂ ed.). New Jersey: Prentice-Hall.
Papadimitriou, Christos (1993). Computational Complexity (1stÂ ed.). Addison Wesley. ISBNÂ 978-0-201-53082-7.
Pippenger, Nicholas (1997). Theories of Computability (1stÂ ed.). Cambridge, England: Cambridge University Press. ISBNÂ 978-0-521-55380-3.
Rodger, Susan; Finley, Thomas (2006). JFLAP: An Interactive Formal Languages and Automata Package (1stÂ ed.). Sudbury, MA: Jones and Bartlett. ISBNÂ 978-0-7637-3834-1.
Sipser, Michael (2006). Introduction to the Theory of Computation (2ndÂ ed.). Boston Mass: Thomson Course Technology. ISBNÂ 978-0-534-95097-2.
Wood, Derick (1987). Theory of Computation (1stÂ ed.). New York: Harper & Row, Publishers, Inc. ISBNÂ 978-0-06-047208-5.
Abstract state machines in theoretical computer science[edit]
Gurevich, Yuri (July 2000). "Sequential Abstract State Machines Capture Sequential Algorithms" (PDF). ACM Transactions on Computational Logic. 1 (1): 77â111. CiteSeerXÂ 10.1.1.146.3017. doi:10.1145/343369.343384. S2CIDÂ 2031696.
Machine learning using finite-state algorithms[edit]
Mitchell, Tom M. (1997). Machine Learning (1stÂ ed.). New York: WCB/McGraw-Hill Corporation. ISBNÂ 978-0-07-042807-2.
Hardware engineering: state minimization and synthesis of sequential circuits[edit]
Booth, Taylor L. (1967). Sequential Machines and Automata Theory (1stÂ ed.). New York: John Wiley and Sons, Inc. Library of Congress Card Catalog Number 67-25924.
Booth, Taylor L. (1971). Digital Networks and Computer Systems (1stÂ ed.). New York: John Wiley and Sons, Inc. ISBNÂ 978-0-471-08840-0.
McCluskey, E. J. (1965). Introduction to the Theory of Switching Circuits (1stÂ ed.). New York: McGraw-Hill Book Company, Inc. Library of Congress Card Catalog Number 65-17394.
Hill, Fredrick J.; Peterson, Gerald R. (1965). Introduction to the Theory of Switching Circuits (1stÂ ed.). New York: McGraw-Hill Book Company. Library of Congress Card Catalog Number 65-17394.
Finite Markov chain processes[edit]
"We may think of a Markov chain as a process that moves successively through a set of states s1, s2, â¦, sr. â¦ if it is in state si it moves on to the next stop to state sj with probability pij. These probabilities can be exhibited in the form of a transition matrix" (Kemeny (1959), p. 384)
Finite Markov-chain processes are also known as subshifts of finite type.

Booth, Taylor L. (1967). Sequential Machines and Automata Theory (1stÂ ed.). New York: John Wiley and Sons, Inc. Library of Congress Card Catalog Number 67-25924.
Kemeny, John G.; Mirkil, Hazleton; Snell, J. Laurie; Thompson, Gerald L. (1959). Finite Mathematical Structures (1stÂ ed.). Englewood Cliffs, N.J.: Prentice-Hall, Inc. Library of Congress Card Catalog Number 59-12841. Chapter 6 "Finite Markov Chains".
External links[edit]



Wikimedia Commons has media related to Finite state machine.

Finite State Automata at Curlie
Modeling a Simple AI behavior using a Finite State Machine Example of usage in Video Games
Free On-Line Dictionary of Computing description of Finite-State Machines
NIST Dictionary of Algorithms and Data Structures description of Finite-State Machines
A brief overview of state machine types, comparing theoretical aspects of Mealy, Moore, Harel & UML state machines.
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}show.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteAutomata theory: formal languages and formal grammarsChomsky hierarchyGrammarsLanguagesAbstract machines
Type-0
â
Type-1
â
â
â
â
â
Type-2
â
â
Type-3
â
â

Unrestricted
(no common name)
Context-sensitive
Positive range concatenation
Indexed
â
Linear context-free rewriting systems
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
â
Non-recursive

Recursively enumerable
Decidable
Context-sensitive
Positive range concatenation*
Indexed*
â
Linear context-free rewriting language
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
Star-free
Finite

Turing machine
Decider
Linear-bounded
PTIME Turing Machine
Nested stack
Thread automaton
restricted Tree stack automaton
Embedded pushdown
Nondeterministic pushdown
Deterministic pushdown
Visibly pushdown
Finite
Counter-free (with aperiodic finite monoid)
Acyclic finite
Each category of languages, except those marked by a *, is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line.
showvteDigital electronicsComponents
Transistor
Resistor
Inductor
Capacitor
Printed electronics
Printed circuit board
Electronic circuit
Flip-flop
Memory cell
Combinational logic
Sequential logic
Logic gate
Boolean circuit
Integrated circuit (IC)
Hybrid integrated circuit (HIC)
Mixed-signal integrated circuit
Three-dimensional integrated circuit (3D IC)
Emitter-coupled logic (ECL)
Erasable programmable logic device (EPLD)
Macrocell array
Programmable logic array (PLA)
Programmable logic device (PLD)
Programmable Array Logic (PAL)
Generic array logic (GAL)
Complex programmable logic device (CPLD)
Field-programmable gate array (FPGA)
Field-programmable object array (FPOA)
Application-specific integrated circuit (ASIC)
Tensor Processing Unit (TPU)
Theory
Digital signal
Boolean algebra
Logic synthesis
Logic in computer science
Computer architecture
Digital signal
Digital signal processing
Circuit minimization
Switching circuit theory
Gate equivalent
Design
Logic synthesis
Place and route
Placement
Routing
Register-transfer level
Hardware description language
High-level synthesis
Formal equivalence checking
Synchronous logic
Asynchronous logic
Finite-state machine
Hierarchical state machine
Applications
Computer hardware
Hardware acceleration
Digital audio
radio
Digital photography
Digital telephone
Digital video
cinematography
television
Electronic literature
Design issues
Metastability
Runt pulse





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Finite-state_machine&oldid=1067167233"
		Categories: Finite automataHidden categories: CS1: long volume valueAll articles with dead external linksArticles with dead external links from October 2017Articles with permanently dead external linksWebarchive template wayback linksArticles with short descriptionShort description is different from WikidataUse dmy dates from January 2020Wikipedia articles needing clarification from March 2021All articles with unsourced statementsArticles with unsourced statements from March 2021Articles with unsourced statements from January 2017All articles that are too technicalWikipedia articles that are too technical from January 2017All articles needing expert attentionArticles needing expert attention from January 2017Commons category link is on WikidataArticles with Curlie links
	
