
Title:
Rounding
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Replacing a number with a simpler value
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}For other uses, see Rounding (disambiguation).
This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources:Â "Rounding"Â âÂ newsÂ Â· newspapersÂ Â· booksÂ Â· scholarÂ Â· JSTOR  (October 2017) (Learn how and when to remove this template message)


  Graphs of the result, y, of rounding x using different methods. For clarity, the graphs are shown displaced from integer y values. InÂ theÂ SVGÂ file, hover over a method to highlight it and, in SMIL-enabled browsers, click to select or deselect it.
Rounding means replacing a number with an approximate value that has a shorter, simpler, or more explicit representation. For example, replacing $23.4476 with $23.45, the fraction 312/937 with 1/3, or the expression â2 with 1.414.
Rounding is often done to obtain a value that is easier to report and communicate than the original. Rounding can also be important to avoid misleadingly precise reporting of a computed number, measurement or estimate; for example, a quantity that was computed as 123,456 but is known to be accurate only to within a few hundred units is usually better stated as "about 123,500".
On the other hand, rounding of exact numbers will introduce some round-off error in the reported result. Rounding is almost unavoidable when reporting many computations â especially when dividing two numbers in integer or fixed-point arithmetic; when computing mathematical functions such as square roots, logarithms, and sines; or when using a floating-point representation with a fixed number of significant digits. In a sequence of calculations, these rounding errors generally accumulate, and in certain ill-conditioned cases they may make the result meaningless.
Accurate rounding of transcendental mathematical functions is difficult because the number of extra digits that need to be calculated to resolve whether to round up or down cannot be known in advance. This problem is known as "the table-maker's dilemma".
Rounding has many similarities to the quantization that occurs when physical quantities must be encoded by numbers or digital signals.
A wavy equals sign (â: approximately equal to) is sometimes used to indicate rounding of exact numbers, e.g., 9.98 â 10. This sign was introduced by Alfred George Greenhill in 1892.[1]
Ideal characteristics of rounding methods include:

Rounding should be done by a function. This way, when the same input is rounded in different instances, the output is unchanged.
Calculations done with rounding should be close to those done without rounding.
As a result of (1) and (2), the output from rounding should be close to its input, often as close as possible by some metric.
To be considered rounding, the range will be a subset of the domain. A classical range is the integers, Z.
Rounding should preserve symmetries that already exist between the domain and range. With finite precision (or a discrete domain), this translates to removing bias.
A rounding method should have utility in computer science or human arithmetic where finite precision is used, and speed is a consideration.
Because it is not usually possible for a method to satisfy all ideal characteristics, many different rounding methods exist.
As a general rule, rounding is idempotent;[2] i.e., once a number has been rounded, rounding it again will not change its value. Rounding functions are also monotonic; i.e., rounding a larger number results in the same or larger result than rounding the smaller number.

Contents

1 Types of rounding
2 Rounding to integer

2.1 Directed rounding to an integer

2.1.1 Rounding down
2.1.2 Rounding up
2.1.3 Rounding toward zero
2.1.4 Rounding away from zero


2.2 Rounding to the nearest integer

2.2.1 Round half up
2.2.2 Round half down
2.2.3 Round half toward zero
2.2.4 Round half away from zero
2.2.5 Round half to even
2.2.6 Round half to odd


2.3 Randomized rounding to an integer

2.3.1 Alternating tie-breaking
2.3.2 Random tie-breaking
2.3.3 Stochastic rounding


2.4 Comparison of approaches for rounding to an integer


3 Rounding to other values

3.1 Rounding to a specified multiple
3.2 Logarithmic rounding

3.2.1 Rounding to a specified power
3.2.2 Scaled rounding


3.3 Floating-point rounding
3.4 Rounding to a simple fraction
3.5 Rounding to an available value


4 Rounding in other contexts

4.1 Dithering and error diffusion
4.2 Monte Carlo arithmetic
4.3 Exact computation with rounded arithmetic
4.4 Double rounding
4.5 Table-maker's dilemma
4.6 Interaction with string searches


5 History
6 Rounding functions in programming languages
7 Other rounding standards

7.1 US weather observations
7.2 Negative zero in meteorology


8 See also
9 Notes
10 References
11 External links



Types of rounding[edit]
Typical rounding problems include:



Rounding problem

Example input

Result

Rounding criterion


Approximating an irrational number by a fraction

Ï

22â¯/â¯7

1-digit-denominator


Approximating a rational number by another fraction with smaller numerator and denominator

399â¯/â¯941

3â¯/â¯7

1-digit-denominator


Approximating a fraction, which have periodic decimal expansion, by a finite decimal fraction

5â¯/â¯3

1.6667

4 decimal places


Approximating a fractional decimal number by one with fewer digits

2.1784

2.18

2 decimal places


Approximating a decimal integer by an integer with more trailing zeros

23,217

23,200

3 significant figures


Approximating a large decimal integer using scientific notation

300,999,999

3.01â¯Ãâ¯108

3 significant figures


Approximating a value by a multiple of a specified amount

48.2

45

Multiple ofÂ 15


Rounding each one of a finite set of real numbers (mostly fractions) to an integer (sometimes the second nearest integer) so that the sum of the rounded numbers equals the rounded sum of the numbers (needed e.g. [1] for the apportionment of seats, implemented e.g. by the largest remainder method, see Mathematics of apportionment, and [2] for distributing the total VAT of an invoice to its items)

{3/12, 4/12, 5/12}

{0, 0, 1}

Sum of rounded elements equals rounded sum of elements

Rounding to integer[edit]
The most basic form of rounding is to replace an arbitrary number by an integer. All the following rounding modes are concrete implementations of an abstract single-argument "round()" procedure. These are true functions (with the exception of those that use randomness).

Directed rounding to an integer[edit]
These four methods are called directed rounding, as the displacements from the original number x to the rounded value y are all directed toward or away from the same limiting value (0, +â, or ââ). Directed rounding is used in interval arithmetic and is often required in financial calculations.
If x is positive, round-down is the same as round-toward-zero, and round-up is the same as round-away-from-zero. If x is negative, round-down is the same as round-away-from-zero, and round-up is the same as round-toward-zero. In any case, if x is an integer, y is just x.
Where many calculations are done in sequence, the choice of rounding method can have a very significant effect on the result. A famous instance involved a new index set up by the Vancouver Stock Exchange in 1982. It was initially set at 1000.000 (three decimal places of accuracy), and after 22 months had fallen to about 520 â whereas stock prices had generally increased in the period. The problem was caused by the index being recalculated thousands of times daily, and always being rounded down to 3 decimal places, in such a way that the rounding errors accumulated. Recalculating with better rounding gave an index value of 1098.892 at the end of the same period.[3]
For the examples below, sgn(x) refers to the sign function applied to the original number, x.

Rounding down[edit]
round down (or take the floor, or round toward negative infinity): y is the largest integer that does not exceed x.

  
    
      
        y
        =
        
          f
          l
          o
          o
          r
        
        (
        x
        )
        =
        
          â
          x
          â
        
        =
        â
        
          â
          
            â
            x
          
          â
        
      
    
    {\displaystyle y=\mathrm {floor} (x)=\left\lfloor x\right\rfloor =-\left\lceil -x\right\rceil }
  

For example, 23.7 gets rounded to 23, and â23.2 gets rounded to â24.

Rounding up[edit]
round up (or take the ceiling, or round toward positive infinity): y is the smallest integer that is not less than x.

  
    
      
        y
        =
        ceil
        â¡
        (
        x
        )
        =
        
          â
          x
          â
        
        =
        â
        
          â
          
            â
            x
          
          â
        
      
    
    {\displaystyle y=\operatorname {ceil} (x)=\left\lceil x\right\rceil =-\left\lfloor -x\right\rfloor }
  

For example, 23.2 gets rounded to 24, and â23.7 gets rounded to â23.

Rounding toward zero[edit]
round toward zero (or truncate, or round away from infinity): y is the integer that is closest to x such that it is between 0 and x (included); i.e. y is the integer part of x, without its fraction digits.

  
    
      
        y
        =
        truncate
        â¡
        (
        x
        )
        =
        sgn
        â¡
        (
        x
        )
        
          â
          
            |
            x
            |
          
          â
        
        =
        â
        sgn
        â¡
        (
        x
        )
        
          â
          
            â
            
              |
              x
              |
            
          
          â
        
        =
        
          
            {
            
              
                
                  
                    â
                    x
                    â
                  
                
                
                  x
                  â¥
                  0
                
              
              
                
                  
                    â
                    x
                    â
                  
                
                
                  x
                  <
                  0
                
              
            
            
          
        
      
    
    {\displaystyle y=\operatorname {truncate} (x)=\operatorname {sgn}(x)\left\lfloor \left|x\right|\right\rfloor =-\operatorname {sgn}(x)\left\lceil -\left|x\right|\right\rceil ={\begin{cases}\left\lfloor x\right\rfloor &x\geq 0\\\left\lceil x\right\rceil &x<0\\\end{cases}}}
  

For example, 23.7 gets rounded to 23, and â23.7 gets rounded to â23.

Rounding away from zero[edit]
round away from zero (or round toward infinity): y is the integer that is closest to 0 (or equivalently, to x) such that x is between 0 and y (included).

  
    
      
        y
        =
        sgn
        â¡
        (
        x
        )
        
          â
          
            |
            x
            |
          
          â
        
        =
        â
        sgn
        â¡
        (
        x
        )
        
          â
          
            â
            
              |
              x
              |
            
          
          â
        
        =
        
          
            {
            
              
                
                  
                    â
                    x
                    â
                  
                
                
                  x
                  â¥
                  0
                
              
              
                
                  
                    â
                    x
                    â
                  
                
                
                  x
                  <
                  0
                
              
            
            
          
        
      
    
    {\displaystyle y=\operatorname {sgn}(x)\left\lceil \left|x\right|\right\rceil =-\operatorname {sgn}(x)\left\lfloor -\left|x\right|\right\rfloor ={\begin{cases}\left\lceil x\right\rceil &x\geq 0\\\left\lfloor x\right\rfloor &x<0\\\end{cases}}}
  

For example, 23.2 gets rounded to 24, and â23.2 gets rounded to â24.

Rounding to the nearest integer[edit]
Rounding a number x to the nearest integer requires some tie-breaking rule for those cases when x is exactly half-way between two integers â that is, when the fraction part of x is exactly 0.5.
If it were not for the 0.5 fractional parts, the round-off errors introduced by the round to nearest method would be symmetric: for every fraction that gets rounded down (such as 0.268), there is a complementary fraction (namely, 0.732) that gets rounded up by the same amount.
When rounding a large set of fixed-point numbers with uniformly distributed fractional parts, the rounding errors by all values, with the omission of those having 0.5 fractional part, would statistically compensate each other. This means that the expected (average) value of the rounded numbers is equal to the expected value of the original numbers when numbers with fractional part 0.5 from the set are removed.
In practice, floating-point numbers are typically used, which have even more computational nuances because they are not equally spaced.

Round half up[edit]
The following tie-breaking rule, called round half up (or round half toward positive infinity), is widely used in many disciplines.[citation needed] That is, half-way values of x are always rounded up.

If the fraction of x is exactly 0.5, then yÂ =Â xÂ +Â 0.5

  
    
      
        y
        =
        
          â
          
            x
            +
            0.5
          
          â
        
        =
        â
        
          â
          
            â
            x
            â
            0.5
          
          â
        
        =
        
          â
          
            
              
                â
                2
                x
                â
              
              2
            
          
          â
        
      
    
    {\displaystyle y=\left\lfloor x+0.5\right\rfloor =-\left\lceil -x-0.5\right\rceil =\left\lceil {\frac {\lfloor 2x\rfloor }{2}}\right\rceil }
  

For example, 23.5 gets rounded to 24, and â23.5 gets rounded to â23.
However, some programming languages (such as Java, Python) define their half up as round half away from zero here.[4][5]
This method only requires checking one digit to determine rounding direction in two's complement and similar representations.

Round half down[edit]
One may also use round half down (or round half toward negative infinity) as opposed to the more common round half up.

If the fraction of x is exactly 0.5, then yÂ =Â xÂ âÂ 0.5

  
    
      
        y
        =
        
          â
          
            x
            â
            0.5
          
          â
        
        =
        â
        
          â
          
            â
            x
            +
            0.5
          
          â
        
        =
        
          â
          
            
              
                â
                2
                x
                â
              
              2
            
          
          â
        
      
    
    {\displaystyle y=\left\lceil x-0.5\right\rceil =-\left\lfloor -x+0.5\right\rfloor =\left\lfloor {\frac {\lceil 2x\rceil }{2}}\right\rfloor }
  

For example, 23.5 gets rounded to 23, and â23.5 gets rounded to â24.

Round half toward zero[edit]
One may also round half toward zero (or round half away from infinity) as opposed to the conventional round half away from zero.

If the fraction of x is exactly 0.5, then yÂ =Â xÂ âÂ 0.5 if x is positive, and yÂ =Â xÂ +Â 0.5 if x is negative.

  
    
      
        y
        =
        sgn
        â¡
        (
        x
        )
        
          â
          
            
              |
              x
              |
            
            â
            0.5
          
          â
        
        =
        â
        sgn
        â¡
        (
        x
        )
        
          â
          
            â
            
              |
              x
              |
            
            +
            0.5
          
          â
        
      
    
    {\displaystyle y=\operatorname {sgn}(x)\left\lceil \left|x\right|-0.5\right\rceil =-\operatorname {sgn}(x)\left\lfloor -\left|x\right|+0.5\right\rfloor }
  

For example, 23.5 gets rounded to 23, and â23.5 gets rounded to â23.
This method treats positive and negative values symmetrically, and therefore is free of overall positive/negative bias if the original numbers are positive or negative with equal probability. It does, however, still have bias toward zero.

Round half away from zero[edit]
The other tie-breaking method commonly taught and used is the round half away from zero (or round half toward infinity), namely:

If the fraction of x is exactly 0.5, then y = x + 0.5 if x is positive, and y = x â 0.5 if x is negative.

  
    
      
        y
        =
        sgn
        â¡
        (
        x
        )
        
          â
          
            
              |
              x
              |
            
            +
            0.5
          
          â
        
        =
        â
        sgn
        â¡
        (
        x
        )
        
          â
          
            â
            
              |
              x
              |
            
            â
            0.5
          
          â
        
      
    
    {\displaystyle y=\operatorname {sgn}(x)\left\lfloor \left|x\right|+0.5\right\rfloor =-\operatorname {sgn}(x)\left\lceil -\left|x\right|-0.5\right\rceil }
  

For example, 23.5 gets rounded to 24, and â23.5 gets rounded to â24.
This can be more efficient on binary computers because only the first omitted bit needs to be considered to determine if it rounds up (on a 1) or down (on a 0). This is one method used when rounding to significant figures due to its simplicity.
This method, also known as commercial rounding,[citation needed] treats positive and negative values symmetrically, and therefore is free of overall positive/negative bias if the original numbers are positive or negative with equal probability. It does, however, still have bias away from zero.
It is often used for currency conversions and price roundings (when the amount is first converted into the smallest significant subdivision of the currency, such as cents of a euro) as it is easy to explain by just considering the first fractional digit, independently of supplementary precision digits or sign of the amount (for strict equivalence between the paying and recipient of the amount).

Round half to even[edit]
A tie-breaking rule without positive/negative bias and without bias toward/away from zero is round half to even. By this convention, if the fractional part of x is 0.5, then y is the even integer nearest to x. Thus, for example, +23.5 becomes +24, as does +24.5; however, â23.5 becomes â24, as does â24.5. This function minimizes the expected error when summing over rounded figures, even when the inputs are mostly positive or mostly negative, provided they are neither mostly even nor mostly odd.
This variant of the round-to-nearest method is also called convergent rounding, statistician's rounding, Dutch rounding, Gaussian rounding, oddâeven rounding,[6] or bankers' rounding.
This is the default rounding mode used in IEEE 754 operations for results in binary floating-point formats (see also nearest integer function), and the more sophisticated mode[clarification needed] used when rounding to significant figures.
By eliminating bias, repeated rounded addition or subtraction of independent numbers will give a result with an error that tends to grow in proportion to the square root of the number of operations rather than linearly. See random walk for more.
However, this rule distorts the distribution by increasing the probability of evens relative to odds. Typically this is less important[citation needed] than the biases that are eliminated by this method.

Round half to odd[edit]
A similar tie-breaking rule to round half to even is round half to odd. In this approach, if the fraction of x is 0.5, then y is the odd integer nearest to x. Thus, for example, +23.5 becomes +23, as does +22.5; while â23.5 becomes â23, as does â22.5.
This method is also free from positive/negative bias and bias toward/away from zero, provided the numbers to be rounded are neither mostly even nor mostly odd.  It also shares the round half to even property of distorting the original distribution, as it increases the probability of odds relative to evens.
This variant is almost never used in computations, except in situations where one wants to avoid increasing the scale of floating-point numbers, which have a limited exponent range. With round half to even, a non-infinite number would round to infinity, and a small denormal value would round to a normal non-zero value. Effectively, this mode prefers preserving the existing scale of tie numbers, avoiding out-of-range results when possible for numeral systems of even radix (such as binary and decimal).[clarification needed (see talk)]

Randomized rounding to an integer[edit]
Alternating tie-breaking[edit]
One method, more obscure than most, is to alternate direction when rounding a number with 0.5 fractional part. All others are rounded to the closest integer.

Whenever the fractional part is 0.5, alternate rounding up or down: for the first occurrence of a 0.5 fractional part, round up, for the second occurrence, round down, and so on. Alternatively, the first 0.5 fractional part rounding can be determined by a random seed.  "Up" and "down" can be any two rounding methods that oppose each other - toward and away from positive infinity or toward and away from zero.
If occurrences of 0.5 fractional parts occur significantly more than a restart of the occurrence "counting", then it is effectively bias free. With guaranteed zero bias, it is useful if the numbers are to be summed or averaged.

Random tie-breaking[edit]
If the fractional part of x is 0.5, choose y randomly between x + 0.5 and x â 0.5, with equal probability. All others are rounded to the closest integer.
Like round-half-to-even and round-half-to-odd, this rule is essentially free of overall bias, but it is also fair among even and odd y values. An advantage over alternate tie-breaking is that the last direction of rounding on the 0.5 fractional part does not have to be "remembered".

Stochastic rounding[edit]
Rounding as follows to one of the closest integer toward negative infinity and the closest integer toward positive infinity, with a probability dependent on the proximity is called stochastic rounding and will give an unbiased result on average.[7]


  
    
      
        Round
        â¡
        (
        x
        )
        =
        
          
            {
            
              
                
                  â
                  x
                  â
                
                
                  
                    Â with probabilityÂ 
                  
                  1
                  â
                  (
                  x
                  â
                  â
                  x
                  â
                  )
                  =
                  â
                  x
                  â
                  â
                  x
                  +
                  1
                
              
              
                
                  â
                  x
                  â
                  +
                  1
                
                
                  
                    Â with probabilityÂ 
                  
                  
                    x
                    â
                    â
                    x
                    â
                  
                
              
            
            
          
        
      
    
    {\displaystyle \operatorname {Round} (x)={\begin{cases}\lfloor x\rfloor &{\text{ with probability }}1-(x-\lfloor x\rfloor )=\lfloor x\rfloor -x+1\\\lfloor x\rfloor +1&{\text{ with probability }}{x-\lfloor x\rfloor }\end{cases}}}
  

For example, 1.6 would be rounded to 1 with probability 0.4 and to 2 with probability 0.6.
Stochastic rounding can be accurate in a way that a rounding function can never be. For example, suppose one started with 0 and added 0.3 to that one hundred times while rounding the running total between every addition. The result would be 0 with regular rounding, but with stochastic rounding, the expected result would be 30, which is the same value obtained without rounding. This can be useful in machine learning where the training may use low precision arithmetic iteratively.[7] Stochastic rounding is also a way to achieve 1-dimensional dithering.

Comparison of approaches for rounding to an integer[edit]


Value

Functional methods

Randomized methods


Directed rounding

Round to nearest

Alternating tie-break

Random tie-break

Stochastic


Down(toward ââ)

Up(toward +â)

Toward 0

Away From 0

Half Down(toward ââ)

Half Up(toward +â)

Half Toward 0

Half Away From 0

Half to Even

Half to Odd

Average

SD

Average

SD

Average

SD


+1.8

+1

+2

+1

+2

+2

+2

+2

+2

+2

+2

+2

0

+2

0

+1.8

0.04


+1.5

+1

+1

+1

+1.505

0

+1.5

0.05

+1.5

0.05


+1.2

+1

+1

+1

+1

0

+1

0

+1.2

0.04


+0.8

0

+1

0

+1

+0.8

0.04


+0.5

0

0

0

+0.505

0

+0.5

0.05

+0.5

0.05


+0.2

0

0

0

0

0

0

0

+0.2

0.04


â0.2

â1

0

â1

â0.2

0.04


â0.5

â1

â1

â1

â0.495

0

â0.5

0.05

â0.5

0.05


â0.8

â1

â1

â1

â1

0

â1

0

â0.8

0.04


â1.2

â2

â1

â1

â2

â1.2

0.04


â1.5

â2

â2

â2

â1.495

0

â1.5

0.05

â1.5

0.05


â1.8

â2

â2

â2

â2

0

â2

0

â1.8

0.04

Rounding to other values[edit]
Rounding to a specified multiple[edit]
The most common type of rounding is to round to an integer; or, more generally, to an integer multiple of some increment â such as rounding to whole tenths of seconds, hundredths of a dollar, to whole multiples of 1/2 or 1/8â¯inch, to whole dozens or thousands, etc.
In general, rounding a number x to a multiple of some specified positive value m entails the following steps:


  
    
      
        
          r
          o
          u
          n
          d
          T
          o
          M
          u
          l
          t
          i
          p
          l
          e
        
        (
        x
        ,
        m
        )
        =
        
          r
          o
          u
          n
          d
        
        (
        x
        
          /
        
        m
        )
        Ã
        m
      
    
    {\displaystyle \mathrm {roundToMultiple} (x,m)=\mathrm {round} (x/m)\times m}
  

For example, rounding xÂ =Â 2.1784 dollars to whole cents (i.e., to a multiple of 0.01) entails computing 2.1784â¯/â¯0.01â¯=â¯217.84, then rounding that to 218, and finally computing 218â¯Ãâ¯0.01â¯=â¯2.18.
When rounding to a predetermined number of significant digits, the increment m depends on the magnitude of the number to be rounded (or of the rounded result).
The increment m is normally a finite fraction in whatever numeral system is used to represent the numbers. For display to humans, that usually means the decimal numeral system (that is, m is an integer times a power of 10, like 1/1000 or 25/100). For intermediate values stored in digital computers, it often means the binary numeral system (m is an integer times a power of 2).
The abstract single-argument "round()" function that returns an integer from an arbitrary real value has at least a dozen distinct concrete definitions presented in the rounding to integer section. The abstract two-argument "roundToMultiple()" function is formally defined here, but in many cases it is used with the implicit value mÂ =Â 1 for the increment and then reduces to the equivalent abstract single-argument function, with also the same dozen distinct concrete definitions.

Logarithmic rounding[edit]
Rounding to a specified power[edit]
Rounding to a specified power is very different from rounding to a specified multiple; for example, it is common in computing to need to round a number to a whole power of 2. The steps, in general, to round a positive number x to a power of some positive number b other than 1, are:


  
    
      
        
          r
          o
          u
          n
          d
          T
          o
          P
          o
          w
          e
          r
        
        (
        x
        ,
        b
        )
        =
        
          b
          
            
              r
              o
              u
              n
              d
            
            (
            
              log
              
                b
              
            
            â¡
            x
            )
          
        
        ,
        x
        >
        0
        ,
        b
        >
        0
        ,
        b
        â 
        1
      
    
    {\displaystyle \mathrm {roundToPower} (x,b)=b^{\mathrm {round} (\log _{b}x)},x>0,b>0,b\neq 1}
  

Many of the caveats applicable to rounding to a multiple are applicable to rounding to a power.

Scaled rounding[edit]
This type of rounding, which is also named rounding to a logarithmic scale, is a variant of rounding to a specified power. Rounding on a logarithmic scale is accomplished by taking the log of the amount and doing normal rounding to the nearest value on the log scale.
For example, resistors are supplied with preferred numbers on a logarithmic scale. In particular, for resistors with a 10% accuracy, they are supplied with nominal values 100, 120, 150, 180, 220, etc. rounded to multiples of 10 (E12 series). If a calculation indicates a resistor of 165 ohms is required then log(150)â¯=â¯2.176, log(165)â¯=â¯2.217 and log(180)â¯=â¯2.255. The logarithm of 165 is closer to the logarithm of 180 therefore a 180 ohm resistor would be the first choice if there are no other considerations.
Whether a value x â (a, b) rounds to a or b depends upon whether the squared value x2 is greater than or less than the product ab. The value 165 rounds to 180 in the resistors example because 1652 = 27225 is greater than 150 Ã 180 = 27000.

Floating-point rounding[edit]
In floating-point arithmetic, rounding aims to turn a given value x into a value y with a specified number of significant digits. In other words, y should be a multiple of a number m that depends on the magnitude of x. The number m is a power of the base (usually 2 or 10) of the floating-point representation.
Apart from this detail, all the variants of rounding discussed above apply to the rounding of floating-point numbers as well. The algorithm for such rounding is presented in the Scaled rounding section above, but with a constant scaling factor sÂ =Â 1, and an integer base bÂ >Â 1.
Where the rounded result would overflow the result for a directed rounding is either the appropriate signed infinity when "rounding away from zero", or the highest representable positive finite number (or the lowest representable negative finite number if x is negative), when "rounding toward zero". The result of an overflow for the usual case of round to nearest is always the appropriate infinity.

Rounding to a simple fraction[edit]
In some contexts it is desirable to round a given number x to a "neat" fraction â that is, the nearest fraction yÂ =Â m/n whose numerator m and denominator n do not exceed a given maximum. This problem is fairly distinct from that of rounding a value to a fixed number of decimal or binary digits, or to a multiple of a given unit m. This problem is related to Farey sequences, the SternâBrocot tree, and continued fractions.

Rounding to an available value[edit]
Finished lumber, writing paper, capacitors, and many other products are usually sold in only a few standard sizes.
Many design procedures describe how to calculate an approximate value, and then "round" to some standard size using phrases such as "round down to nearest standard value", "round up to nearest standard value", or "round to nearest standard value".[8][9]
When a set of preferred values is equally spaced on a logarithmic scale, choosing the closest preferred value to any given value can be seen as a form of scaled rounding. Such rounded values can be directly calculated.[10]

Rounding in other contexts[edit]
Dithering and error diffusion[edit]
When digitizing continuous signals, such as sound waves, the overall effect of a number of measurements is more important than the accuracy of each individual measurement. In these circumstances, dithering, and a related technique, error diffusion, are normally used. A related technique called pulse-width modulation is used to achieve analog type output from an inertial device by rapidly pulsing the power with a variable duty cycle.
Error diffusion tries to ensure the error, on average, is minimized. When dealing with a gentle slope from one to zero, the output would be zero for the first few terms until the sum of the error and the current value becomes greater than 0.5, in which case a 1 is output and the difference subtracted from the error so far. FloydâSteinberg dithering is a popular error diffusion procedure when digitizing images.
As a one-dimensional example, suppose the numbers 0.9677, 0.9204, 0.7451, and 0.3091 occur in order and each is to be rounded to a multiple of 0.01. In this case the cumulative sums, 0.9677, 1.8881 = 0.9677 + 0.9204, 2.6332 = 0.9677 + 0.9204 + 0.7451, and 2.9423 = 0.9677 + 0.9204 + 0.7451 + 0.3091, are each rounded to a multiple of 0.01: 0.97, 1.89, 2.63, and 2.94. The first of these and the differences of adjacent values give the desired rounded values: 0.97, 0.92 = 1.89 â 0.97, 0.74 = 2.63 â 1.89, and 0.31 = 2.94 â 2.63.

Monte Carlo arithmetic[edit]
Monte Carlo arithmetic is a technique in Monte Carlo methods where the rounding is randomly up or down. Stochastic rounding can be used for Monte Carlo arithmetic, but in general, just rounding up or down with equal probability is more often used. Repeated runs will give a random distribution of results which can indicate the stability of the computation.[11]

Exact computation with rounded arithmetic[edit]
It is possible to use rounded arithmetic to evaluate the exact value of a function with integer domain and range. For example, if an integer n is known to be a perfect square, its square root can be computed by converting n to a floating-point value z, computing the approximate square root x of z with floating point, and then rounding x to the nearest integer y. If n is not too big, the floating-point round-off error in x will be less than 0.5, so the rounded value y will be the exact square root of n. This is essentially why slide rules could be used for exact arithmetic.

Double rounding[edit]

Rounding a number twice in succession to different levels of precision, with the latter precision being coarser, is not guaranteed to give the same result as rounding once to the final precision except in the case of directed rounding.[nb 1] For instance rounding 9.46 to one decimal gives 9.5, and then 10 when rounding to integer using rounding half to even, but would give 9 when rounded to integer directly. Borman and Chatfield[12] discuss the implications of double rounding when comparing data rounded to one decimal place to specification limits expressed using integers.
In Martinez v. Allstate and Sendejo v. Farmers, litigated between 1995 and 1997, the insurance companies argued that double rounding premiums was permissible and in fact required. The US courts ruled against the insurance companies and ordered them to adopt rules to ensure single rounding.[13]
Some computer languages and the IEEE 754-2008 standard dictate that in straightforward calculations the result should not be rounded twice. This has been a particular problem with Java as it is designed to be run identically on different machines, special programming tricks have had to be used to achieve this with x87 floating point.[14][15]
The Java language was changed to allow different results where the difference does not matter and require a strictfp qualifier to be used when the results have to conform accurately; strict floating point has been restored in JavaÂ 17.[16]
In some algorithms, an intermediate result is computed in a larger precision, then must be rounded to the final precision. Double rounding can be avoided by choosing an adequate rounding for the intermediate computation. This consists in avoiding to round to midpoints for the final rounding (except when the midpoint is exact). In binary arithmetic, the idea is to round the result toward zero, and set the least significant bit to 1 if the rounded result is inexact; this rounding is called sticky rounding.[17] Equivalently, it consists in returning the intermediate result when it is exactly representable, and the nearest floating-point number with an odd significand otherwise; this is why it is also known as rounding to odd.[18][19]

Table-maker's dilemma[edit]
William M. Kahan coined the term "The Table-Maker's Dilemma" for the unknown cost of rounding transcendental functions:

"Nobody knows how much it would cost to compute yw correctly rounded for every two floating-point arguments at which it does not over/underflow. Instead, reputable math libraries compute elementary transcendental functions mostly within slightly more than half an ulp and almost always well within one ulp. Why can't yw be rounded within half an ulp like SQRT? Because nobody knows how much computation it would cost... No general way exists to predict how many extra digits will have to be carried to compute a transcendental expression and round it correctly to some preassigned number of digits. Even the fact (if true) that a finite number of extra digits will ultimately suffice may be a deep theorem."[20]
The IEEE 754 floating-point standard guarantees that add, subtract, multiply, divide, fused multiplyâadd, square root, and floating-point remainder will give the correctly rounded result of the infinite-precision operation. No such guarantee was given in the 1985 standard for more complex functions and they are typically only accurate to within the last bit at best. However, the 2008 standard guarantees that conforming implementations will give correctly rounded results which respect the active rounding mode; implementation of the functions, however, is optional.
Using the GelfondâSchneider theorem and LindemannâWeierstrass theorem many of the standard elementary functions can be proved to return transcendental results when given rational non-zero arguments; therefore it is always possible to correctly round such functions. However, determining a limit for a given precision on how accurate results need to be computed, before a correctly rounded result can be guaranteed, may demand a lot of computation time or may be out of reach.[21] In practice, when this limit is not known or too large, some decision has to be made in the implementation (see below), but according to a probabilistic model, correct rounding can be satisfied with a very high probability.
Some programming packages offer correct rounding. The GNU MPFR package gives correctly rounded arbitrary precision results. Some other libraries implement elementary functions with correct rounding in double precision:

IBM's Accurate portable mathematical library (abbreviated as APMathLib or just MathLib),[22] also called libultim,[23] in rounding to nearest only. This library uses up to 768 bits of working precision. It was included in the GNU C Library in 2001,[24] but the "slow paths" (providing correct rounding) were removed from 2018 to 2021.
Sun Microsystems's libmcr, in the 4 rounding modes.[25] For the difficult cases, this library also uses multiple precision, and the number of words is increased by 2 each time the Table-maker's dilemma occurs (with undefined behavior in the very unlikely event that some limit of the machine is reached).
CRlibm, written in the old ArÃ©naire team (LIP, ENS Lyon). It supports the 4 rounding modes and is proved.[26]
There exist computable numbers for which a rounded value can never be determined no matter how many digits are calculated. Specific instances cannot be given but this follows from the undecidability of the halting problem. For instance, if Goldbach's conjecture is true but unprovable, then the result of rounding the following value up to the next integer cannot be determined: either 1+10ân where n is the first even number greater than 4 which is not the sum of two primes, or 1 if there is no such number. The rounded result is 2 if such a number n exists and 1 otherwise. The value before rounding can however be approximated to any given precision even if the conjecture is unprovable.

Interaction with string searches[edit]
Rounding can adversely affect a string search for a number. For example, Ï rounded to four digits is "3.1416" but a simple search for this string will not discover "3.14159" or any other value of Ï rounded to more than four digits. In contrast, truncation does not suffer from this problem; for example, a simple string search for "3.1415", which is Ï truncated to four digits, will discover values of Ï truncated to more than four digits.

History[edit]
The concept of rounding is very old, perhaps older than the concept of division itself. Some ancient clay tablets found in Mesopotamia contain tables with rounded values of reciprocals and square roots in base 60.[27]
Rounded approximations to Ï, the length of the year, and the length of the month are also ancientâsee base 60 examples.
The round-to-even method has served as the ASTM (E-29) standard since 1940. The origin of the terms unbiased rounding and statistician's rounding are fairly self-explanatory. In the 1906 fourth edition of Probability and Theory of Errors[28] Robert Simpson Woodward called this "the computer's rule" indicating that it was then in common use by human computers who calculated mathematical tables. Churchill Eisenhart indicated the practice was already "well established" in data analysis by the 1940s.[29]
The origin of the term bankers' rounding remains more obscure. If this rounding method was ever a standard in banking, the evidence has proved extremely difficult to find. To the contrary, section 2 of the European Commission report The Introduction of the Euro and the Rounding of Currency Amounts[30] suggests that there had previously been no standard approach to rounding in banking; and it specifies that "half-way" amounts should be rounded up.
Until the 1980s, the rounding method used in floating-point computer arithmetic was usually fixed by the hardware, poorly documented, inconsistent, and different for each brand and model of computer. This situation changed after the IEEE 754 floating-point standard was adopted by most computer manufacturers. The standard allows the user to choose among several rounding modes, and in each case specifies precisely how the results should be rounded. These features made numerical computations more predictable and machine-independent, and made possible the efficient and consistent implementation of interval arithmetic.
Currently, much research tends to round to multiples of 5 or 2. For example, JÃ¶rg Baten used age heaping in many studies, to evaluate the numeracy level of ancient populations. He came up with the ABCC Index, which enables the comparison of the numeracy among regions possible without any historical sources where the population literacy was measured.[31]

Rounding functions in programming languages[edit]
Most programming languages provide functions or special syntax to round fractional numbers in various ways. The earliest numeric languages, such as FORTRAN and C, would provide only one method, usually truncation (toward zero). This default method could be implied in certain contexts, such as when assigning a fractional number to an integer variable, or using a fractional number as an index of an array. Other kinds of rounding had to be programmed explicitly; for example, rounding a positive number to the nearest integer could be implemented by adding 0.5 and truncating.
In the last decades, however, the syntax and the standard libraries of most languages have commonly provided at least the four basic rounding functions (up, down, to nearest, and toward zero). The tie-breaking method may vary depending the language and version or may be selectable by the programmer. Several languages follow the lead of the IEEE 754 floating-point standard, and define these functions as taking a double precision float argument and returning the result of the same type, which then may be converted to an integer if necessary. This approach may avoid spurious overflows because floating-point types have a larger range than integer types. Some languages, such as PHP, provide functions that round a value to a specified number of decimal digits (e.g., from 4321.5678 to 4321.57 or 4300). In addition, many languages provide a printf or similar string formatting function, which allows one to convert a fractional number to a string, rounded to a user-specified number of decimal places (the precision). On the other hand, truncation (round to zero) is still the default rounding method used by many languages, especially for the division of two integer values.
On the opposite, CSS and SVG do not define any specific maximum precision for numbers and measurements, that are treated and exposed in their DOM and in their IDL interface as strings as if they had infinite precision, and do not discriminate between integers and floating-point values; however, the implementations of these languages will typically convert these numbers into IEEE 754 double-precision floating-point values before exposing the computed digits with a limited precision (notably within standard JavaScript or ECMAScript[32] interface bindings).

Other rounding standards[edit]
Some disciplines or institutions have issued standards or directives for rounding.

US weather observations[edit]
In a guideline issued in mid-1966,[33] the U.S. Office of the Federal Coordinator for Meteorology determined that weather data should be rounded to the nearest round number, with the "round half up" tie-breaking rule. For example, 1.5 rounded to integer should become 2, and â1.5 should become â1. Prior to that date, the tie-breaking rule was "round half away from zero".

Negative zero in meteorology[edit]
Main article: Signed zero Â§Â Scientific uses
Some meteorologists may write "â0" to indicate a temperature between 0.0 and â0.5 degrees (exclusive) that was rounded to an integer. This notation is used when the negative sign is considered important, no matter how small is the magnitude; for example, when rounding temperatures in the Celsius scale, where below zero indicates freezing.[citation needed]

See also[edit]
Gal's accurate tables
Interval arithmetic
ISO 80000-1
Kahan summation algorithm
Nearest integer function
Truncation
Signed-digit representation
Party-list proportional representation is an application of rounding to integers that has thoroughly been investigated
Cash rounding, dealing with the absence of extremely low-value coins
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ A case where double rounding always leads to the same value as directly rounding to the final precision is when the radix is odd.


References[edit]


^ Isaiah Lankham, Bruno Nachtergaele, Anne Schilling: Linear Algebra as an Introduction to Abstract Mathematics. World Scientific, Singapur 2016, .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}ISBNÂ 978-981-4730-35-8, p. 186.

^ Kulisch, Ulrich W. (July 1977). "Mathematical foundation of computer arithmetic". IEEE Transactions on Computers. C-26 (7): 610â621. doi:10.1109/TC.1977.1674893. S2CIDÂ 35883481.

^ Higham, Nicholas John (2002). Accuracy and stability of numerical algorithms. p.Â 54. ISBNÂ 978-0-89871-521-7.

^ "java.math.RoundingMode". Oracle.

^ "decimal â Decimal fixed point and floating point arithmetic". Python Software Foundation.

^ Engineering Drafting Standards Manual (NASA), X-673-64-1F, p90

^ Jump up to: a b Gupta, Suyog; Angrawl, Ankur; Gopalakrishnan, Kailash; Narayanan, Pritish (2016-02-09). "Deep Learning with Limited Numerical Precision". p.Â 3. arXiv:1502.02551 [cs.LG].

^ ""Zener Diode Voltage Regulators"" (PDF). Archived from the original (PDF) on 2011-07-13. Retrieved 2010-11-24.

^ 
"Build a Mirror Tester"

^ Bruce Trump, Christine Schneider.
"Excel Formula Calculates Standard 1%-Resistor Values".
Electronic Design, 2002-01-21.
[1]

^ Parker, D. Stott; Eggert, Paul R.; Pierce, Brad (2000-03-28). "Monte Carlo Arithmetic: a framework for the statistical analysis of roundoff errors". IEEE Computation in Science and Engineering.

^ Borman, Phil; Chatfield, Marion (2015-11-10). "Avoid the perils of using rounded data". Journal of Pharmaceutical and Biomedical Analysis. 115: 506â507. doi:10.1016/j.jpba.2015.07.021. PMIDÂ 26299526.

^ Deborah R. Hensler (2000). Class Action Dilemmas: Pursuing Public Goals for Private Gain. RAND. pp.Â 255â293. ISBNÂ 0-8330-2601-1.

^ Samuel A. Figueroa (July 1995). "When is double rounding innocuous?". ACM SIGNUM Newsletter. ACM. 30 (3): 21â25. doi:10.1145/221332.221334. S2CIDÂ 14829295.

^ Roger Golliver (October 1998). "Efficiently producing default orthogonal IEEE double results using extended IEEE hardware" (PDF). Intel.

^ Darcy, Joseph D. "JEP 306: Restore Always-Strict Floating-Point Semantics". Retrieved 2021-09-12.

^ Moore, J. Strother; Lynch, Tom; Kaufmann, Matt (1996). "A mechanically checked proof of the correctness of the kernel of the AMD5K86 floating-point division algorithm" (PDF). IEEE Transactions on Computers. 47. CiteSeerXÂ 10.1.1.43.3309. doi:10.1109/12.713311. Retrieved 2016-08-02.

^ Boldo, Sylvie; Melquiond, Guillaume (2008). "Emulation of a FMA and correctly-rounded sums: proved algorithms using rounding to odd" (PDF). IEEE Transactions on Computers. 57 (4): 462â471. doi:10.1109/TC.2007.70819. S2CIDÂ 1850330. Retrieved 2016-08-02.

^ "21718 â real.c rounding not perfect". gcc.gnu.org.

^ Kahan, William Morton. "A Logarithm Too Clever by Half". Retrieved 2008-11-14.

^ Muller, Jean-Michel; Brisebarre, Nicolas; de Dinechin, Florent; Jeannerod, Claude-Pierre; LefÃ¨vre, Vincent; Melquiond, Guillaume; Revol, Nathalie; StehlÃ©, Damien; Torres, Serge (2010). "Chapter 12: Solving the Table Maker's Dilemma". Handbook of Floating-Point Arithmetic (1Â ed.). BirkhÃ¤user. doi:10.1007/978-0-8176-4705-6. ISBNÂ 978-0-8176-4704-9. LCCNÂ 2009939668.

^ "Accurate Portable Mathematical Library". Archived from the original on 2005-02-07.

^ "libultim â ultimate correctly-rounded elementary-function library".

^ https://sourceware.org/git/?p=glibc.git;a=commit;h=e4d8276142b9c07b23043ef44b0fe8fa7bcc3121

^ "libmcr â correctly-rounded elementary-function library".

^ "CRlibm â Correctly Rounded mathematical library". Archived from the original on 2016-10-27.

^ 
Duncan J. Melville. "YBC 7289 clay tablet". 2006

^ Probability and theory of errors. historical.library.cornell.edu. Mathematical monographs,no. 7. 1906.

^ Churchill Eisenhart (1947). "Effects of Rounding or Grouping Data".  In Eisenhart; Hastay; Wallis (eds.). Selected Techniques of Statistical Analysis for Scientific and Industrial Research, and Production and Management Engineering. New York: McGraw-Hill. pp.Â 187â223. Retrieved 2014-01-30.

^ http://ec.europa.eu/economy_finance/publications/publication1224_en.pdf

^ Baten, JÃ¶rg (2009). "Quantifying Quantitative Literacy: Age Heaping and the History of Human Capital" (PDF). Journal of Economic History. 69 (3): 783â808. doi:10.1017/S0022050709001120. hdl:10230/481. S2CIDÂ 35494384.

^ "ECMA-262 ECMAScript Language Specification" (PDF). ecma-international.org.

^ OFCM, 2005: Federal Meteorological Handbook No. 1 Archived 1999-04-20 at the Wayback Machine, Washington, DC., 104 pp.


External links[edit]
Weisstein, Eric W. "Rounding". MathWorld.
An introduction to different rounding algorithms that is accessible to a general audience but especially useful to those studying computer science and electronics.
How To Implement Custom Rounding Procedures by Microsoft (broken)




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Rounding&oldid=1065081602"
		Categories: ArithmeticComputer arithmeticStatistical data transformationTheory of computationHidden categories: Webarchive template wayback linksArticles with short descriptionShort description is different from WikidataArticles needing additional references from October 2017All articles needing additional referencesUse dmy dates from January 2020All articles with unsourced statementsArticles with unsourced statements from June 2017Articles with unsourced statements from November 2020Wikipedia articles needing clarification from December 2018Articles with unsourced statements from December 2021Wikipedia articles needing clarification from September 2017Articles with unsourced statements from July 2009
	
