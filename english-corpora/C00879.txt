
Title:
Complexity class
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Set of problems in computational complexity theory
  A representation of the relationships between several important complexity classes
In computational complexity theory, a complexity class is a set of computational problems of related resource-based complexity. The two most commonly analyzed resources are time and memory. 
In general, a complexity class is defined in terms of a type of computational problem, a model of computation, and a bounded resource like time or memory. In particular, most complexity classes consist of decision problems that are solvable with a Turing machine, and are differentiated by their time or space (memory) requirements. For instance, the class P is the set of decision problems solvable by a deterministic Turing machine in polynomial time. There are, however, many complexity classes defined in terms of other types of problems (e.g. counting problems and function problems) and using other models of computation (e.g. probabilistic Turing machines, interactive proof systems, Boolean circuits, and quantum computers).
The study of the relationships between complexity classes is a major area of research in theoretical computer science. There are often general hierarchies of complexity classes; for example, it is known that a number of fundamental time and space complexity classes relate to each other in the following way: NLâPâNPâPSPACEâEXPTIMEâEXPSPACE (where â denotes the subset relation). However, many relationships are not yet known; for example, one of the most famous open problems in computer science concerns whether P equals NP. The relationships between classes often answer questions about the fundamental nature of computation. The P versus NP problem, for instance, is directly related to questions of whether nondeterminism adds any computational power to computers and whether problems having a solution that can be quickly checked for correctness can also be quickly solved.

Contents

1 Background

1.1 Computational problems

1.1.1 Decision problems


1.2 Computational models

1.2.1 Deterministic Turing machines
1.2.2 Nondeterministic Turing machines


1.3 Resource bounds

1.3.1 Time bounds
1.3.2 Space bounds




2 Basic complexity classes

2.1 Time complexity classes

2.1.1 P and NP
2.1.2 EXPTIME and NEXPTIME


2.2 Space complexity classes

2.2.1 L and NL
2.2.2 PSPACE and NPSPACE
2.2.3 EXPSPACE and NEXPSPACE




3 Properties of complexity classes

3.1 Closure
3.2 Hardness and completeness


4 Relationships between complexity classes

4.1 Savitch's theorem
4.2 Hierarchy theorems


5 Other models of computation

5.1 Randomized computation

5.1.1 Important complexity classes


5.2 Interactive proof systems

5.2.1 Important complexity classes


5.3 Boolean circuits

5.3.1 Important complexity classes


5.4 Quantum computation


6 Other types of problems

6.1 Counting problems

6.1.1 Important complexity classes


6.2 Function problems
6.3 Promise problems


7 Summary of relationships between complexity classes
8 See also
9 References
10 Bibliography
11 Further reading



Background[edit]
Complexity classes are sets of related computational problems. They are defined in terms of the computational difficulty of solving the problems contained within them with respect to particular computational resources like time or memory. More formally, the definition of a complexity class consists of three things: a type of computational problem, a model of computation, and a bounded computational resource. In particular, most complexity classes consist of decision problems that can be solved by a Turing machine with bounded time or space resources. For example, the complexity class P is defined as the set of decision problems that can be solved by a deterministic Turing machine in polynomial time.

Computational problems[edit]
Intuitively, a computational problem is just a question that a computer is able to answer. For example, "is the natural number 
  
    
      
        n
      
    
    {\displaystyle n}
  
 prime?" is a problem that a computer could solve. A computational problem is mathematically represented as the set of answers to the problem. In the primality example, the problem (call it 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathit {PRIME}}}
  
) is represented by the set of all natural numbers that are prime: 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
        =
        {
        n
        â
        
          N
        
        
          |
        
        n
        
          Â is prime
        
        }
      
    
    {\displaystyle {\mathit {PRIME}}=\{n\in \mathbb {N} |n{\text{ is prime}}\}}
  
. In the theory of computation, these answers are represented as strings; for example, in the primality example the natural numbers could be represented as strings of bits that represent binary numbers. For this reason, computational problems are often synonymously referred to as languages; for example, saying that the 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathit {PRIME}}}
  
 problem is in the complexity class NP is equivalent to saying that the language 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathit {PRIME}}}
  
 is in NP.

Decision problems[edit]
  A decision problem has only two possible outputs, yes or no (or alternately 1 or 0) on any input.
The most commonly analyzed problems in theoretical computer science are decision problemsâthe kinds of problems that can be posed as yes-no questions. The primality example above, for instance, is an example of a decision problem as it can be represented by the yes-no question "is the natural number 
  
    
      
        n
      
    
    {\displaystyle n}
  
 prime". In terms of the theory of computation, a decision problem is represented as the set of input strings that a computer running a correct algorithm would answer "yes" to. In the primality example, 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathit {PRIME}}}
  
 is the set of strings representing natural numbers that, when input into a computer running an algorithm that correctly tests for primality, the algorithm answers "yes, this number is prime". This "yes-no" format is often equivalently stated as "accept-reject"; that is, an algorithm "accepts" an input string if the answer to the decision problem is "yes" and "rejects" if the answer is "no".
While some problems cannot easily be expressed as decision problems, they nonetheless encompass a broad range of computational problems.[1] Other types of problems that certain complexity classes are defined in terms of include function problems (e.g. FP), counting problems (e.g. #P), optimization problems, and promise problems (see section "Other types of problems").

Computational models[edit]
To make concrete the notion of a "computer", in theoretical computer science problems are analyzed in the context of a computational model. This is also directly relevant to making exact notions of computational resources like "time" and "memory". In computational complexity theory, complexity classes deal with the inherent resource requirements of problems and not the resource requirements that depend upon how a physical computer is constructed. For example, in the real world different computers may require different amounts of time and memory to solve the same problem because of the way that they have been engineered. By providing an abstract mathematical representations of computers, computational models abstract away superfluous complexities of the real world (like differences in processor speed) that obstruct an understanding of fundamental principles.
The most commonly used computational model is the Turing machine. While other models exist and many complexity classes are defined in terms of them (see section "Other models of computation"), the Turing machine is used to define most basic complexity classes. With the Turing machine, instead of using standard units of time like the second (which make it impossible to disentangle running time from the speed of physical hardware) and standard units of memory like bytes, the notion of time is abstracted as the number of elementary steps that a Turing machine takes to solve a problem and the notion of memory is abstracted as the number of cells that are used on the machine's tape. These are explained in greater detail below.
It is also possible to use the Blum axioms to define complexity classes without referring to a concrete computational model, but this approach is less frequently used in complexity theory.

Deterministic Turing machines[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Turing machine
  An illustration of a Turing machine. The "B" indicates the blank symbol.
A Turing machine is a mathematical model of a general computing machine. It is the most commonly used model in complexity theory, owing in large part to the fact that it is believed to be as powerful as any other model of computation and is easy to analyze mathematically. Importantly, it is believed that if there exists an algorithm that solves a particular problem then there also exists a Turing machine that solves that same problem (this is known as the ChurchâTuring thesis); this means that it is believed that every algorithm can be represented as a Turing machine.
Mechanically, a Turing machine (TM) manipulates symbols (generally restricted to the bits 0 and 1 to provide an intuitive connection to real-life computers) contained on an infinitely long strip of tape. The TM can read and write, one at a time, using a tape head. Operation is fully determined by a finite set of elementary instructions such as "in state 42, if the symbol seen is 0, write a 1; if the symbol seen is 1, change into state 17; in state 17, if the symbol seen is 0, write a 1 and change to state 6". The Turing machine starts with only the input string on its tape and blanks everywhere else. The TM accepts the input if it enters a designated accept state and rejects the input if it enters a reject state. The deterministic Turing machine (DTM) is the most basic type of Turing machine. It uses a fixed set of rules to determine its future actions (which is why it is called "deterministic").
A computational problem can then be defined in terms of a Turing machine as the set of input strings that a particular Turing machine accepts. For example, the primality problem 
  
    
      
        
          
            P
            R
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathit {PRIME}}}
  
 from above is the set of strings (representing natural numbers) that a Turing machine running an algorithm that correctly tests for primality accepts. A Turing machine is said to recognize a language (recall that "problem" and "language" are largely synonymous in computability and complexity theory) if it accepts all inputs that are in the language and is said to decide a language if it additionally rejects all inputs that are not in the language (certain inputs may cause a Turing machine to run forever, so decidability places the additional constraint over recognizability that the Turing machine must halt on all inputs). A Turing machine that "solves" a problem is generally meant to mean one that decides the language.
Turing machines enable intuitive notions of "time" and "space". The time complexity of a TM on a particular input is the number of elementary steps that the Turing machine takes to reach either an accept or reject state. The space complexity is the number of cells on its tape that it uses to reach either an accept or reject state.

Nondeterministic Turing machines[edit]
Main article: Nondeterministic Turing machine
  A comparison of deterministic and nondeterministic computation. If any branch on the nondeterministic computation accepts then the NTM accepts.
A variant of the deterministic Turing machine (DTM) is the nondeterministic Turing machine (NTM). Intuitively, an NTM is just a regular Turing machine that has the added capability of being able to explore multiple possible future actions from a given state, and "choosing" a branch that accepts (if any accept). That is, while a DTM must follow only one branch of computation, an NTM can be imagined as a computation tree, branching into many possible computational pathways at each step (see image). If at least one branch of the tree halts with an "accept" condition, then the NTM accepts the input. In this way, an NTM can be thought of as simultaneously exploring all computational possibilities in parallel and selecting an accepting branch.[2] NTMs are not meant to be physically realizable models, they are simply theoretically interesting abstract machines that give rise to a number of interesting complexity classes (which often do have physically realizable equivalent definitions). 
The time complexity of an NTM is the maximum number of steps that the NTM uses on any branch of its computation.[3] Similarly, the space complexity of an NTM is the maximum number of cells that the NTM uses on any branch of its computation.
DTMs can be viewed as a special case of NTMs that do not make use of the power of nondeterminism. Hence, every computation that can be carried out by a DTM can also be carried out by an equivalent NTM. It is also possible to simulate any NTM using a DTM. Hence, the two are equivalent in terms of computability. However, simulating an NTM with a DTM often requires greater time and/or memory resources; as will be seen, how significant this slowdown is for certain classes of computational problems is an important question in computational complexity theory.

Resource bounds[edit]
Complexity classes group computational problems by their resource requirements. To do this, computational problems are differentiated by upper bounds on the maximum amount of resources the most efficient algorithm takes to solve them. More particularly, complexity classes are concerned with the rate of growth in resource requirements to solve a computational problem as the input size increases. For example, the amount of time it takes to solve problems in the complexity class P grows relatively slowly as the input size increases, while it grows comparatively quickly for problems in the complexity class EXPTIME (or more accurately, for problems in EXPTIME that are outside of P, since 
  
    
      
        
          
            P
          
        
        â
        
          
            E
            X
            P
            T
            I
            M
            E
          
        
      
    
    {\displaystyle {\mathsf {P}}\subseteq {\mathsf {EXPTIME}}}
  
). This process is formalized using big O notation.
Note that the study of complexity classes is intended primarily to understand the inherent complexity required to solve computational problems. Complexity theorists are thus generally concerned with finding the smallest complexity class that a problem falls into and are therefore concerned with identifying which class a computational problem falls into using the most efficient algorithm. There may be an algorithm, for instance, that solves a particular problem in exponential time, but if the most efficient algorithm for solving this problem runs in polynomial time then the inherent time complexity of that problem is better described as polynomial.

Time bounds[edit]
Main article: Time complexity
The time complexity of an algorithm with respect to the Turing machine model is the number of steps it takes for a Turing machine to run an algorithm on a given input size. Formally, the time complexity for an algorithm implemented with a Turing machine 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is defined as the function 
  
    
      
        
          t
          
            M
          
        
        :
        
          N
        
        â
        
          N
        
      
    
    {\displaystyle t_{M}:\mathbb {N} \to \mathbb {N} }
  
, where 
  
    
      
        
          t
          
            M
          
        
        (
        n
        )
      
    
    {\displaystyle t_{M}(n)}
  
 is the maximum number of steps that 
  
    
      
        M
      
    
    {\displaystyle M}
  
 takes on any input of length 
  
    
      
        n
      
    
    {\displaystyle n}
  
. For example, say the inputs to 
  
    
      
        M
      
    
    {\displaystyle M}
  
 are binary numbers. Then there are, for instance, four inputs of size two: 00, 01, 10, and 11. Say that running 
  
    
      
        M
      
    
    {\displaystyle M}
  
 on 00 takes ten steps, on 01 takes twelve steps, on 10 takes eight steps, and on 11 takes fifteen steps. The runtime 
  
    
      
        
          t
          
            M
          
        
        (
        2
        )
      
    
    {\displaystyle t_{M}(2)}
  
 is the maximum of these four running times: 
  
    
      
        
          t
          
            M
          
        
        (
        2
        )
        =
        15
      
    
    {\displaystyle t_{M}(2)=15}
  
.
However, complexity classes are concerned less with particular runtime values and more with the general class of functions that the time complexity function falls into. For instance, is the time complexity a polynomial? A logarithmic function? An exponential function? Or another kind of function? Since exact time complexity functions are often complicated expressions, they are simplified using big O notation. This leads to the most basic sets of time complexity classes: DTIME and NTIME. They are defined as follows:

The time complexity class 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(t(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle O(t(n))}
  
 time deterministic Turing machine.
The time complexity class 
  
    
      
        
          
            N
            T
            I
            M
            E
          
        
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {NTIME}}(t(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle O(t(n))}
  
 time nondeterministic Turing machine.
For example, if a problem 
  
    
      
        X
      
    
    {\displaystyle X}
  
 can be solved by an algorithm running in time 
  
    
      
        t
        (
        n
        )
        =
        8
        
          n
          
            3
          
        
        +
        2
        n
        +
        4
      
    
    {\displaystyle t(n)=8n^{3}+2n+4}
  
 then it is in 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            3
          
        
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{3})}
  
 since 
  
    
      
        t
        (
        n
        )
        =
        8
        
          n
          
            3
          
        
        +
        2
        n
        +
        4
        =
        O
        (
        
          n
          
            3
          
        
        )
      
    
    {\displaystyle t(n)=8n^{3}+2n+4=O(n^{3})}
  
. Notice that under big O notation it is also the case that 
  
    
      
        8
        
          n
          
            3
          
        
        +
        2
        n
        +
        4
        =
        O
        (
        
          n
          
            4
          
        
        )
      
    
    {\displaystyle 8n^{3}+2n+4=O(n^{4})}
  
, 
  
    
      
        8
        
          n
          
            3
          
        
        +
        2
        n
        +
        4
        =
        O
        (
        
          n
          
            5
          
        
        )
      
    
    {\displaystyle 8n^{3}+2n+4=O(n^{5})}
  
, and so on. This means that DTIME classes are generally not mutually exclusive but rather form a hierarchy: 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            3
          
        
        )
        â
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{3})\subseteq }
  

  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            4
          
        
        )
        â
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{4})\subseteq }
  

  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            5
          
        
        )
        â
        â¯
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{5})\subseteq \cdots }
  
. This hierarchical nature appears frequently among complexity classes.

Space bounds[edit]
Main article: Space complexity
The space complexity of an algorithm with respect to the Turing machine model is the number of cells on the Turing machine's tape that are required to run an algorithm on a given input size. Formally, the space complexity of an algorithm implemented with a Turing machine 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is defined as the function 
  
    
      
        
          s
          
            M
          
        
        :
        
          N
        
        â
        
          N
        
      
    
    {\displaystyle s_{M}:\mathbb {N} \to \mathbb {N} }
  
, where 
  
    
      
        
          s
          
            M
          
        
        (
        n
        )
      
    
    {\displaystyle s_{M}(n)}
  
 is the maximum number of cells that 
  
    
      
        M
      
    
    {\displaystyle M}
  
 uses on any input of length 
  
    
      
        n
      
    
    {\displaystyle n}
  
.
The most basic space complexity classes are defined as follows:

The space complexity class 
  
    
      
        
          
            D
            S
            P
            A
            C
            E
          
        
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {DSPACE}}(s(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle O(s(n))}
  
 space deterministic Turing machine.
The space complexity class 
  
    
      
        
          
            N
            S
            P
            A
            C
            E
          
        
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {NSPACE}}(s(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle O(s(n))}
  
 space nondeterministic Turing machine.
Basic complexity classes[edit]
See also: List of complexity classes
ALL is the class of all decision problems. Many important complexity classes are defined by bounding the time or space used by an algorithm. Several important complexity classes defined in this manner are explained below.

Time complexity classes[edit]
Main article: Time complexity
Recall that the time complexity class 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(t(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle O(t(n))}
  
 time deterministic Turing machine and 
  
    
      
        
          
            N
            T
            I
            M
            E
          
        
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {NTIME}}(t(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle O(t(n))}
  
 time nondeterministic Turing machine. Time complexity classes are often formally defined in terms of these two classes.

P and NP[edit]
Main articles: P (complexity) and NP (complexity)
P is the class of problems that are solvable by a deterministic Turing machine in polynomial time and NP is the class of problems that are solvable by a nondeterministic Turing machine in polynomial time. Or more formally,


  
    
      
        
          
            P
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            k
          
        
        )
      
    
    {\displaystyle {\mathsf {P}}=\bigcup _{k\in \mathbb {N} }{\mathsf {DTIME}}(n^{k})}
  


  
    
      
        
          
            N
            P
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            N
            T
            I
            M
            E
          
        
        (
        
          n
          
            k
          
        
        )
      
    
    {\displaystyle {\mathsf {NP}}=\bigcup _{k\in \mathbb {N} }{\mathsf {NTIME}}(n^{k})}
  

P is often said to be the class of problems that can be solved "quickly" or "efficiently" by a deterministic computer, since the time complexity of solving a problem in P increases relatively slowly with the input size.
An important feature of the class NP is that it can be equivalently defined as the class of problems whose solutions are verifiable by a deterministic Turing machine in polynomial time. That is, a language is in NP if there exists a deterministic polynomial time Turing machine, referred to as the verifier, that takes as input a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 and a certificate string 
  
    
      
        c
      
    
    {\displaystyle c}
  
, and accepts 
  
    
      
        w
      
    
    {\displaystyle w}
  
 if 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is in the language and rejects 
  
    
      
        w
      
    
    {\displaystyle w}
  
 if 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is not in the language. Intuitively, the certificate acts as a proof that the input 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is in the language. Not only does this equivalence highlight a fundamental connection between nondeterminism and solution verifiability, but it also provides a useful method for proving a language is in NPâsimply identify a suitable certificate and show that it can be verified in polynomial time.
While there might seem to be an obvious difference between the class of problems that are efficiently solvable and the class of problems that are merely efficiently checkable, P and NP are actually at the center of one of the most famous unsolved problems in computer science: the P versus NP problem. While it is known that P
  
    
      
        â
      
    
    {\displaystyle \subseteq }
  
NP (intuitively, deterministic Turing machines are just a subclass of nondeterministic Turing machines that don't make use of their nondeterminism; or under the verifier definition, P is the class of problems whose polynomial time verifiers need only receive the empty string as their certificate), it is not known whether NP is strictly larger than P. If P=NP, then it follows that nondeterminism provides no additional computational power over determinism with regards to the ability to quickly find a solution to a problem; that is, being able to explore all possible branches of computation provides at most a polynomial speedup over being able to explore only a single branch. Furthermore, it would follow that if a proof for a problem instance that can quickly be checked for correctness exists (that is, if the problem is in NP), then there also exists an algorithm that can quickly construct that proof (that is, the problem is in P).[4] However, the overwhelming majority of computer scientists believe that P
  
    
      
        â 
      
    
    {\displaystyle \neq }
  
NP,[5] and most cryptographic schemes employed today rely on the assumption that P
  
    
      
        â 
      
    
    {\displaystyle \neq }
  
NP.[6]

EXPTIME and NEXPTIME[edit]
Main articles: EXPTIME and NEXPTIME
EXPTIME is the class of decision problems solvable by a deterministic Turing machine in exponential time and NEXPTIME is the class of decision problems solvable by a nondeterministic Turing machine in exponential time. Or more formally,


  
    
      
        
          
            E
            X
            P
            T
            I
            M
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          2
          
            
              n
              
                k
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {EXPTIME}}=\bigcup _{k\in \mathbb {N} }{\mathsf {DTIME}}(2^{n^{k}})}
  


  
    
      
        
          
            N
            E
            X
            P
            T
            I
            M
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            N
            T
            I
            M
            E
          
        
        (
        
          2
          
            
              n
              
                k
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {NEXPTIME}}=\bigcup _{k\in \mathbb {N} }{\mathsf {NTIME}}(2^{n^{k}})}
  

EXPTIME is a strict superset of P and NEXPTIME is a strict superset of NP. It is further the case that EXPTIME
  
    
      
        â
      
    
    {\displaystyle \subseteq }
  
NEXPTIME. It is not known whether this is proper, but if P=NP then EXPTIME must equal NEXPTIME.

Space complexity classes[edit]
Main article: Space complexity
Recall that the space complexity class 
  
    
      
        
          
            D
            S
            P
            A
            C
            E
          
        
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {DSPACE}}(s(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle O(s(n))}
  
 space deterministic Turing machine and 
  
    
      
        
          
            N
            S
            P
            A
            C
            E
          
        
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {NSPACE}}(s(n))}
  
 is the collection of all problems that are decidable by an 
  
    
      
        O
        (
        s
        (
        n
        )
        )
      
    
    {\displaystyle O(s(n))}
  
 space nondeterministic Turing machine. Space complexity classes are often formally defined in terms of these two classes. 

L and NL[edit]
Main articles: L (complexity) and NL (complexity)
While it is possible to define logarithmic time complexity classes, these are extremely narrow classes as sublinear times do not even enable a Turing machine to read the entire input (because 
  
    
      
        log
        â¡
        n
        <
        n
      
    
    {\displaystyle \log n<n}
  
).[7] However, there are a meaningful number of problems that can be solved in logarithmic space. The definitions of these classes require a two-tape Turing machine so that it is possible for the machine to store the entire input (it can be shown that in terms of computability the two-tape Turing machine is equivalent to the single-tape Turing machine).[8] In the two-tape Turing machine model, one tape is the input tape, which is read-only. The other is the work tape, which allows both reading and writing and is the tape on which the Turing machine performs computations. The space complexity of the Turing machine is measured as the number of cells that are used on the work tape.
L is then defined as the class of problems solvable in logarithmic space on a deterministic Turing machine and NL is the class of problems solvable in logarithmic space on a nondeterministic Turing machine. Or more formally,[9]


  
    
      
        
          
            L
          
        
        =
        
          
            D
            S
            P
            A
            C
            E
          
        
        (
        log
        â¡
        n
        )
      
    
    {\displaystyle {\mathsf {L}}={\mathsf {DSPACE}}(\log n)}
  


  
    
      
        
          
            N
            L
          
        
        =
        
          
            N
            S
            P
            A
            C
            E
          
        
        (
        log
        â¡
        n
        )
      
    
    {\displaystyle {\mathsf {NL}}={\mathsf {NSPACE}}(\log n)}
  

It is known that 
  
    
      
        
          
            L
          
        
        â
        
          
            N
            L
          
        
        â
        
          
            P
          
        
      
    
    {\displaystyle {\mathsf {L}}\subseteq {\mathsf {NL}}\subseteq {\mathsf {P}}}
  
. However, it is not known whether any of these relationships is proper.

PSPACE and NPSPACE[edit]
Main article: PSPACE (complexity)
The complexity classes PSPACE and NPSPACE are the space analogues to  P and  NP. That is, PSPACE is the class of problems solvable in polynomial space by a deterministic Turing machine and NPSPACE is the class of problems solvable in polynomial space by a nondeterministic Turing machine. More formally,


  
    
      
        
          
            P
            S
            P
            A
            C
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            D
            S
            P
            A
            C
            E
          
        
        (
        
          n
          
            k
          
        
        )
      
    
    {\displaystyle {\mathsf {PSPACE}}=\bigcup _{k\in \mathbb {N} }{\mathsf {DSPACE}}(n^{k})}
  


  
    
      
        
          
            N
            P
            S
            P
            A
            C
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            N
            S
            P
            A
            C
            E
          
        
        (
        
          n
          
            k
          
        
        )
      
    
    {\displaystyle {\mathsf {NPSPACE}}=\bigcup _{k\in \mathbb {N} }{\mathsf {NSPACE}}(n^{k})}
  

While it is not known whether P=NP, Savitch's theorem  famously showed that PSPACE=NPSPACE. It is also known that P
  
    
      
        â
      
    
    {\displaystyle \subseteq }
  
PSPACE, which follows intuitively from the fact that, since writing to a cell on a Turing machine's tape is defined as taking one unit of time, a Turing machine operating in polynomial time can only write to polynomially many cells. It is suspected that P is strictly smaller than PSPACE, but this has not been proven.

EXPSPACE and NEXPSPACE[edit]
Main article: EXPSPACE
The complexity classes EXPSPACE and NEXPSPACE are the space analogues to EXPTIME and NEXPTIME. That is, EXPSPACE is the class of problems solvable in exponential space by a deterministic Turing machine and NEXPSPACE is the class of problems solvable in exponential space by a nondeterministic Turing machine. Or more formally,


  
    
      
        
          
            E
            X
            P
            S
            P
            A
            C
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            D
            S
            P
            A
            C
            E
          
        
        (
        
          2
          
            
              n
              
                k
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {EXPSPACE}}=\bigcup _{k\in \mathbb {N} }{\mathsf {DSPACE}}(2^{n^{k}})}
  


  
    
      
        
          
            N
            E
            X
            P
            S
            P
            A
            C
            E
          
        
        =
        
          â
          
            k
            â
            
              N
            
          
        
        
          
            N
            S
            P
            A
            C
            E
          
        
        (
        
          2
          
            
              n
              
                k
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {NEXPSPACE}}=\bigcup _{k\in \mathbb {N} }{\mathsf {NSPACE}}(2^{n^{k}})}
  

Savitch's theorem establishes that EXPSPACE=NEXPSPACE. This class is extremely broad: it is known to be a strict superset of PSPACE, NP, and P, and is believed to be a strict superset of EXPTIME.

Properties of complexity classes[edit]
Closure[edit]
Complexity classes have a variety of closure properties. For example, decision classes may be closed under negation, disjunction, conjunction, or even under all Boolean operations. Moreover, they might also be closed under a variety of quantification schemes. P, for instance, is closed under all Boolean operations, and under quantification over polynomially sized domains (though likely not closed over exponential sized domains). Closure properties can be helpful in separating classesâone possible route to separating two complexity classes is to find some closure property possessed by one and not by the other.
Each class X that is not closed under negation has a complement class co-X, which consists of the complements of the languages contained in X. Similarly, one can define the Boolean closure of a class, and so on; this is, however, less commonly done.
Closure properties are one of the key reasons many complexity classes are defined in the way that they are.[10] Take, for example, a problem that can be solved in 
  
    
      
        t
        (
        n
        )
        =
        n
      
    
    {\displaystyle t(n)=n}
  
 time (that is, in linear time) and one that can be solved in, at best, 
  
    
      
        t
        (
        n
        )
        =
        
          n
          
            1000
          
        
      
    
    {\displaystyle t(n)=n^{1000}}
  
 time. Both of these problems are in P, yet the runtime of the second grows considerably faster than the runtime of the first as the input size increases. One might ask whether it would be better to define the class of "efficiently solvable" problems using some smaller polynomial bound, like 
  
    
      
        
          n
          
            2
          
        
      
    
    {\displaystyle n^{2}}
  
, rather than all polynomials, which allows for such large discrepancies. It turns out, however, that the polynomials are the smallest class of functions containing the linear functions that are closed under addition, multiplication, and composition.[10] This means that the polynomials are the smallest class that enables the composition of "efficient algorithms"; that is, a polynomial-time algorithm that calls a polynomial-time subroutine still yields a polynomial-time algorithm.[11] If the 
  
    
      
        
          n
          
            2
          
        
      
    
    {\displaystyle n^{2}}
  
 bound were utilized, however, then composing a constant number of "efficient" algorithms might result in a new algorithm that is not "efficient". (Note that the definition of P is also useful because, empirically, almost all problems in P that are practically useful do in fact have low order polynomial runtimes, and almost all problems outside of P that are practically useful do not have any known algorithms with small exponential runtimes, i.e. with 
  
    
      
        O
        (
        
          c
          
            n
          
        
        )
      
    
    {\displaystyle O(c^{n})}
  
 runtimes where 
  
    
      
        c
      
    
    {\displaystyle c}
  
 is close to 1.[12])

Hardness and completeness[edit]
See also: Reduction (complexity)
Many complexity classes are defined using the concept of a reduction. A reduction is a transformation of one problem into another problem. It captures the informal notion of a problem being at least as difficult as another problem. For instance, if a problem 
  
    
      
        X
      
    
    {\displaystyle X}
  
 can be solved using an algorithm for 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
, 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is no more difficult than 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
, and we say that 
  
    
      
        X
      
    
    {\displaystyle X}
  
 reduces to 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
. There are many different types of reductions, based on the method of reduction, such as Cook reductions, Karp reductions and Levin reductions, and the bound on the complexity of reductions, such as polynomial-time reductions or log-space reductions.
The most commonly used reduction is a polynomial-time reduction. This means that the reduction process takes polynomial time. For example, the problem of squaring an integer can be reduced to the problem of multiplying two integers. This means an algorithm for multiplying two integers can be used to square an integer. Indeed, this can be done by giving the same input to both inputs of the multiplication algorithm. Thus we see that squaring is not more difficult than multiplication, since squaring can be reduced to multiplication.
This motivates the concept of a problem being hard for a complexity class. A problem 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is hard for a class of problems C if every problem in C can be reduced to 
  
    
      
        X
      
    
    {\displaystyle X}
  
. Thus no problem in C is harder than 
  
    
      
        X
      
    
    {\displaystyle X}
  
, since an algorithm for 
  
    
      
        X
      
    
    {\displaystyle X}
  
 allows us to solve any problem in C. Of course, the notion of hard problems depends on the type of reduction being used. For complexity classes larger than P, polynomial-time reductions are commonly used. In particular, the set of problems that are hard for NP is the set of NP-hard problems.
If a problem 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is in C and is hard for C, then 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is said to be complete for C. This means that 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is the hardest problem in C (since there could be many problems that are equally hard, one might say that 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is as hard as the hardest problems in C). Thus the class of NP-complete problems contains the most difficult problems in NP, in the sense that they are the ones most likely not to be in P. Because the problem PÂ =Â NP is not solved, being able to reduce a known NP-complete problem, Î 2, to another problem, Î 1, would indicate that there is no known polynomial-time solution for Î 1.  This is because a polynomial-time solution to Î 1 would yield a polynomial-time solution to Î 2. Similarly, because all NP problems can be reduced to the set, finding an NP-complete problem that can be solved in polynomial time would mean that PÂ =Â NP.

Relationships between complexity classes[edit]
Savitch's theorem[edit]
Main article: Savitch's theorem
Savitch's theorem establishes that PSPACE = NPSPACE and EXPSPACE = NEXPSPACE. One central question of complexity theory is whether nondeterminism adds significant power to a computational model. This is central to the open P versus NP problem in the context of time. Savitch's theorem shows that for space, nondeterminism does not add significantly more power, where "significant" means the difference between polynomial and superpolynomial resource requirements (or, for EXPSPACE, the difference between exponential and superexponential). For example, Savitch's theorem proves that no problem that requires exponential space for a deterministic Turing machine can be solved by a nondeterministic polynomial space Turing machine.

Hierarchy theorems[edit]
Main articles: Time hierarchy theorem and Space hierarchy theorem
By definition of DTIME, it follows that 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            
              k
              
                1
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{k_{1}})}
  
 is contained in 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        
          n
          
            
              k
              
                2
              
            
          
        
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(n^{k_{2}})}
  
 if 
  
    
      
        
          k
          
            1
          
        
        â¤
        
          k
          
            2
          
        
      
    
    {\displaystyle k_{1}\leq k_{2}}
  
, since 
  
    
      
        O
        (
        
          n
          
            
              k
              
                1
              
            
          
        
        )
        â
        O
        (
        
          n
          
            
              k
              
                2
              
            
          
        
        )
      
    
    {\displaystyle O(n^{k_{1}})\subseteq O(n^{k_{2}})}
  
 if 
  
    
      
        
          k
          
            1
          
        
        â¤
        
          k
          
            2
          
        
      
    
    {\displaystyle k_{1}\leq k_{2}}
  
. However, this definition gives no indication of whether this inclusion is strict. For time and space requirements, the conditions under which the inclusion is strict are given by the time and space hierarchy theorems, respectively. They are called hierarchy theorems because they induce a proper hierarchy on the classes defined by constraining the respective resources. The hierarchy theorems enable one to make quantitative statements about how much more additional time or space is needed in order to increase the number of problems that can be solved.
The time hierarchy theorem states that


  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        
          
            (
          
        
        f
        (
        n
        )
        
          
            )
          
        
        â
        
          
            D
            T
            I
            M
            E
          
        
        
          
            (
          
        
        f
        (
        n
        )
        â
        
          log
          
            2
          
        
        â¡
        (
        f
        (
        n
        )
        )
        
          
            )
          
        
      
    
    {\displaystyle {\mathsf {DTIME}}{\big (}f(n){\big )}\subsetneq {\mathsf {DTIME}}{\big (}f(n)\cdot \log ^{2}(f(n)){\big )}}
  
.
The space hierarchy theorem states that


  
    
      
        
          
            D
            S
            P
            A
            C
            E
          
        
        
          
            (
          
        
        f
        (
        n
        )
        
          
            )
          
        
        â
        
          
            D
            S
            P
            A
            C
            E
          
        
        
          
            (
          
        
        f
        (
        n
        )
        â
        log
        â¡
        (
        f
        (
        n
        )
        )
        
          
            )
          
        
      
    
    {\displaystyle {\mathsf {DSPACE}}{\big (}f(n){\big )}\subsetneq {\mathsf {DSPACE}}{\big (}f(n)\cdot \log(f(n)){\big )}}
  
.
The time and space hierarchy theorems form the basis for most separation results of complexity classes. For instance, the time hierarchy theorem establishes that P is strictly contained in EXPTIME, and the space hierarchy theorem establishes that L is strictly contained in PSPACE.

Other models of computation[edit]
While deterministic and non-deterministic Turing machines are the most commonly used models of computation, many complexity classes are defined in terms of other computational models. In particular,

A number of classes are defined using probabilistic Turing machines, including the classes BPP, PP, RP, and ZPP
A number of classes are defined using interactive proof systems, including the classes IP, MA, and AM
A number of classes are defined using Boolean circuits, including the classes P/poly and its subclasses NC and AC
A number of classes are defined using quantum Turing machines, including the classes BQP and QMA
These are explained in greater detail below.

Randomized computation[edit]
Main article: Randomized computation
A number of important complexity classes are defined using the probabilistic Turing machine, a variant of the Turing machine that can toss random coins. These classes help to better describe the complexity of randomized algorithms.
A probabilistic Turing machine is similar to a deterministic Turing machine, except rather than following a single transition function (a set of rules for how to proceed at each step of the computation) it probabilistically selects between multiple transition functions at each step. The standard definition of a probabilistic Turing machine specifies two transition functions, so that the selection of transition function at each step resembles a coin flip. The randomness introduced at each step of the computation introduces the potential for error; that is, strings that the Turing machine is meant to accept may on some occasions be rejected and strings that the Turing machine is meant to reject may on some occasions be accepted. As a result, the complexity classes based on the probabilistic Turing machine are defined in large part around the amount of error that is allowed. Formally, they are defined using an error probability 
  
    
      
        Ïµ
      
    
    {\displaystyle \epsilon }
  
. A probabilistic Turing machine 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is said to recognize a language 
  
    
      
        L
      
    
    {\displaystyle L}
  
 with error probability 
  
    
      
        Ïµ
      
    
    {\displaystyle \epsilon }
  
 if:

a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 in 
  
    
      
        L
      
    
    {\displaystyle L}
  
 implies that 
  
    
      
        
          Pr
        
        [
        M
        
          Â acceptsÂ 
        
        w
        ]
        â¥
        1
        â
        Ïµ
      
    
    {\displaystyle {\text{Pr}}[M{\text{ accepts }}w]\geq 1-\epsilon }
  

a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 not in 
  
    
      
        L
      
    
    {\displaystyle L}
  
 implies that 
  
    
      
        
          Pr
        
        [
        M
        
          Â rejectsÂ 
        
        w
        ]
        â¥
        1
        â
        Ïµ
      
    
    {\displaystyle {\text{Pr}}[M{\text{ rejects }}w]\geq 1-\epsilon }
  

Important complexity classes[edit]
  The relationships between the fundamental probabilistic complexity classes. BQP is a probabilistic quantum complexity class and is described in the quantum computing section.
The fundamental randomized time complexity classes are ZPP, RP, co-RP, BPP, and PP.
The strictest class is ZPP (zero-error probabilistic polynomial time), the class of problems solvable in polynomial time by a probabilistic Turing machine with error probability 0. Intuitively, this is the strictest class of probabilistic problems because it demands no error whatsoever. 
A slightly looser class is RP (randomized polynomial time), which maintains no error for strings not in the language but allows bounded error for strings in the language. More formally, a language is in RP if there is a probabilistic polynomial-time Turing machine 
  
    
      
        M
      
    
    {\displaystyle M}
  
 such that if a string is not in the language then 
  
    
      
        M
      
    
    {\displaystyle M}
  
 always rejects and if a string is in the language then 
  
    
      
        M
      
    
    {\displaystyle M}
  
 accepts with a probability at least 1/2. The class co-RP is similarly defined except the roles are flipped: error is not allowed for strings in the language but is allowed for strings not in the language. Taken together, the classes RP and co-RP encompass all of the problems that can be solved by probabilistic Turing machines with one-sided error. 
Loosening the error requirements further to allow for two-sided error yields the class BPP (bounded-error probabilistic polynomial time), the class of problems solvable in polynomial time by a probabilistic Turing machine with error probability less than 1/3 (for both strings in the language and not in the language). BPP is the most practically relevant of the probabilistic complexity classesâproblems in BPP have efficient randomized algorithms that can be run quickly on real computers. BPP is also at the center of the important unsolved problem in computer science over whether P=BPP, which if true would mean that randomness does not increase the computational power of computers, i.e. any probabilistic Turing machine could be simulated by a deterministic Turing machine with at most polynomial slowdown. 
The broadest class of efficiently-solvable probabilistic problems is PP (probabilistic polynomial time), the set of languages solvable by a probabilistic Turing machine in polynomial time with an error probability of less than 1/2 for all strings.
ZPP, RP and co-RP are all subsets of BPP, which in turn is a subset of PP. The reason for this is intuitive: the classes allowing zero error and only one-sided error are all contained within the class that allows two-sided error, and PP simply relaxes the error probability of BPP. ZPP relates to RP and co-RP in the following way: 
  
    
      
        
          
            ZPP
          
        
        =
        
          
            RP
          
        
        â©
        
          
            co-RP
          
        
      
    
    {\displaystyle {\textsf {ZPP}}={\textsf {RP}}\cap {\textsf {co-RP}}}
  
. That is, ZPP consists exactly of those problems that are in both RP and co-RP. Intuitively, this follows from the fact that RP and co-RP allow only one-sided error: co-RP does not allow error for strings in the language and RP does not allow error for strings not in the language. Hence, if a problem is in both RP and co-RP, then there must be no error for strings both in and not in the language (i.e. no error whatsoever), which is exactly the definition of ZPP. 
Important randomized space complexity classes include BPL, RL, and RLP.

Interactive proof systems[edit]
Main article: Interactive proof system
A number of complexity classes are defined using interactive proof systems. Interactive proofs generalize the proofs definition of the complexity class NP and yield insights into cryptography, approximation algorithms, and formal verification.

  General representation of an interactive proof protocol
Interactive proof systems are abstract machines that model computation as the exchange of messages between two parties: a prover 
  
    
      
        P
      
    
    {\displaystyle P}
  
 and a verifier 
  
    
      
        V
      
    
    {\displaystyle V}
  
. The parties interact by exchanging messages, and an input string is accepted by the system if the verifier decides to accept the input on the basis of the messages it has received from the prover. The prover 
  
    
      
        P
      
    
    {\displaystyle P}
  
 has unlimited computational power while the verifier has bounded computational power (the standard definition of interactive proof systems defines the verifier to be polynomially-time bounded). The prover, however, is untrustworthy (this prevents all languages from being trivially recognized by the proof system by having the computationally unbounded prover solve for whether a string is in a language and then sending a trustworthy "YES" or "NO" to the verifier), so the verifier must conduct an "interrogation" of the prover by "asking it" successive rounds of questions, accepting only if it develops a high degree of confidence that the string is in the language.[13]

Important complexity classes[edit]
The class NP is a simple proof system in which the verifier is restricted to being a deterministic polynomial-time Turing machine and the procedure is restricted to one round (that is, the prover sends only a single, full proofâtypically referred to as the certificateâto the verifier). Put another way, in the definition of the class NP (the set of decision problems for which the problem instances, when the answer is "YES", have proofs verifiable in polynomial time by a deterministic Turing machine) is a proof system in which the proof is constructed by an unmentioned prover and the deterministic Turing machine is the verifier. For this reason, NP can also be called dIP (deterministic interactive proof), though it is rarely referred to as such.
It turns out that NP captures the full power of interactive proof systems with deterministic (polynomial-time) verifiers because it can be shown that for any proof system with a deterministic verifier it is never necessary to need more than a single round of messaging between the prover and the verifier. Interactive proof systems that provide greater computational power over standard complexity classes thus require probabilistic verifiers, which means that the verifier's questions to the prover are computed using probabilistic algorithms. As noted in the section above on randomized computation, probabilistic algorithms introduce error into the system, so complexity classes based on probabilistic proof systems are defined in terms of an error probability 
  
    
      
        Ïµ
      
    
    {\displaystyle \epsilon }
  
. 
The most general complexity class arising out of this characterization is the class IP (interactive polynomial time), which is the class of all problems solvable by an interactive proof system 
  
    
      
        (
        P
        ,
        V
        )
      
    
    {\displaystyle (P,V)}
  
, where 
  
    
      
        V
      
    
    {\displaystyle V}
  
 is probabilistic polynomial-time and the proof system satisfies two properties: for a language 
  
    
      
        L
        â
        
          
            I
            P
          
        
      
    
    {\displaystyle L\in {\mathsf {IP}}}
  


(Completeness) a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 in 
  
    
      
        L
      
    
    {\displaystyle L}
  
 implies 
  
    
      
        Pr
        [
        V
        
          Â acceptsÂ 
        
        w
        
          Â after interacting withÂ 
        
        P
        ]
        â¥
        
          
            
              2
              3
            
          
        
      
    
    {\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\geq {\tfrac {2}{3}}}
  

(Soundness) a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 not in 
  
    
      
        L
      
    
    {\displaystyle L}
  
 implies 
  
    
      
        Pr
        [
        V
        
          Â acceptsÂ 
        
        w
        
          Â after interacting withÂ 
        
        P
        ]
        â¤
        
          
            
              1
              3
            
          
        
      
    
    {\displaystyle \Pr[V{\text{ accepts }}w{\text{ after interacting with }}P]\leq {\tfrac {1}{3}}}
  

An important feature of IP is that it equals PSPACE. In other words, any problem that can be solved by a polynomial-time interactive proof system can also be solved by a deterministic Turing machine with polynomial space resources, and vice versa.
A modification of the protocol for IP produces another important complexity class: AM (ArthurâMerlin protocol). In the definition of interactive proof systems used by IP, the prover was not able to see the coins utilized by the verifier in its probabilistic computationâit was only able to see the messages that the verifier produced with these coins. For this reason, the coins are called private random coins. The interactive proof system can be constrained so that the coins used by the verifier are public random coins; that is, the prover is able to see the coins. Formally, AM is defined as the class of languages with an interactive proof in which the verifier sends a random string to the prover, the prover responds with a message, and the verifier either accepts or rejects by applying a deterministic polynomial-time function to the message from the prover. AM can be generalized to AM[k], where k is the number of messages exchanged (so in the generalized form the standard AM defined above is AM[2]). However, it is the case that for all 
  
    
      
        k
        â¥
        2
      
    
    {\displaystyle k\geq 2}
  
, AM[k]=AM[2]. It is also the case that 
  
    
      
        
          
            A
            M
          
        
        [
        k
        ]
        â
        
          
            I
            P
          
        
        [
        k
        ]
      
    
    {\displaystyle {\mathsf {AM}}[k]\subseteq {\mathsf {IP}}[k]}
  
.
Other complexity classes defined using interactive proof systems include MIP (multiprover interactive polynomial time) and QIP (quantum interactive polynomial time).

Boolean circuits[edit]
Main article: Circuit complexity
  Example Boolean circuit computing the Boolean function 
  
    
      
        
          f
          
            C
          
        
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        
          x
          
            3
          
        
        )
        =
        Â¬
        (
        
          x
          
            1
          
        
        â§
        
          x
          
            2
          
        
        )
        â§
        (
        (
        
          x
          
            2
          
        
        â§
        
          x
          
            3
          
        
        )
        â¨
        Â¬
        
          x
          
            3
          
        
        )
      
    
    {\displaystyle f_{C}(x_{1},x_{2},x_{3})=\neg (x_{1}\wedge x_{2})\wedge ((x_{2}\wedge x_{3})\vee \neg x_{3})}
  
, with example input 
  
    
      
        
          x
          
            1
          
        
        =
        0
      
    
    {\displaystyle x_{1}=0}
  
, 
  
    
      
        
          x
          
            2
          
        
        =
        1
      
    
    {\displaystyle x_{2}=1}
  
, and 
  
    
      
        
          x
          
            3
          
        
        =
        0
      
    
    {\displaystyle x_{3}=0}
  
. The 
  
    
      
        â§
      
    
    {\displaystyle \wedge }
  
 nodes are AND gates, the 
  
    
      
        â¨
      
    
    {\displaystyle \vee }
  
 nodes are OR gates, and the 
  
    
      
        Â¬
      
    
    {\displaystyle \neg }
  
 nodes are NOT gates.
An alternative model of computation to the Turing machine is the Boolean circuit, a simplified model of the digital circuits used in modern computers. Not only does this model provide an intuitive connection between computation in theory and computation in practice, but it is also a natural model for non-uniform computation (computation in which different input sizes within the same problem use different algorithms).
Formally, a Boolean circuit 
  
    
      
        C
      
    
    {\displaystyle C}
  
 is a directed acyclic graph in which edges represent wires (which carry the bit values 0 and 1), the input bits are represented by source vertices (vertices with no incoming edges), and all non-source vertices represent logic gates (generally the AND, OR, and NOT gates). One logic gate is designated the output gate, and represents the end of the computation. The input/output behavior of a circuit 
  
    
      
        C
      
    
    {\displaystyle C}
  
 with 
  
    
      
        n
      
    
    {\displaystyle n}
  
 input variables is represented by the Boolean function 
  
    
      
        
          f
          
            C
          
        
        :
        {
        0
        ,
        1
        
          }
          
            n
          
        
        â
        {
        0
        ,
        1
        }
      
    
    {\displaystyle f_{C}:\{0,1\}^{n}\to \{0,1\}}
  
; for example, on input bits 
  
    
      
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
      
    
    {\displaystyle x_{1},x_{2},...,x_{n}}
  
, the output bit 
  
    
      
        b
      
    
    {\displaystyle b}
  
 of the circuit is represented mathematically as 
  
    
      
        b
        =
        
          f
          
            C
          
        
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle b=f_{C}(x_{1},x_{2},...,x_{n})}
  
. The circuit 
  
    
      
        C
      
    
    {\displaystyle C}
  
 is said to compute the Boolean function 
  
    
      
        
          f
          
            C
          
        
      
    
    {\displaystyle f_{C}}
  
.
Any particular circuit has a fixed number of input vertices, so it can only act on inputs of that size. Languages (the formal representations of decision problems), however, contain strings of differing lengths, so languages cannot be fully captured by a single circuit (this contrasts with the Turing machine model, in which a language is fully described by a single Turing machine that can act on any input size). A language is thus represented by a circuit family. A circuit family is an infinite list of circuits 
  
    
      
        (
        
          C
          
            0
          
        
        ,
        
          C
          
            1
          
        
        ,
        
          C
          
            2
          
        
        ,
        .
        .
        .
        )
      
    
    {\displaystyle (C_{0},C_{1},C_{2},...)}
  
, where 
  
    
      
        
          C
          
            n
          
        
      
    
    {\displaystyle C_{n}}
  
 is a circuit with 
  
    
      
        n
      
    
    {\displaystyle n}
  
 input variables. A circuit family is said to decide a language 
  
    
      
        L
      
    
    {\displaystyle L}
  
 if, for every string 
  
    
      
        w
      
    
    {\displaystyle w}
  
, 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is in the language 
  
    
      
        L
      
    
    {\displaystyle L}
  
 if and only if 
  
    
      
        
          C
          
            n
          
        
        (
        w
        )
        =
        1
      
    
    {\displaystyle C_{n}(w)=1}
  
, where 
  
    
      
        n
      
    
    {\displaystyle n}
  
 is the length of 
  
    
      
        w
      
    
    {\displaystyle w}
  
. In other words, a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 of size 
  
    
      
        n
      
    
    {\displaystyle n}
  
 is in the language represented by the circuit family 
  
    
      
        (
        
          C
          
            0
          
        
        ,
        
          C
          
            1
          
        
        ,
        
          C
          
            2
          
        
        ,
        .
        .
        .
        )
      
    
    {\displaystyle (C_{0},C_{1},C_{2},...)}
  
 if the circuit 
  
    
      
        
          C
          
            n
          
        
      
    
    {\displaystyle C_{n}}
  
 (the circuit with the same number of input vertices as the number of characters in 
  
    
      
        w
      
    
    {\displaystyle w}
  
) evaluates to 1 when 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is its input.
While complexity classes defined using Turing machines are described in terms of time complexity, circuit complexity classes are defined in terms of circuit size â the number of vertices in the circuit. The size complexity of a circuit family 
  
    
      
        (
        
          C
          
            0
          
        
        ,
        
          C
          
            1
          
        
        ,
        
          C
          
            2
          
        
        ,
        .
        .
        .
        )
      
    
    {\displaystyle (C_{0},C_{1},C_{2},...)}
  
 is the function 
  
    
      
        f
        :
        
          N
        
        â
        
          N
        
      
    
    {\displaystyle f:\mathbb {N} \to \mathbb {N} }
  
, where 
  
    
      
        f
        (
        n
        )
      
    
    {\displaystyle f(n)}
  
 is the circuit size of 
  
    
      
        
          C
          
            n
          
        
      
    
    {\displaystyle C_{n}}
  
. The familiar function classes follow naturally from this; for example, a polynomial-size circuit family is one such that the function 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is a polynomial.

Important complexity classes[edit]
The complexity class P/poly is the set of languages that are decidable by polynomial-size circuit families. It turns out that there is a natural connection between circuit complexity and time complexity. Intuitively, a language with small time complexity (that is, requires relatively few sequential operations on a Turing machine), also has a small circuit complexity (that is, requires relatively few Boolean operations). Formally, it can be shown that if a language is in 
  
    
      
        
          
            D
            T
            I
            M
            E
          
        
        (
        t
        (
        n
        )
        )
      
    
    {\displaystyle {\mathsf {DTIME}}(t(n))}
  
, where 
  
    
      
        t
      
    
    {\displaystyle t}
  
 is a function 
  
    
      
        t
        :
        
          N
        
        â
        
          N
        
      
    
    {\displaystyle t:\mathbb {N} \to \mathbb {N} }
  
, then it has circuit complexity 
  
    
      
        O
        (
        
          t
          
            2
          
        
        (
        n
        )
        )
      
    
    {\displaystyle O(t^{2}(n))}
  
.[14] It follows directly from this fact that 
  
    
      
        
          
            
              P
            
          
        
        â
        
          
            P/poly
          
        
      
    
    {\displaystyle {\mathsf {\color {Blue}P}}\subset {\textsf {P/poly}}}
  
. In other words, any problem that can be solved in polynomial time by a deterministic Turing machine can also be solved by a polynomial-size circuit family. It is further the case that the inclusion is proper, i.e. 
  
    
      
        
          
            P
          
        
        â
        
          
            P/poly
          
        
      
    
    {\displaystyle {\textsf {P}}\subsetneq {\textsf {P/poly}}}
  
 (for example, there are some undecidable problems that are in P/poly).
P/poly has a number of properties that make it highly useful in the study of the relationships between complexity classes. In particular, it is helpful in investigating problems related to P versus NP. For example, if there is any language in NP that is not in P/poly, then 
  
    
      
        
          
            P
          
        
        â 
        
          
            N
            P
          
        
      
    
    {\displaystyle {\mathsf {P}}\neq {\mathsf {NP}}}
  
.[15] P/poly is also helpful in investigating properties of the polynomial hierarchy. For example, if NP â P/poly, then PH collapses to 
  
    
      
        
          Î£
          
            2
          
          
            
              P
            
          
        
      
    
    {\displaystyle \Sigma _{2}^{\mathsf {P}}}
  
. A full description of the relations between P/poly and other complexity classes is available at "Importance of P/poly". P/poly is also helpful in the general study of the properties of Turing machines, as the class can be equivalently defined as the class of languages recognized by a polynomial-time Turing machine with a polynomial-bounded advice function.
Two subclasses of P/poly that have interesting properties in their own right are NC and AC. These classes are defined not only in terms of their circuit size but also in terms of their depth. The depth of a circuit is the length of the longest directed path from an input node to the output node. The class NC is the set of languages that can be solved by circuit families that are restricted not only to having polynomial-size but also to having polylogarithmic depth. The class AC is defined similarly to NC, however gates are allowed to have unbounded fan-in (that is, the AND and OR gates can be applied to more than two bits). NC is a notable class because it can be equivalently defined as the class of languages that have efficient parallel algorithms.

Quantum computation[edit]
This section needs expansion. You can help by adding to it.  (April 2017)
The classes BQP and QMA, which are of key importance in quantum information science, are defined using quantum Turing machines.

Other types of problems[edit]
While most complexity classes are sets of decision problems, there are also a number of complexity classes defined in terms of other types of problems. In particular, there are complexity classes consisting of counting problems, function problems, and promise problems. These are explained in greater detail below.

Counting problems[edit]
Main article: Counting problem (complexity)
A counting problem asks not only whether a solution exists (as with a decision problem), but asks how many solutions exist.[16] For example, the decision problem 
  
    
      
        C
        Y
        C
        L
        E
      
    
    {\displaystyle CYCLE}
  
 asks whether a particular graph 
  
    
      
        G
      
    
    {\displaystyle G}
  
 has a simple cycle (the answer is a simple yes/no); the corresponding counting problem 
  
    
      
        
          
            #
            C
            Y
            C
            L
            E
          
        
      
    
    {\displaystyle {\mathit {\#CYCLE}}}
  
 (pronounced "sharp cycle") asks how many simple cycles 
  
    
      
        G
      
    
    {\displaystyle G}
  
 has.[17] The output to a counting problem is thus a number, in contrast to the output for a decision problem, which is a simple yes/no (or accept/reject, 0/1, or other equivalent scheme).[18] So whereas decision problems are represented mathematically as formal languages, counting problems are represented mathematically as functions: a counting problem is formalized as the function 
  
    
      
        f
        :
        {
        0
        ,
        1
        
          }
          
            â
          
        
        â
        
          N
        
      
    
    {\displaystyle f:\{0,1\}^{*}\to \mathbb {N} }
  
 such that for an input 
  
    
      
        w
        â
        {
        0
        ,
        1
        
          }
          
            â
          
        
      
    
    {\displaystyle w\in \{0,1\}^{*}}
  
, 
  
    
      
        f
        (
        w
        )
      
    
    {\displaystyle f(w)}
  
 is the number of solutions. For example, in the 
  
    
      
        C
        Y
        C
        L
        E
      
    
    {\displaystyle CYCLE}
  
 problem, the input is a graph 
  
    
      
        G
      
    
    {\displaystyle G}
  
 (represented as a string of bits) and 
  
    
      
        f
        (
        G
        )
      
    
    {\displaystyle f(G)}
  
 is the number of simple cycles in 
  
    
      
        G
      
    
    {\displaystyle G}
  
. 
Counting problems arise in a number of fields, including statistical estimation, statistical physics, network design, and economics.[19]

Important complexity classes[edit]
Main article: â¯P
#P (pronounced "sharp P") is an important class of counting problems that can be thought of as the counting version of NP.[16] The connection to NP arises from the fact that the number of solutions to a problem equals the number of accepting branches in a nondeterministic Turing machine's computation tree. #P is thus formally defined as follows:

#P is the set of all functions 
  
    
      
        f
        :
        {
        0
        ,
        1
        
          }
          
            â
          
        
        â
        
          N
        
      
    
    {\displaystyle f:\{0,1\}^{*}\to \mathbb {N} }
  
 such that there is a polynomial time nondeterministic Turing machine 
  
    
      
        M
      
    
    {\displaystyle M}
  
 such that for all 
  
    
      
        w
        â
        {
        0
        ,
        1
        
          }
          
            â
          
        
      
    
    {\displaystyle w\in \{0,1\}^{*}}
  
, 
  
    
      
        f
        (
        w
        )
      
    
    {\displaystyle f(w)}
  
 equals the number of accepting branches in 
  
    
      
        M
      
    
    {\displaystyle M}
  
's computation tree on 
  
    
      
        w
      
    
    {\displaystyle w}
  
.[16]
And just as NP can be defined both in terms of nondeterminism and in terms of a verifier (i.e. as an interactive proof system), so too can #P be equivalently defined in terms of a verifier. Recall that a decision problem is in NP if there exists a polynomial-time checkable certificate to a given problem instanceâthat is, NP asks whether there exists a proof of membership (a certificate) for the input that can be checked for correctness in polynomial time. The class #P asks how many such certificates exist.[16] In this context, #P is defined as follows:

#P is the set of functions 
  
    
      
        f
        :
        {
        0
        ,
        1
        
          }
          
            â
          
        
        â
        
          N
        
      
    
    {\displaystyle f:\{0,1\}^{*}\to \mathbb {N} }
  
 such that there exists a polynomial 
  
    
      
        p
        :
        
          N
        
        â
        
          N
        
      
    
    {\displaystyle p:\mathbb {N} \to \mathbb {N} }
  
 and a polynomial-time Turing machine 
  
    
      
        V
      
    
    {\displaystyle V}
  
 (the verifier), such that for every 
  
    
      
        w
        â
        {
        0
        ,
        1
        
          }
          
            â
          
        
      
    
    {\displaystyle w\in \{0,1\}^{*}}
  
, 
  
    
      
        f
        (
        w
        )
        =
        
          
            |
          
        
        
          
            {
          
        
        c
        â
        {
        0
        ,
        1
        
          }
          
            p
            (
            
              |
            
            w
            
              |
            
            )
          
        
        :
        V
        (
        w
        ,
        c
        )
        =
        1
        
          
            }
          
        
        
          
            |
          
        
      
    
    {\displaystyle f(w)={\Big |}{\big \{}c\in \{0,1\}^{p(|w|)}:V(w,c)=1{\big \}}{\Big |}}
  
.[20] In other words, 
  
    
      
        f
        (
        w
        )
      
    
    {\displaystyle f(w)}
  
 equals the size of the set containing all of the polynomial-size certificates.
Function problems[edit]
Main article: Function problem
This section needs expansion. You can help by adding to it.  (May 2020)
Counting problems are a subset of a broader class of problems called function problems. A function problem is a computational problem where a single output (of a total function) is expected for every input, but the output is more complex than that of a decision problem. For function problems, the output is not simply 'yes' or 'no'. The complexity class FP is the set of function problems that can be solved by a deterministic Turing machine in polynomial time.[21]

Promise problems[edit]
Main article: Promise problem
This section needs expansion. You can help by adding to it.  (May 2020)
Summary of relationships between complexity classes[edit]
The following table shows some of the classes of problems that are considered in complexity theory.  If class X is a strict subset of Y, then X is shown below Y with a dark line connecting them.  If X is a subset, but it is unknown whether they are equal sets, then the line is lighter and dotted. Technically, the breakdown into decidable and undecidable pertains more to the study of computability theory, but is useful for putting the complexity classes in perspective.










Decision Problem
















Type 0 (Recursively enumerable)








Undecidable










Decidable










EXPSPACE










NEXPTIME










EXPTIME










PSPACE




















Type 1 (Context Sensitive)


































co-NP






BQP








NP


























BPP




























P
















NC












Type 2 (Context Free)










Type 3 (Regular)


See also[edit]
List of complexity classes
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Arora and Barak p. 28

^ Sipser p. 48

^ Sipser p. 255

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Aaronson, Scott (8 January 2017). "P=?NP". Electronic Colloquim on Computational Complexity. Weizmann Institute of Science. p.Â 3.

^ "Guest Column: The Third P =? NP Poll1" (PDF).

^ Aaronson, Scott (8 January 2017). "P=?NP". Electronic Colloquim on Computational Complexity. Weizmann Institute of Science. p.Â 4.

^ Sipser pg. 320

^ Sipser pg. 321

^ Sipser pg. 321

^ Jump up to: a b Aaronson, Scott (8 January 2017). "P=?NP". Electronic Colloquim on Computational Complexity. Weizmann Institute of Science. p.Â 7.

^ Aaronson, Scott (14 August 2011). "Why Philosophers Should Care About Computational Complexity". Electronic Colloqium on Computational Complexity. Weizmann Institute of Science. p.Â 5.

^ Aaronson, Scott (8 January 2017). "P=?NP". Electronic Colloquim on Computational Complexity. Weizmann Institute of Science. p.Â 6.

^ Arora and Barak p. 144: "The verifier conducts an interrogation of the prover, repeatedly asking questions and listening to the prover's responses."

^ Sipser p. 355

^ Arora and Barak p. 286

^ Jump up to: a b c d Barak, Boaz (Spring 2006). "Complexity of counting" (PDF). Computer Science 522: Computational Complexity. Princeton University.

^ Arora, Sanjeev (Spring 2003). "Complexity classes having to do with counting". Computer Science 522: Computational Complexity Theory. Princeton University.

^ Arora and Barak p. 342

^ Arora and Barak p. 341-342

^ Arora and Barak p. 344

^ Arora and Barak p. 344


Bibliography[edit]
Arora, Sanjeev; Barak, Boaz (2009). Computational Complexity: A Modern Approach. Cambridge University Press. ISBNÂ 978-0-521-42426-4.
Sipser, Michael (2006). Introduction to the Theory of Computation (2ndÂ ed.). USA: Thomson Course Technology. ISBNÂ 978-0-534-95097-2.
Further reading[edit]
The Complexity Zoo: A huge list of complexity classes, a reference for experts.
Neil Immerman. "Computational Complexity Theory". Archived from the original on 2016-04-16. Includes a diagram showing the hierarchy of complexity classes and how they fit together.
Michael Garey, and David S. Johnson: Computers and Intractability: A Guide to the Theory of NP-Completeness. New York: W. H. Freeman & Co., 1979.  The standard reference on NP-Complete problems - an important category of problems whose solutions appear to require an impractically long time to compute.
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hide.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteImportant complexity classes (more)Considered feasible
DLOGTIME
AC0
ACC0
TC0
L
SL
RL
NL
NC
SC
CC
P
P-complete
ZPP
RP
BPP
BQP
APX
Suspected infeasible
UP
NP
NP-complete
NP-hard
co-NP
co-NP-complete
AM
QMA
PH
âP
PP
#P
#P-complete
IP
PSPACE
PSPACE-complete
Considered infeasible
EXPTIME
NEXPTIME
EXPSPACE
2-EXPTIME
ELEMENTARY
PR
R
RE
ALL
Class hierarchies
Polynomial hierarchy
Exponential hierarchy
Grzegorczyk hierarchy
Arithmetical hierarchy
Boolean hierarchy
Families of classes
DTIME
NTIME
DSPACE
NSPACE
Probabilistically checkable proof
Interactive proof system





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Complexity_class&oldid=1053922675"
		Categories: Complexity classesComputational complexity theoryMeasures of complexityTheoretical computer scienceHidden categories: Articles with short descriptionShort description is different from WikidataArticles to be expanded from April 2017All articles to be expandedArticles using small message boxesArticles to be expanded from May 2020
	
