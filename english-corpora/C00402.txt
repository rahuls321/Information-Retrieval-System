
Title:
D (programming language)
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		This article may require cleanup to meet Wikipedia's quality standards. The specific problem is: This article is all over the place, the history section is pre-empted by content in the features section, which rambles and I suspect spends most of it's space/time discussing programming metaparadigms, instead of delivering a focussed, encyclopedia-like summary and overview of what a thing is, in this case D, the programming language.  I think this could be alleviated by stealing the historical information from the features section, and putting that into the history section where it belongs, which could be placed above the features section so that the reader has the information they need up front. Please help improve this article if you can.  (November 2021) (Learn how and when to remove this template message)
Multi-paradigm system programming language
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}For other programming languages  named D, see D (disambiguation) Â§Â Computing. For other uses, see D (disambiguation).


.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}D programming languageParadigmMulti-paradigm: functional, imperative, object-orientedDesignedÂ byWalter Bright, Andrei Alexandrescu (since 2007)DeveloperD Language FoundationFirstÂ appeared8Â December 2001; 20 years agoÂ (2001-12-08)[1]Stable release2.097.0[2]Â 
   / 3 June 2021; 7 months agoÂ (3 June 2021)
Typing disciplineInferred, static, strongOSFreeBSD, Linux, macOS, WindowsLicenseBoost[3][4][5]Filename extensions.d[6][7]Websitedlang.orgMajor implementationsDMD (reference implementation), GCC, 
GDC, 

LDC, SDCInfluenced byC, C++, C#, Eiffel,[8] Java, PythonInfluencedGenie, MiniD, Qore, Swift,[9] Vala, C++11, C++14, C++17, C++20, Go, C#, and others.
 D Programming at Wikibooks

D, also known as Dlang, is a multi-paradigm system programming language created by Walter Bright at Digital Mars and released in 2001. Andrei Alexandrescu joined the design and development effort in 2007. Though it originated as a re-engineering of C++, D is a distinct language. It has redesigned some core C++ features, while also sharing characteristics of other languages, notably Java, Python, Ruby, C#, and Eiffel.
The design goals of the language attempted to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while also being shorter.[10]  The language as a whole is not memory-safe[11] but does include optional attributes designed to check memory safety.[12]
Type inference, automatic memory management and syntactic sugar for common types allow faster development, while bounds checking, design by contract features and a concurrency-aware type system help reduce the occurrence of bugs.[13]

Contents

1 Features

1.1 Programming paradigms

1.1.1 Imperative
1.1.2 Object-oriented
1.1.3 Functional
1.1.4 Parallelism
1.1.5 Concurrency
1.1.6 Metaprogramming


1.2 Memory management
1.3 SafeD

1.3.1 Scope Lifetime Safety
1.3.2 Lifetime Safety of Assignments
1.3.3 Function Parameter Lifetime Annotations within @safe code


1.4 Interaction with other systems

1.4.1 Interaction with C++ code

1.4.1.1 An Example of C++ interoperation




1.5 Better C

1.5.1 Features included in Better C
1.5.2 Features excluded from Better C




2 History
3 Implementations
4 Development tools
5 Examples

5.1 Example 1
5.2 Example 2


6 Uses
7 See also
8 References
9 Further reading
10 External links



Features[edit]
D was designed with lessons learned from practical C++ usage, rather than from a purely theoretical perspective. Although the language uses many C and C++ concepts, it also discards some, or uses different approaches (and syntax) to achieve some goals. As such, it is not source compatible (nor does it aim to be) with C and C++ source code in general (some simpler code bases from these languages might by luck work with D, or require some porting). D has, however, been constrained in its design by the rule that any code that was legal in both C and D should behave in the same way.
D gained some features before C++, such as closures, anonymous functions, compile-time function execution, ranges, built-in container iteration concepts and type inference. D adds to the functionality of C++ by also implementing design by contract, unit testing, true modules, garbage collection, first class arrays, associative arrays, dynamic arrays, array slicing, nested functions, lazy evaluation, scoped (deferred) code execution, and a re-engineered template syntax. C++ multiple inheritance was replaced by Java-style single inheritance with interfaces and mixins. On the other hand, D's declaration, statement and expression syntax closely matches that of C++.
D retains C++'s ability to perform low-level programming including inline assembler, which typifies the differences between D and application languages like Java and C#. Inline assembler lets programmers enter machine-specific assembly code within standard D code, a method used by system programmers to access the low-level features of the processor needed to run programs that interface directly with the underlying hardware, such as operating systems and device drivers, as well as writing high-performance code (i.e. using vector extensions, SIMD) that is hard to generate by the compiler automatically.
D supports function overloading and operator overloading, as well as dynamic arrays and associative arrays by default. Symbols (functions, variables, classes) can be declared in any order - forward declarations are not required. Similarly imports can be done almost in any order, and even be scoped (i.e. import some module or part of it inside a function, class or unittest only). D has built-in support for documentation comments, allowing automatic documentation generation.
In D, text character strings are just arrays of characters, and arrays in D are bounds-checked, unlike those in C++.[14] Specific operators for string handling exist, visually distinct from mathematical corellaries. D has first class types for complex and imaginary numbers, and evaluates expressions involving such types, efficiently.[15]

Programming paradigms[edit]
D supports five main programming paradigms:

concurrent (actor model)
object-oriented
imperative
functional
metaprogramming
Imperative[edit]
Imperative programming in D is almost identical to that in C. Functions, data, statements, declarations and expressions work just as they do in C, and the C runtime library may be accessed directly. On the other hand, some notable differences between D and C in the area of imperative programming include D's foreach loop construct, which allows looping over a collection, and nested functions, which are functions that are declared inside another and may access the enclosing function's local variables.

import std.stdio;

void main() {
    int multiplier = 10;
    int scaled(int x) { return x * multiplier; }

    foreach (i; 0 .. 10) {
        writefln("Hello, world %d! scaled = %d", i, scaled(i));
    }
}

Object-oriented[edit]
Object-oriented programming in D is based on a single inheritance hierarchy, with all classes derived from class Object. D does not support multiple inheritance; instead, it uses Java-style interfaces, which are comparable to C++'s pure abstract classes, and mixins, which separates common functionality from the inheritance hierarchy. D also allows the defining of static and final (non-virtual) methods in interfaces.
Interfaces and inheritance in D support covariant types for return types of overridden methods.
D supports type forwarding, as well as optional custom dynamic dispatch.
Classes (and interfaces) in D can contain invariants which are automatically checked before and after entry to public methods, in accordance with the design by contract methodology.
Many aspects of classes (and structs) can be introspected automatically at compile time (a form of reflection using type traits) and at run time (RTII / TypeInfo), to facilitate generic code or automatic code generation (usually using compile-time techniques).

Functional[edit]
D supports functional programming features such as function literals, closures, recursively-immutable objects and the use of higher-order functions. There are two syntaxes for anonymous functions, including a multiple-statement form and a "shorthand" single-expression notation:[10]

int function(int) g;
g = (x) { return x * x; }; // longhand
g = (x) => x * x;          // shorthand

There are two built-in types for function literals, function, which is simply a pointer to a stack-allocated function, and delegate, which also includes a pointer to the surrounding environment. Type inference may be used with an anonymous function, in which case the compiler creates a delegate unless it can prove that an environment pointer is not necessary. Likewise, to implement a closure, the compiler places enclosed local variables on the heap only if necessary (for example, if a closure is returned by another function, and exits that function's scope). When using type inference, the compiler will also add attributes such as pure and nothrow to a function's type, if it can prove that they apply.
Other functional features such as currying and common higher-order functions such as map, filter, and reduce are available through the standard library modules std.functional and std.algorithm.

import std.stdio, std.algorithm, std.range;

void main()
{
    int[] a1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    int[] a2 = [6, 7, 8, 9];

    // must be immutable to allow access from inside a pure function
    immutable pivot = 5;

    int mySum(int a, int b) pure nothrow // pure function
    {
        if (b <= pivot) // ref to enclosing-scope
            return a + b;
        else
            return a;
    }

    // passing a delegate (closure)
    auto result = reduce!mySum(chain(a1, a2));
    writeln("Result: ", result); // Result: 15

    // passing a delegate literal
    result = reduce!((a, b) => (b <= pivot) ? a + b : a)(chain(a1, a2));
    writeln("Result: ", result); // Result: 15
}

Alternatively, the above function compositions can be expressed using Uniform function call syntax (UFCS) for more natural left-to-right reading:

    auto result = a1.chain(a2).reduce!mySum();
    writeln("Result: ", result);

    result = a1.chain(a2).reduce!((a, b) => (b <= pivot) ? a + b : a)();
    writeln("Result: ", result);

Parallelism[edit]
Parallel programming concepts are implemented in the library, and do not require extra support from the compiler. However the D type system and compiler ensure that data sharing can be detected and managed transparently.

import std.stdio : writeln;
import std.range : iota;
import std.parallelism : parallel;

void main()
{
    foreach (i; iota(11).parallel) {
        // The body of the foreach loop is executed in parallel for each i
        writeln("processing ", i);
    }
}

iota(11).parallel is equivalent to std.parallelism.parallel(iota(11)) by using UFCS.
The same module also supports taskPool which can be used for dynamic creation of parallel tasks, as well as map-filter-reduce and fold style operations on ranges (and arrays), which is useful when combined with functional operations. std.algorithm.map returns a lazily evaluated range rather than an array. This way, the elements are computed by each worker task in parallel automatically.

import std.stdio : writeln;
import std.algorithm : map;
import std.range : iota;
import std.parallelism : taskPool;

/* On Intel i7-3930X and gdc 9.3.0:
 * 5140ms using std.algorithm.reduce
 * 888ms using std.parallelism.taskPool.reduce
 *
 * On AMD Threadripper 2950X, and gdc 9.3.0:
 * 2864ms using std.algorithm.reduce
 * 95ms using std.parallelism.taskPool.reduce
 */
void main()
{
  auto nums = iota(1.0, 1_000_000_000.0);

  auto x = taskPool.reduce!"a + b"(
      0.0, map!"1.0 / (a * a)"(nums)
  );

  writeln("Sum: ", x);
}

Concurrency[edit]
Concurrency is fully implemented in the library, and it does not require support from the compiler. Alternative implementations and methodologies of writing concurrent code are possible. The use of D typing system does help ensure memory safety.

import std.stdio, std.concurrency, std.variant;

void foo()
{
    bool cont = true;

    while (cont)
    {
        receive( // Delegates are used to match the message type.
            (int msg) => writeln("int received: ", msg),
            (Tid sender) { cont = false; sender.send(-1); },
            (Variant v) => writeln("huh?") // Variant matches any type
        );
    }
}

void main()
{
    auto tid = spawn(&foo); // spawn a new thread running foo()

    foreach (i; 0 .. 10)
        tid.send(i);   // send some integers

    tid.send(1.0f);    // send a float
    tid.send("hello"); // send a string
    tid.send(thisTid); // send a struct (Tid)

    receive((int x) => writeln("Main thread received message: ", x));
}

Metaprogramming[edit]
Metaprogramming is supported through templates, compile-time function execution, tuples, and string mixins. The following examples demonstrate some of D's compile-time features.
Templates in D can be written in a more imperative style compared to the C++ functional style for templates. This is a regular function that calculates the factorial of a number:

ulong factorial(ulong n) {
    if (n < 2)
        return 1;
    else
        return n * factorial(n-1);
}

Here, the use of static if, D's compile-time conditional construct, is demonstrated to construct a template that performs the same calculation using code that is similar to that of the function above:

template Factorial(ulong n) {
    static if (n < 2)
        enum Factorial = 1;
    else
        enum Factorial = n * Factorial!(n-1);
}

In the following two examples, the template and function defined above are used to compute factorials. The types of constants need not be specified explicitly as the compiler infers their types from the right-hand sides of assignments:

enum fact_7 = Factorial!(7);

This is an example of compile-time function execution (CTFE). Ordinary functions may be used in constant, compile-time expressions provided they meet certain criteria:

enum fact_9 = factorial(9);

The std.string.format function performs printf-like data formatting (also at compile-time, through CTFE), and the "msg" pragma displays the result at compile time:

import std.string : format;
pragma(msg, format("7! = %s", fact_7));
pragma(msg, format("9! = %s", fact_9));

String mixins, combined with compile-time function execution, allow for the generation of D code using string operations at compile time. This can be used to parse domain-specific languages, which will be compiled as part of the program:

import FooToD; // hypothetical module which contains a function that parses Foo source code
               // and returns equivalent D code
void main() {
    mixin(fooToD(import("example.foo")));
}

Memory management[edit]
Memory is usually managed with garbage collection, but specific objects may be finalized immediately when they go out of scope. This is what majority of programs and libraries written in D use.
In case more control about memory layout and better performance is needed, explicit memory management is possible using the overloaded operators new and delete, by calling C's malloc and free directly, or implementing custom allocator schemes (i.e. on stack with fallback, RAII style allocation, reference counting, shared reference counting). Garbage collection can be controlled: programmers may add and exclude memory ranges from being observed by the collector, can disable and enable the collector and force either a generational or full collection cycle.[16] The manual gives many examples of how to implement different highly optimized memory management schemes for when garbage collection is inadequate in a program.[17]
In functions, structs are by default allocated on the stack, while classes by default allocated on the heap (with only reference to the class instance being on the stack). However this can be changed for classes, for example using standard library template std.typecons.scoped, or by using new for structs and assigning to pointer instead to value-based variable.[18]
In function, static arrays (of known size) are allocated on stack. For dynamic arrays one can use core.stdc.stdlib.alloca function (similar to C function alloca, to allocate memory on stack. The returned pointer can be used (recast) into a (typed) dynamic array, by means of a slice (however resizing array, including appending must be avoided; and for obvious reasons they must not be returned from the function).[19]
A scope keyword can be used both to annotate parts of code, but also variables and classes/structs, to indicate they should be destroyed (destructor called) immediately on scope exit. Whatever the memory is deallocated also depends on implementation and class-vs-struct differences.[20]
std.experimental.allocator contains a modular and composable allocator templates, to create custom high performance allocators for special use cases.[21]

SafeD[edit]
SafeD[22]
is the name given to the subset of D that can be guaranteed to be memory safe (no writes to memory that has not been allocated or that has been recycled). Functions marked @safe are checked at compile time to ensure that they do not use any features that could result in corruption of memory, such as pointer arithmetic and unchecked casts, and any other functions called must also be marked as @safe or @trusted. Functions can be marked @trusted for the cases where the compiler cannot distinguish between safe use of a feature that is disabled in SafeD and a potential case of memory corruption.[23]

Scope Lifetime Safety[edit]
Initially under the banners of DIP1000[24] and DIP25[25] (now part of the language specification[26]), D provides protections against certain ill-formed constructions involving the lifetimes of data.
The current mechanisms in place primarily deal with function parameters and stack memory however it is a stated ambition of the leadership of the programming language to provide a more thorough treatment of lifetimes within the D programming language.[27] (Influenced by ideas from Rust programming language).

Lifetime Safety of Assignments[edit]
Within @safe code, the lifetime of an assignment involving a reference type is checked to ensure that the lifetime of the assignee is longer than that of the assigned.
For example:

@safe void test()
{
    int tmp = 0; // #1
    int* rad;    // #2
    rad = &tmp;  // If the order of the declarations of #1 and #2 is reversed, this fails.
    {
    	int bad = 45; // Lifetime of "bad" only extends to the scope in which it is defined.
        *rad = bad;   // This is kosher.
        rad = &bad;   // Lifetime of rad longer than bad, hence this is not kosher at all.
    }
}

Function Parameter Lifetime Annotations within @safe code[edit]
When applied to function parameter which are either of pointer type or references, the keywords return and scope constrain the lifetime and use of that parameter.
The Standard Dictates the following behaviour:[28]





Storage Class

Behaviour (and constraints to) of a Parameter with the storage class


scope

references in the parameter cannot be escaped. Ignored for parameters with no references


return

Parameter may be returned or copied to the first parameter, but otherwise does not escape from the function. Such copies are required not to outlive the argument(s) they were derived from. Ignored for parameters with no references

An Annotated Example is given below.@safe:

int* gp;
void thorin(scope int*);
void gloin(int*);
int* balin(return scope int* p, scope int* q, int* r)
{
     gp = p; // error, p escapes to global gp
     gp = q; // error, q escapes to global gp
     gp = r; // ok

     thorin(p); // ok, p does not escape thorin()
     thorin(q); // ok
     thorin(r); // ok

     gloin(p); // error, gloin() escapes p
     gloin(q); // error, gloin() escapes q
     gloin(r); // ok that gloin() escapes r

     return p; // ok
     return q; // error, cannot return 'scope' q
     return r; // ok
}

Interaction with other systems[edit]
C's application binary interface (ABI) is supported, as well as all of C's fundamental and derived types, enabling direct access to existing C code and libraries. D bindings are available for many popular C libraries. Additionally, C's standard library is part of standard D.
On Microsoft Windows, D can access Component Object Model (COM) code.
As long as memory management is properly taken care of, many other languages can be mixed with D in a single binary. For example GDC compiler allow to link C, C++, and other supported language codes to be intermixed. D code (functions) can also be marked as using C, C++, Pascal ABIs, and thus be passed to the libraries written in these languages as callbacks. Similarly data can be interchanged between the codes written in these languages in both ways. This usually restricts use to primitive types, pointers, some forms of arrays, unions, structs, and only some types of function pointers.
Because many other programming languages often provide the C API for writing extensions or running the interpreter of the languages, D can interface directly with these languages as well, using standard C bindings (with a thin D interface file). For example, there are bi-directional bindings for languages like Python,[29] Lua[30][31] and other languages, often using compile-time code generation and compile-time type reflection methods.

Interaction with C++ code[edit]
D takes a permissive but realistic approach to interoperation with C++ code.[32]
For D code marked as extern(C++), the following features are specified:

The name mangling conventions shall match those of C++ on the target.
For Function Calls, the ABI shall be equivalent.
The vtable shall be matched up to single inheritance (The only level supported by the D language specification).
C++ namespaces are used via the syntax extern(C++, namespace) where namespace is the name of the C++ namespace.

An Example of C++ interoperation[edit]
The C++ side

#include <iostream>
using namespace std;
class Base
{
    public:
        virtual void print3i(int a, int b, int c) = 0;
};

class Derived : public Base
{
    public:
        int field;
        Derived(int field) : field(field) {}

        void print3i(int a, int b, int c)
        {
            cout << "a = " << a << endl;
            cout << "b = " << b << endl;
            cout << "c = " << c << endl;
        }

        int mul(int factor);
};

int Derived::mul(int factor)
{
    return field * factor;
}

Derived *createInstance(int i)
{
    return new Derived(i);
}

void deleteInstance(Derived *&d)
{
    delete d;
    d = 0;
}

The D side

extern(C++)
{
    abstract class Base
    {
        void print3i(int a, int b, int c);
    }

    class Derived : Base
    {
        int field;
        @disable this();
        override void print3i(int a, int b, int c);
        final int mul(int factor);
    }

    Derived createInstance(int i);
    void deleteInstance(ref Derived d);
}

void main()
{
    import std.stdio;

    auto d1 = createInstance(5);
    writeln(d1.field);
    writeln(d1.mul(4));

    Base b1 = d1;
    b1.print3i(1, 2, 3);

    deleteInstance(d1);
    assert(d1 is null);

    auto d2 = createInstance(42);
    writeln(d2.field);

    deleteInstance(d2);
    assert(d2 is null);
}

Better C[edit]
The D programming language has an official subset known as "Better C".[33] This subset forbids access to D features requiring use of runtime libraries other than that of C.
Enabled via the compiler flags "-betterC" on DMD and LDC, and "-fno-druntime" on GDC, Better C may only call into D code compiled under the same flag (and linked code other than D) but code compiled without the Better C option may call into code compiled with it: this will, however, lead to slightly different behaviours due to differences in how C and D handle asserts.

Features included in Better C[edit]
Unrestricted use of compile-time features (for example, D's dynamic allocation features can be used at compile time to pre-allocate D data)
Full metaprogramming facilities
Nested functions, nested structs, delegates and lambdas
Member functions, constructors, destructors, operating overloading, etc.
The full module system
Array slicing, and array bounds checking
RAII
scope(exit)
Memory safety protections
Interfacing with C++
COM classes and C++ classes
assert failures are directed to the C runtime library
switch with strings
final switch
unittest blocks
printf format validation
Features excluded from Better C[edit]
Garbage collection
TypeInfo and ModuleInfo
Built-in threading (e.g. core.thread)
Dynamic arrays (though slices of static arrays work) and associative arrays
Exceptions
synchronized and core.sync
Static module constructors or destructors
History[edit]
Walter Bright started working on a new language in 1999. D was first released in December 2001[1] and reached version 1.0 in January 2007.[34] The first version of the language (D1) concentrated on the imperative, object oriented and metaprogramming paradigms,[35] similar to C++.
Some members of the D community dissatisfied with Phobos, D's official runtime and standard library, created an alternative runtime and standard library named Tango. The first public Tango announcement came within days of D 1.0's release.[36] Tango adopted a different programming style, embracing OOP and high modularity. Being a community-led project, Tango was more open to contributions, which allowed it to progress faster than the official standard library. At that time, Tango and Phobos were incompatible due to different runtime support APIs (the garbage collector, threading support, etc.). This made it impossible to use both libraries in the same project. The existence of two libraries, both widely in use, has led to significant dispute due to some packages using Phobos and others using Tango.[37]
In June 2007, the first version of D2 was released.[38] The beginning of D2's development signaled D1's stabilization. The first version of the language has been placed in maintenance, only receiving corrections and implementation bugfixes. D2 introduced breaking changes to the language, beginning with its first experimental const system. D2 later added numerous other language features, such as closures, purity, and support for the functional and concurrent programming paradigms. D2 also solved standard library problems by separating the runtime from the standard library. The completion of a D2 Tango port was announced in February 2012.[39]
The release of Andrei Alexandrescu's book The D Programming Language on 12 June 2010, marked the stabilization of D2, which today is commonly referred to as just "D".
In January 2011, D development moved from a bugtracker / patch-submission basis to GitHub. This has led to a significant increase in contributions to the compiler, runtime and standard library.[40]
In December 2011, Andrei Alexandrescu announced that D1, the first version of the language, would be discontinued on 31 December 2012.[41] The final D1 release, D v1.076, was on 31 December 2012.[42]
Code for the official D compiler, the Digital Mars D compiler by Walter Bright, was originally released under a custom license, qualifying as source available but not conforming to the open source definition.[43] In 2014, the compiler front-end was re-licensed as open source under the Boost Software License.[3] This re-licensed code excluded the back-end, which had been partially developed at Symantec. On 7 April 2017, the whole compiler was made available under the Boost license after Symantec gave permission to re-license the back-end, too.[4][44][45][46] On 21 June 2017, the D Language was accepted for inclusion in GCC.[47]

Implementations[edit]
Most current D implementations compile directly into machine code for efficient execution.
Production ready compilers:

DMD â The Digital Mars D compiler by Walter Bright is the official D compiler; open sourced under the Boost Software License.[3][4] The DMD frontend is shared by GDC (now in GCC) and LDC, to improve compatibility between compilers. Initially the frontend was written in C++, but now most of it is now written in D itself (self-hosting). The backend and machine code optimizers are based on the Symantec compiler. At first it supported only 32-bit x86, with support added for 64-bit amd64 and PowerPC by Walter Bright. Later the backend and almost the entire compiler was ported from C++ to D for full self-hosting.
GCC â The GNU Compiler Collection, merged GDC[48] into GCC 9 on 29 October 2018.[49] The first working versions of GDC with GCC, based on GCC 3.3 and GCC 3.4 on 32-bit x86 on Linux and macOS[50] was released on 22 March 2004. Since then GDC has gained support for additional platforms, improved performance, and fixed bugs, while tracking upstream DMD code for the frontend and language specification.[51]
LDC â A compiler based on the DMD front-end that uses LLVM as its compiler back-end. The first release-quality version was published on 9 January 2009.[52] It supports version 2.0.[53]
Toy and proof-of-concept compilers:

D Compiler for .NET â A back-end for the D programming language 2.0 compiler.[54][55] It compiles the code to Common Intermediate Language (CIL) bytecode rather than to machine code. The CIL can then be run via a Common Language Infrastructure (CLI) virtual machine. The project has not been updated in years and the author indicated the project is not active anymore.
SDC â The Stupid D Compiler uses a custom front-end and LLVM as its compiler back-end. It is written in D and uses a scheduler to handle symbol resolution in order to elegantly handle the compile-time features of D. This compiler currently supports a limited subset of the language.[56][57]
Using above compilers and toolchains, it is possible to compile D programs to target many different architectures, including x86, amd64, AArch64, PowerPC, MIPS64, DEC Alpha, Motorola m68k, Sparc, s390, WebAssembly. The primary supported operating systems are Windows and Linux, but various compilers also support Mac OS X, FreeBSD, NetBSD, AIX, Solaris/OpenSolaris and Android, either as a host or target, or both. WebAssembly target (supported via LDC and LLVM) can operate in any WebAssembly environment, like modern web browser (Google Chrome, Mozilla Firefox, Microsoft Edge, Apple Safari), or dedicated Wasm virtual machines.

Development tools[edit]
Editors and integrated development environments (IDEs) supporting syntax highlighting and partial code completion for the language include SlickEdit, Emacs, vim, SciTE, Smultron, Zeus,[58] and Geany among others.[59]

Dexed (formerly Coedit),[60] a D focused graphical IDE written in Object Pascal
Mono-D[61] is a feature rich cross-platform D focused graphical IDE based on MonoDevelop / Xamarin Studio, mainly written in C Sharp.[62]
Eclipse plug-ins for D include DDT[63] and Descent (dead project).[64]
Visual Studio integration is provided by VisualD.[65][66]
Visual Studio Code integration with extensions as Dlang-Vscode[67] or Code-D.[68]
A bundle is available for TextMate, and the Code::Blocks IDE includes partial support for the language. However, standard IDE features such as code completion or refactoring are not yet available, though they do work partially in Code::Blocks (due to D's similarity to C).
The Xcode 3 plugin "D for Xcode" enables D-based projects and development.[69]
KDevelop (as well as its text editor backend, Kate) autocompletion plugin is available.[70]
Open source D IDEs for Windows exist, some written in D, such as Poseidon,[71] D-IDE,[72] and Entice Designer.[73]
D applications can be debugged using any C/C++ debugger, like GDB or WinDbg, although support for various D-specific language features is extremely limited. On Windows, D programs can be debugged using Ddbg, or Microsoft debugging tools (WinDBG and Visual Studio), after having converted the debug information using cv2pdb. The ZeroBUGS debugger for Linux has experimental support for the D language. Ddbg can be used with various IDEs or from the command line; ZeroBUGS has its own graphical user interface (GUI).
DustMite is a powerful tool for minimizing D source code, useful when finding compiler or tests issues.[74]
dub is a popular package and build manager for D applications and libraries, and is often integrated into IDE support.[75]

Examples[edit]
This section possibly contains original research. Please improve it by verifying the claims made and adding inline citations. Statements consisting only of original research should be removed.  (September 2020) (Learn how and when to remove this template message)
Example 1[edit]
This example program prints its command line arguments. The main function is the entry point of a D program, and args is an array of strings representing the command line arguments. A string in D is an array of characters, represented by immutable(char)[].

import std.stdio: writefln;

void main(string[] args) {
    foreach (i, arg; args)
        writefln("args[%d] = '%s'", i, arg);
}

The foreach statement can iterate over any collection. In this case, it is producing a sequence of indexes (i) and values (arg) from the array args. The index i and the value arg have their types inferred from the type of the array args.

Example 2[edit]
The following shows several D capabilities and D design trade-offs in a short program. It iterates over the lines of a text file named words.txt, which contains a different word on each line, and prints all the words that are anagrams of other words.

import std.stdio, std.algorithm, std.range, std.string;

void main() {
    dstring[] [dstring] signature2words;

    foreach (dchar[] w; lines(File("words.txt"))) {
        w = w.chomp().toLower();
        immutable signature = w.dup.sort().release().idup;
        signature2words[signature] ~= w.idup;
    }

    foreach (words; signature2words) {
        if (words.length > 1) {
            writeln(words.join(" "));
        }
    }
}

signature2words is a built-in associative array that maps dstring (32-bit / char) keys to arrays of dstrings. It is similar to defaultdict(list) in Python.
lines(File()) yields lines lazily, with the newline. It has to then be copied with idup to obtain a string to be used for the associative array values (the idup property of arrays returns an immutable duplicate of the array, which is required since the dstring type is actually immutable(dchar)[]). Built-in associative arrays require immutable keys.
The ~= operator appends a new dstring to the values of the associate dynamic array.
toLower, join and chomp are string functions that D allows the use of with a method syntax. The name of such functions are often similar to Python string methods. The toLower converts a string to lower case, join("Â ") joins an array of strings into a single string using a single space as separator, and chomp removes a newline from the end of the string if one is present. The w.dup.sort().release().idup is more readable, but equivalent to release(sort(w.dup)).idup for example. This feature is called UFCS (Uniform Function Call Syntax), and allows extending any built-in or third party package types with method-like functionality. The style of writing code like this is often referenced as pipeline (especially when the objects used are lazily computed, for example iterators / ranges) or Fluent interface.
The sort is an std.algorithm function that sorts the array in place, creating a unique signature for words that are anagrams of each other. The release() method on the return value of sort() is handy to keep the code as a single expression.
The second foreach iterates on the values of the associative array, it is able to infer the type of words.
signature is assigned to an immutable variable, its type is inferred.
UTF-32 dchar[] is used instead of normal UTF-8 char[] otherwise sort() refuses to sort it. There are more efficient ways to write this program using just UTF-8.
Uses[edit]
Notable organisations that use the D programming language for projects include Facebook,[76] eBay,[77] and Netflix.[78]
D has been successfully used for AAA games,[79] language interpreters, virtual machines,[80][81] an operating system kernel,[82] GPU programming,[83] web development,[84][85] numerical analysis,[86] GUI applications,[87][88] a passenger information system,[89] machine learning,[90] text processing, web and application servers and research.

See also[edit]
.mw-parser-output .portalbox{float:right;border:solid #aaa 1px;padding:0}.mw-parser-output .portalbox.tleft{margin:0.5em 1em 0.5em 0}.mw-parser-output .portalbox.tright{margin:0.5em 0 0.5em 1em}.mw-parser-output .portalbox>ul{display:table;box-sizing:border-box;padding:0.1em;max-width:175px;background:#f9f9f9;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox>ul>li{display:table-row}.mw-parser-output .portalbox>ul>li>span:first-child{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox>ul>li>span:last-child{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}

Computer programming portal
Ddoc
D Language Foundation
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"D Change Log to Nov 7 2005". D Programming Language 1.0. Digital Mars. Retrieved 1 December 2011.

^ "Change Log: 2.097.0". Retrieved 3 June 2021.

^ Jump up to: a b c "dmd front end now switched to Boost license". Retrieved 9 September 2014.

^ Jump up to: a b c "dmd Backend converted to Boost License". 7 April 2017. Retrieved 9 April 2017.

^ "D 2.0 FAQ". Retrieved 11 August 2015.

^  ""D Programming Language - Fileinfo.com"". Retrieved 15 November 2020.[citation needed]

^  ""D Programming Language - dlang.org"". Retrieved 15 November 2020.[citation needed]

^ Alexandrescu, Andrei (2010). The D programming language (FirstÂ ed.). Upper Saddle River, New Jersey: Addison-Wesley. p.Â 314. ISBNÂ 978-0321635365.

^ "Building assert() in Swift, Part 2: __FILE__ and __LINE__". Retrieved 25 September 2014.

^ Jump up to: a b "Expressions". Digital Mars. Retrieved 27 December 2012.

^ "On: Ruminations on D: An Interview with Walter Bright". Hacker News. 30 August 2016. "It's close, and we're working to close the remaining gaps."

^ "Memory-Safe-D-Spec". D Language Foundation.

^ Archived at Ghostarchive and the Wayback Machine: Andrei Alexandrescu (2 August 2010). Three Cool Things About D.

^ "D Strings vs C++ Strings". Digital Mars. 2012.

^ "D Complex Types and C++ std::complex". Digital Mars. 2012. Retrieved 4 November 2021.{{cite web}}:  CS1 maint: url-status (link)

^ "std.gc". D Programming Language 1.0. Digital Mars. Retrieved 6 July 2010.

^ "Memory Management". D Programming Language 2.0. Digital Mars. Retrieved 17 February 2012.

^ "Go Your Own Way (Part One: The Stack)". The D Blog. 7 July 2017. Retrieved 7 May 2020.

^ "Go Your Own Way (Part One: The Stack)". The D Blog. 7 July 2017. Retrieved 7 May 2020.

^ "Attributes - D Programming Language". dlang.org. Retrieved 7 May 2020.

^ "std.experimental.allocator - D Programming Language". dlang.org. Retrieved 7 May 2020.

^ Bartosz Milewski. "SafeD â D Programming Language". Retrieved 17 July 2014.

^ Steven Schveighoffer (28 September 2016). "How to Write @trusted Code in D". Retrieved 4 January 2018.

^ "Scoped Pointers". GitHub. 3 April 2020.

^ "Sealed References".

^ "D Language Specification: Functions - Return Scope Parameters".

^ "Ownership and Borrowing in D". 15 July 2019.

^ "D Language Specification: Functions - Function Parameter Storage Classes".

^ "PyD". GitHub. 7 May 2020. Retrieved 7 May 2020.

^ Parker, Mike. "Package derelict-lua on DUB". DUB Package Registry. Retrieved 7 May 2020.

^ Parker, Mike. "Package bindbc-lua on DUB". DUB Package Registry. Retrieved 7 May 2020.

^ "Interfacing to C++".

^ "Better C".

^ "D Change Log". D Programming Language 1.0. Digital Mars. Retrieved 11 January 2012.

^ "Intro". D Programming Language 1.0. Digital Mars. Retrieved 1 December 2011.

^ "Announcing a new library". Retrieved 15 February 2012.

^ "Wiki4D: Standard Lib". Retrieved 6 July 2010.

^ "Change Log â D Programming Language". D Programming Language 2.0. D Language Foundation. Retrieved 22 November 2020.

^ "Tango for D2: All user modules ported". Retrieved 16 February 2012.

^ Walter Bright. "Re: GitHub or dsource?". Retrieved 15 February 2012.

^ Andrei Alexandrescu. "D1 to be discontinued on December 31, 2012". Retrieved 31 January 2014.

^ "D Change Log". D Programming Language 1.0. Digital Mars. Retrieved 31 January 2014.

^ "backendlicense.txt". DMD source code. GitHub. Archived from the original on 22 October 2016. Retrieved 5 March 2012.

^ "Reddit comment by Walter Bright". 5 March 2009. Retrieved 9 September 2014.

^ D-Compiler-unter-freier-Lizenz on linux-magazin.de (2017, in German)

^ switch backend to Boost License #6680 from Walter Bright on github.com

^ D Language accepted for inclusion in GCC

^ "GDC".

^ "GCC 9 Release Series â Changes, New Features, and Fixes - GNU Project - Free Software Foundation (FSF)". gcc.gnu.org. Retrieved 7 May 2020.

^ "Another front end for GCC". forum.dlang.org. Retrieved 7 May 2020.

^ "GCC 9 Release Series Changes, New Features, and Fixes".

^ "LLVM D compiler project on GitHub". GitHub. Retrieved 19 August 2016.

^ "BuildInstructionsPhobosDruntimeTrunk â ldc â D Programming Language â Trac". Retrieved 11 August 2015.

^ "D .NET project on CodePlex". Retrieved 3 July 2010.

^ Jonathan Allen (15 May 2009). "Source for the D.NET Compiler is Now Available". InfoQ. Retrieved 6 July 2010.

^ Archived at Ghostarchive and the Wayback Machine: "DConf 2014: SDC, a D Compiler as a Library by Amaury Sechet". YouTube. Retrieved 8 January 2014.

^ "deadalnix/SDC". GitHub. Retrieved 8 January 2014.

^ "Wiki4D: EditorSupport/ZeusForWindows". Retrieved 11 August 2015.

^ "Wiki4D: Editor Support". Retrieved 3 July 2010.

^ "Basile.B / dexed". GitLab. Retrieved 29 April 2020.

^ "Mono-D - D Wiki". wiki.dlang.org. Retrieved 30 April 2020.

^ "Mono-D â D Support for MonoDevelop". Retrieved 11 August 2015.

^ "Google Project Hosting". Retrieved 11 August 2015.

^ "descent". Retrieved 11 August 2015.

^ "Visual D - D Programming Language". Retrieved 11 August 2015.

^ Schuetze, Rainer (17 April 2020). "rainers/visuald: Visual D - Visual Studio extension for the D programming language". github.com. Retrieved 30 April 2020.

^ "dlang-vscode". GitHub. Retrieved 21 December 2016.

^ "code-d". GitHub. Retrieved 21 December 2016.

^ "Michel Fortin â D for Xcode". Retrieved 11 August 2015.

^ "Dav1dde/lumen". GitHub. Retrieved 11 August 2015.

^ "poseidon". Retrieved 11 August 2015.

^ "Mono-D â D Support for MonoDevelop". Retrieved 11 August 2015.

^ "Entice Designer â Dprogramming.com â The D programming language". Retrieved 11 August 2015.

^ "What is DustMite?". GitHub. Retrieved 29 April 2020.

^ "dlang/dub: Package and build management system for D". GitHub. Retrieved 29 April 2020.

^ "Under the Hood: warp, a fast C and C++ preprocessor". 28 March 2014. Retrieved 4 January 2018.

^ "Faster Command Line Tools in D". 24 May 2017. Retrieved 4 January 2018.

^ "Introducing Vectorflow". 2 August 2017. Retrieved 4 January 2018.

^ "Quantum Break: AAA Gaming With Some D Code". Retrieved 4 January 2018.

^ "Higgs JavaScript Virtual Machine". GitHub. Retrieved 4 January 2018.

^ "A D implementation of the ECMA 262 (Javascript) programming language". GitHub. Retrieved 4 January 2018.

^ "Project Highlight: The PowerNex Kernel". 24 June 2016. Retrieved 4 January 2018.

^ "DCompute: Running D on the GPU". 30 October 2017. Retrieved 4 January 2018.

^ "vibe.d - a high-performance asynchronous I/O, concurrency and web application toolkit written in D". Retrieved 4 January 2018.

^ "Project Highlight: Diamond MVC Framework". 20 November 2017. Retrieved 4 January 2018.

^ "Numeric age for D: Mir GLAS is faster than OpenBLAS and Eigen". Retrieved 4 January 2018.

^ "On Tilix and D: An Interview with Gerald Nunn". 11 August 2017. Retrieved 4 January 2018.

^ "Project Highlight: DlangUI". 7 October 2016. Retrieved 4 January 2018.

^ "Project Highlight: Funkwerk". Retrieved 4 January 2018.

^ "Netflix/vectorflow". GitHub.com. Netflix, Inc. 5 May 2020. Retrieved 7 May 2020.


Further reading[edit]
Alexandrescu, Andrei (4 January 2010). The D Programming Language (1Â ed.). Addison-Wesley Professional. ISBNÂ 978-0-321-63536-5.
Alexandrescu, Andrei (15 June 2009). "The Case for D". Dr. Dobb's Journal.
Bright, Walter (8 April 2014). "How I Came to Write D". Dr. Dobb's Journal.
Ãehreli, Ali (1 February 2012). "Programming in D". (distributed under CC-BY-NC-SA license). This book teaches programming to novices, but covers many advanced D topics as well.
Metz, Cade (7 July 2014). "The Next Big Programming Language You've Never Heard Of". Wired.
Ruppe, Adam (May 2014). D Cookbook (1Â ed.). PACKT Publishing. ISBNÂ 978-1-783-28721-5.
External links[edit]



Wikibooks has a book on the topic of: A Beginner's Guide to D




Wikibooks has a book on the topic of: D Programming

Official website 
Digital Mars
Turkish Forum
Dlang on GitHub
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteC programming language
ANSI C
C99
C11
C17
C2x
Embedded C
MISRA C
Features
Functions
Header files
Operators
String
Syntax
Preprocessor
Data types
Standard library
Char
File I/O
Math
Dynamic memory
String
Time
Variadic
POSIX
Standard libraryimplementations
Bionic
libhybris
dietlibc
glibc
EGLIBC
klibc
Windows CRT
musl
Newlib
uClibc
Compilers
ACK
Borland Turbo C
Clang
GCC
ICC
LCC
Norcroft C
PCC
SDCC
TCC
Microsoft Visual Studio / Express / C++
Watcom C/C++
IDEs
Anjuta
CLion
Code::Blocks
CodeLite
Eclipse
Geany
GNOME Builder
KDevelop
Microsoft Visual Studio
NetBeans
Comparison withother languages
Compatibility of C and C++
Comparison with Pascal
Descendantlanguages
C++
C#
D
Objective-C
Alef
Limbo
Go
Vala

 Category

Authority control General
Integrated Authority File (Germany)
National libraries
United States





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=D_(programming_language)&oldid=1069025092"
		Categories: Programming languagesC programming language familyClass-based programming languagesCross-platform softwareFree compilers and interpretersHigh-level programming languagesMulti-paradigm programming languagesObject-oriented programming languagesProcedural programming languagesProgramming languages created in 2001Statically typed programming languagesSystems programming languages2001 softwareSoftware using the Boost licenseArticles with example D codeHidden categories: All articles with unsourced statementsArticles with unsourced statements from September 2020CS1 maint: url-statusArticles needing cleanup from November 2021All pages needing cleanupCleanup tagged articles with a reason field from November 2021Wikipedia pages needing cleanup from November 2021Articles with short descriptionShort description is different from WikidataUse dmy dates from April 2018Articles that may contain original research from September 2020All articles that may contain original researchArticles with GND identifiersArticles with LCCN identifiers
	
