
Title:
Stochastic gradient descent
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Optimization algorithm
Stochastic gradient descent (often abbreviated SGD) is an iterative method for optimizing an objective function with suitable smoothness properties (e.g. differentiable or subdifferentiable). It can be regarded as a stochastic approximation of gradient descent optimization, since it replaces the actual gradient (calculated from the entire data set) by an estimate thereof (calculated from a randomly selected subset of the data). Especially in high-dimensional optimization problems this reduces the computational burden, achieving faster iterations in trade for a lower convergence rate.[1]
While the basic idea behind stochastic approximation can be traced back to the RobbinsâMonro algorithm of the 1950s, stochastic gradient descent has become an important optimization method in machine learning.[2]

Contents

1 Background
2 Iterative method
3 Example
4 Notable applications
5 Extensions and variants

5.1 Implicit updates (ISGD)
5.2 Momentum
5.3 Averaging
5.4 AdaGrad
5.5 RMSProp
5.6 Adam
5.7 Backtracking line search
5.8 Second-order methods


6 Notes
7 See also
8 References
9 Further reading
10 External links



Background[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: M-estimation
See also: Estimating equation
Both statistical estimation and machine learning consider the problem of minimizing an objective function that has the form of a sum:


  
    
      
        Q
        (
        w
        )
        =
        
          
            1
            n
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          Q
          
            i
          
        
        (
        w
        )
        ,
      
    
    {\displaystyle Q(w)={\frac {1}{n}}\sum _{i=1}^{n}Q_{i}(w),}
  

where the parameter 
  
    
      
        w
      
    
    {\displaystyle w}
  
 that minimizes 
  
    
      
        Q
        (
        w
        )
      
    
    {\displaystyle Q(w)}
  
 is to be estimated. Each summand function 
  
    
      
        
          Q
          
            i
          
        
      
    
    {\displaystyle Q_{i}}
  
 is typically associated with the 
  
    
      
        i
      
    
    {\displaystyle i}
  
-th observation in the data set (used for training).
In classical statistics, sum-minimization problems arise in least squares and in maximum-likelihood estimation (for independent observations).  The general class of estimators that arise as minimizers of sums are called M-estimators. However, in statistics, it has been long recognized that requiring even local minimization is too restrictive for some problems of maximum-likelihood estimation.[3] Therefore, contemporary statistical theorists often consider stationary points of the likelihood function (or zeros of its derivative, the score function, and other estimating equations).
The sum-minimization problem also arises for empirical risk minimization. In this case, 
  
    
      
        
          Q
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle Q_{i}(w)}
  
 is the value of the loss function at 
  
    
      
        i
      
    
    {\displaystyle i}
  
-th example, and 
  
    
      
        Q
        (
        w
        )
      
    
    {\displaystyle Q(w)}
  
 is the empirical risk.
When used to minimize the above function, a standard (or "batch") gradient descent method would perform the following iterations:


  
    
      
        w
        :=
        w
        â
        Î·
        â
        Q
        (
        w
        )
        =
        w
        â
        
          
            Î·
            n
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        â
        
          Q
          
            i
          
        
        (
        w
        )
        ,
      
    
    {\displaystyle w:=w-\eta \nabla Q(w)=w-{\frac {\eta }{n}}\sum _{i=1}^{n}\nabla Q_{i}(w),}
  

where 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
 is a step size (sometimes called the learning rate in machine learning).
In many cases, the summand functions have a simple form that enables inexpensive evaluations of the sum-function and the sum gradient. For example, in statistics, one-parameter exponential families allow economical function-evaluations and gradient-evaluations.
However, in other cases, evaluating the sum-gradient may require expensive evaluations of the gradients from all summand functions. When the training set is enormous and no simple formulas exist, evaluating the sums of gradients becomes very expensive, because evaluating the gradient requires evaluating all the summand functions' gradients. To economize on the computational cost at every iteration, stochastic gradient descent samples a subset of summand functions at every step. This is very effective in the case of large-scale machine learning problems.[4]

Iterative method[edit]
  Fluctuations in the total objective function as gradient steps with respect to mini-batches are taken.
In stochastic (or "on-line") gradient descent, the true gradient of 
  
    
      
        Q
        (
        w
        )
      
    
    {\displaystyle Q(w)}
  
 is approximated by a gradient at a single example:


  
    
      
        w
        :=
        w
        â
        Î·
        â
        
          Q
          
            i
          
        
        (
        w
        )
        .
      
    
    {\displaystyle w:=w-\eta \nabla Q_{i}(w).}
  

As the algorithm sweeps through the training set, it performs the above update for each training example. Several passes can be made over the training set until the algorithm converges. If this is done, the data can be shuffled for each pass to prevent cycles. Typical implementations may use an adaptive learning rate so that the algorithm converges.[5]
In pseudocode, stochastic gradient descent can be presented as follows:





Choose an initial vector of parameters 
  
    
      
        w
      
    
    {\displaystyle w}
  
 and learning rate 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
.
Repeat until an approximate minimum is obtained:
Randomly shuffle examples in the training set.
For 
  
    
      
        i
        =
        1
        ,
        2
        ,
        .
        .
        .
        ,
        n
      
    
    {\displaystyle i=1,2,...,n}
  
, do:

  
    
      
        w
        :=
        w
        â
        Î·
        â
        
          Q
          
            i
          
        
        (
        w
        )
        .
      
    
    {\displaystyle w:=w-\eta \nabla Q_{i}(w).}
  



A compromise between computing the true gradient and the gradient at a single example is to compute the gradient against more than one training example (called a "mini-batch") at each step.  This can perform significantly better than "true" stochastic gradient descent described, because the code can make use of vectorization libraries rather than computing each step separately.  It may also result in smoother convergence, as the gradient computed at each step is averaged over more training examples.
The convergence of stochastic gradient descent has been analyzed using the theories of convex minimization and of stochastic approximation. Briefly, when the learning rates 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
 decrease with an appropriate rate,
and subject to relatively mild assumptions, stochastic gradient descent converges almost surely to a global minimum 
when the objective function is convex or pseudoconvex, 
and otherwise converges almost surely to a local minimum.[6][7]
This is in fact a consequence of the RobbinsâSiegmund theorem.[8]

Example[edit]
Let's suppose we want to fit a straight line 
  
    
      
        
          
            
              y
              ^
            
          
        
        =
        
        
          w
          
            1
          
        
        +
        
          w
          
            2
          
        
        x
      
    
    {\displaystyle {\hat {y}}=\!w_{1}+w_{2}x}
  
 to a training set with observations 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle (x_{1},x_{2},\ldots ,x_{n})}
  
 and corresponding estimated responses 
  
    
      
        (
        
          
            
              
                y
                
                  1
                
              
              ^
            
          
        
        ,
        
          
            
              
                y
                
                  2
                
              
              ^
            
          
        
        ,
        â¦
        ,
        
          
            
              
                y
                
                  n
                
              
              ^
            
          
        
        )
      
    
    {\displaystyle ({\hat {y_{1}}},{\hat {y_{2}}},\ldots ,{\hat {y_{n}}})}
  
 using least squares. The objective function to be minimized is:


  
    
      
        Q
        (
        w
        )
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          Q
          
            i
          
        
        (
        w
        )
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          
            (
            
              
                
                  
                    
                      y
                      
                        i
                      
                    
                    ^
                  
                
              
              â
              
                y
                
                  i
                
              
            
            )
          
          
            2
          
        
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          
            (
            
              
                w
                
                  1
                
              
              +
              
                w
                
                  2
                
              
              
                x
                
                  i
                
              
              â
              
                y
                
                  i
                
              
            
            )
          
          
            2
          
        
        .
      
    
    {\displaystyle Q(w)=\sum _{i=1}^{n}Q_{i}(w)=\sum _{i=1}^{n}\left({\hat {y_{i}}}-y_{i}\right)^{2}=\sum _{i=1}^{n}\left(w_{1}+w_{2}x_{i}-y_{i}\right)^{2}.}
  

The last line in the above pseudocode for this specific problem will become:


  
    
      
        
          
            [
            
              
                
                  
                    w
                    
                      1
                    
                  
                
              
              
                
                  
                    w
                    
                      2
                    
                  
                
              
            
            ]
          
        
        :=
        
          
            [
            
              
                
                  
                    w
                    
                      1
                    
                  
                
              
              
                
                  
                    w
                    
                      2
                    
                  
                
              
            
            ]
          
        
        â
        Î·
        
          
            [
            
              
                
                  
                    
                      â
                      
                        â
                        
                          w
                          
                            1
                          
                        
                      
                    
                  
                  (
                  
                    w
                    
                      1
                    
                  
                  +
                  
                    w
                    
                      2
                    
                  
                  
                    x
                    
                      i
                    
                  
                  â
                  
                    y
                    
                      i
                    
                  
                  
                    )
                    
                      2
                    
                  
                
              
              
                
                  
                    
                      â
                      
                        â
                        
                          w
                          
                            2
                          
                        
                      
                    
                  
                  (
                  
                    w
                    
                      1
                    
                  
                  +
                  
                    w
                    
                      2
                    
                  
                  
                    x
                    
                      i
                    
                  
                  â
                  
                    y
                    
                      i
                    
                  
                  
                    )
                    
                      2
                    
                  
                
              
            
            ]
          
        
        =
        
          
            [
            
              
                
                  
                    w
                    
                      1
                    
                  
                
              
              
                
                  
                    w
                    
                      2
                    
                  
                
              
            
            ]
          
        
        â
        Î·
        
          
            [
            
              
                
                  2
                  (
                  
                    w
                    
                      1
                    
                  
                  +
                  
                    w
                    
                      2
                    
                  
                  
                    x
                    
                      i
                    
                  
                  â
                  
                    y
                    
                      i
                    
                  
                  )
                
              
              
                
                  2
                  
                    x
                    
                      i
                    
                  
                  (
                  
                    w
                    
                      1
                    
                  
                  +
                  
                    w
                    
                      2
                    
                  
                  
                    x
                    
                      i
                    
                  
                  â
                  
                    y
                    
                      i
                    
                  
                  )
                
              
            
            ]
          
        
        .
      
    
    {\displaystyle {\begin{bmatrix}w_{1}\\w_{2}\end{bmatrix}}:={\begin{bmatrix}w_{1}\\w_{2}\end{bmatrix}}-\eta {\begin{bmatrix}{\frac {\partial }{\partial w_{1}}}(w_{1}+w_{2}x_{i}-y_{i})^{2}\\{\frac {\partial }{\partial w_{2}}}(w_{1}+w_{2}x_{i}-y_{i})^{2}\end{bmatrix}}={\begin{bmatrix}w_{1}\\w_{2}\end{bmatrix}}-\eta {\begin{bmatrix}2(w_{1}+w_{2}x_{i}-y_{i})\\2x_{i}(w_{1}+w_{2}x_{i}-y_{i})\end{bmatrix}}.}
  

Note that in each iteration (also called update), the gradient is only evaluated at a single point 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 instead of at the set of all samples.
The key difference compared to standard (Batch) Gradient Descent is that only one piece of data from the dataset is used to calculate the step, and the piece of data is picked randomly at each step.

Notable applications[edit]
Stochastic gradient descent is a popular algorithm for training a wide range of models in machine learning, including (linear) support vector machines, logistic regression (see, e.g., Vowpal Wabbit) and graphical models.[9] When combined with the backpropagation algorithm, it is the de facto standard algorithm for training artificial neural networks.[10] Its use has been also reported in the Geophysics community, specifically to applications of Full Waveform Inversion (FWI).[11]
Stochastic gradient descent competes with the L-BFGS algorithm,[citation needed] which is also widely used. Stochastic gradient descent has been used since at least 1960 for training linear regression models, originally under the name ADALINE.[12]
Another stochastic gradient descent algorithm is the least mean squares (LMS) adaptive filter.

Extensions and variants[edit]
Many improvements on the basic stochastic gradient descent algorithm have been proposed and used. In particular, in machine learning, the need to set a learning rate (step size) has been recognized as problematic. Setting this parameter too high can cause the algorithm to diverge; setting it too low makes it slow to converge.[13] A conceptually simple extension of stochastic gradient descent makes the learning rate a decreasing function Î·t of the iteration number t, giving a learning rate schedule, so that the first iterations cause large changes in the parameters, while the later ones do only fine-tuning. Such schedules have been known since the work of MacQueen on k-means clustering.[14] Practical guidance on choosing the step size in several variants of SGD is given by Spall.[15]

Implicit updates (ISGD)[edit]
As mentioned earlier, classical stochastic gradient descent is generally sensitive to learning rate Î·. Fast convergence requires large learning rates but this may induce numerical instability. The problem can be largely solved[16] by considering implicit updates whereby the stochastic gradient is evaluated at the next iterate rather than the current one:


  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
        :=
        
          w
          
            
              o
              l
              d
            
          
        
        â
        Î·
        â
        
          Q
          
            i
          
        
        (
        
          w
          
            
              n
              e
              w
            
          
        
        )
        .
      
    
    {\displaystyle w^{\rm {new}}:=w^{\rm {old}}-\eta \nabla Q_{i}(w^{\rm {new}}).}
  

This equation is implicit since 
  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
      
    
    {\displaystyle w^{\rm {new}}}
  
 appears on both sides of the equation. It is a stochastic form of the proximal gradient method since the update
can also be written as:


  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
        :=
        arg
        â¡
        
          min
          
            w
          
        
        {
        
          Q
          
            i
          
        
        (
        w
        )
        +
        
          
            1
            
              2
              Î·
            
          
        
        
          |
        
        
          |
        
        w
        â
        
          w
          
            
              o
              l
              d
            
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
        }
        .
      
    
    {\displaystyle w^{\rm {new}}:=\arg \min _{w}\{Q_{i}(w)+{\frac {1}{2\eta }}||w-w^{\rm {old}}||^{2}\}.}
  

As an example, 
consider least squares with features 
  
    
      
        
          x
          
            1
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        â
        
          
            R
          
          
            p
          
        
      
    
    {\displaystyle x_{1},\ldots ,x_{n}\in \mathbb {R} ^{p}}
  
 and observations

  
    
      
        
          y
          
            1
          
        
        ,
        â¦
        ,
        
          y
          
            n
          
        
        â
        
          R
        
      
    
    {\displaystyle y_{1},\ldots ,y_{n}\in \mathbb {R} }
  
. We wish to solve:


  
    
      
        
          min
          
            w
          
        
        
          â
          
            j
            =
            1
          
          
            n
          
        
        (
        
          y
          
            j
          
        
        â
        
          x
          
            j
          
          â²
        
        w
        
          )
          
            2
          
        
        ,
      
    
    {\displaystyle \min _{w}\sum _{j=1}^{n}(y_{j}-x_{j}'w)^{2},}
  

where 
  
    
      
        
          x
          
            j
          
          â²
        
        w
        =
        
          x
          
            j
            1
          
        
        
          w
          
            1
          
        
        +
        
          x
          
            j
            ,
            2
          
        
        
          w
          
            2
          
        
        +
        .
        .
        .
        +
        
          x
          
            j
            ,
            p
          
        
        
          w
          
            p
          
        
      
    
    {\displaystyle x_{j}'w=x_{j1}w_{1}+x_{j,2}w_{2}+...+x_{j,p}w_{p}}
  
  indicates the inner product.
Note that 
  
    
      
        x
      
    
    {\displaystyle x}
  
 could have "1" as the first element to include an intercept. Classical stochastic gradient descent proceeds as follows:


  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
        =
        
          w
          
            
              o
              l
              d
            
          
        
        +
        Î·
        (
        
          y
          
            i
          
        
        â
        
          x
          
            i
          
          â²
        
        
          w
          
            
              o
              l
              d
            
          
        
        )
        
          x
          
            i
          
        
      
    
    {\displaystyle w^{\rm {new}}=w^{\rm {old}}+\eta (y_{i}-x_{i}'w^{\rm {old}})x_{i}}
  

where 
  
    
      
        i
      
    
    {\displaystyle i}
  
 is uniformly sampled between 1 and 
  
    
      
        n
      
    
    {\displaystyle n}
  
. Although theoretical convergence of this procedure happens under relatively mild assumptions, in practice the procedure can be quite unstable. In particular, when 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
 is misspecified so that 
  
    
      
        I
        â
        Î·
        
          x
          
            i
          
        
        
          x
          
            i
          
          â²
        
      
    
    {\displaystyle I-\eta x_{i}x_{i}'}
  
 has large absolute eigenvalues with high probability, the procedure may diverge numerically within a few iterations. In contrast, implicit stochastic gradient descent (shortened as ISGD) can be solved in closed-form as:


  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
        =
        
          w
          
            
              o
              l
              d
            
          
        
        +
        
          
            Î·
            
              1
              +
              Î·
              
                |
              
              
                |
              
              
                x
                
                  i
                
              
              
                |
              
              
                
                  |
                
                
                  2
                
              
            
          
        
        (
        
          y
          
            i
          
        
        â
        
          x
          
            i
          
          â²
        
        
          w
          
            
              o
              l
              d
            
          
        
        )
        
          x
          
            i
          
        
        .
      
    
    {\displaystyle w^{\rm {new}}=w^{\rm {old}}+{\frac {\eta }{1+\eta ||x_{i}||^{2}}}(y_{i}-x_{i}'w^{\rm {old}})x_{i}.}
  

This procedure will remain numerically stable virtually for all 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
 as the learning rate is now normalized. Such comparison between classical and implicit stochastic gradient descent in the least squares problem is very similar to the comparison between least mean squares (LMS) and 
normalized least mean squares filter (NLMS).
Even though a closed-form solution for ISGD is only possible in least squares, the procedure can be efficiently implemented in a wide range of models. Specifically, suppose that 
  
    
      
        
          Q
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle Q_{i}(w)}
  
 depends on 
  
    
      
        w
      
    
    {\displaystyle w}
  
 only through a linear combination with features 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
, so that we can write 
  
    
      
        
          â
          
            w
          
        
        
          Q
          
            i
          
        
        (
        w
        )
        =
        â
        q
        (
        
          x
          
            i
          
          â²
        
        w
        )
        
          x
          
            i
          
        
      
    
    {\displaystyle \nabla _{w}Q_{i}(w)=-q(x_{i}'w)x_{i}}
  
, where 

  
    
      
        q
        (
        )
        â
        
          R
        
      
    
    {\displaystyle q()\in \mathbb {R} }
  
 may depend on 
  
    
      
        
          x
          
            i
          
        
        ,
        
          y
          
            i
          
        
      
    
    {\displaystyle x_{i},y_{i}}
  
 as well but not on 
  
    
      
        w
      
    
    {\displaystyle w}
  
 except through 
  
    
      
        
          x
          
            i
          
          â²
        
        w
      
    
    {\displaystyle x_{i}'w}
  
. Least squares obeys this rule, and so does logistic regression, and most generalized linear models. For instance, in least squares, 
  
    
      
        q
        (
        
          x
          
            i
          
          â²
        
        w
        )
        =
        
          y
          
            i
          
        
        â
        
          x
          
            i
          
          â²
        
        w
      
    
    {\displaystyle q(x_{i}'w)=y_{i}-x_{i}'w}
  
, and in logistic regression 
  
    
      
        q
        (
        
          x
          
            i
          
          â²
        
        w
        )
        =
        
          y
          
            i
          
        
        â
        S
        (
        
          x
          
            i
          
          â²
        
        w
        )
      
    
    {\displaystyle q(x_{i}'w)=y_{i}-S(x_{i}'w)}
  
, where 
  
    
      
        S
        (
        u
        )
        =
        
          e
          
            u
          
        
        
          /
        
        (
        1
        +
        
          e
          
            u
          
        
        )
      
    
    {\displaystyle S(u)=e^{u}/(1+e^{u})}
  
 is the logistic function. In Poisson regression, 
  
    
      
        q
        (
        
          x
          
            i
          
          â²
        
        w
        )
        =
        
          y
          
            i
          
        
        â
        
          e
          
            
              x
              
                i
              
              â²
            
            w
          
        
      
    
    {\displaystyle q(x_{i}'w)=y_{i}-e^{x_{i}'w}}
  
, and so on.
In such settings, ISGD is simply implemented as follows. Let 
  
    
      
        f
        (
        Î¾
        )
        =
        Î·
        q
        (
        
          x
          
            i
          
          â²
        
        
          w
          
            o
            l
            d
          
        
        +
        Î¾
        
          |
        
        
          |
        
        
          x
          
            i
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
        )
      
    
    {\displaystyle f(\xi )=\eta q(x_{i}'w^{old}+\xi ||x_{i}||^{2})}
  
, where 
  
    
      
        Î¾
      
    
    {\displaystyle \xi }
  
 is scalar.
Then, ISGD is equivalent to:


  
    
      
        
          w
          
            
              n
              e
              w
            
          
        
        =
        
          w
          
            
              o
              l
              d
            
          
        
        +
        
          Î¾
          
            â
          
        
        
          x
          
            i
          
        
        ,
        Â 
        
          where
        
        Â 
        
          Î¾
          
            â
          
        
        =
        f
        (
        
          Î¾
          
            â
          
        
        )
        .
      
    
    {\displaystyle w^{\rm {new}}=w^{\rm {old}}+\xi ^{\ast }x_{i},~{\text{where}}~\xi ^{\ast }=f(\xi ^{\ast }).}
  

The scaling factor 
  
    
      
        
          Î¾
          
            â
          
        
        â
        
          R
        
      
    
    {\displaystyle \xi ^{\ast }\in \mathbb {R} }
  
 can be found through the bisection method since 
in most regular models, such as the aforementioned generalized linear models, function 
  
    
      
        q
        (
        )
      
    
    {\displaystyle q()}
  
 is decreasing, 
and thus the search bounds for 
  
    
      
        
          Î¾
          
            â
          
        
      
    
    {\displaystyle \xi ^{\ast }}
  
 are 

  
    
      
        [
        min
        (
        0
        ,
        f
        (
        0
        )
        )
        ,
        max
        (
        0
        ,
        f
        (
        0
        )
        )
        ]
      
    
    {\displaystyle [\min(0,f(0)),\max(0,f(0))]}
  
.

Momentum[edit]
Further proposals include the momentum method, which appeared in Rumelhart, Hinton and Williams' paper on backpropagation learning.[17] Stochastic gradient descent with momentum remembers the update Îw at each iteration, and determines the next update as a linear combination of the gradient and the previous update:[18][19]


  
    
      
        Î
        w
        :=
        Î±
        Î
        w
        â
        Î·
        â
        
          Q
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle \Delta w:=\alpha \Delta w-\eta \nabla Q_{i}(w)}
  


  
    
      
        w
        :=
        w
        +
        Î
        w
      
    
    {\displaystyle w:=w+\Delta w}
  

that leads to:


  
    
      
        w
        :=
        w
        â
        Î·
        â
        
          Q
          
            i
          
        
        (
        w
        )
        +
        Î±
        Î
        w
      
    
    {\displaystyle w:=w-\eta \nabla Q_{i}(w)+\alpha \Delta w}
  

where the parameter 
  
    
      
        w
      
    
    {\displaystyle w}
  
 which minimizes 
  
    
      
        Q
        (
        w
        )
      
    
    {\displaystyle Q(w)}
  
 is to be estimated, 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
 is a step size (sometimes called the learning rate in machine learning) and 
  
    
      
        Î±
      
    
    {\displaystyle \alpha }
  
 is an exponential decay factor between 0 and 1 that determines the relative contribution of the current gradient and earlier gradients to the weight change.
The name momentum stems from an analogy to momentum in physics: the weight vector 
  
    
      
        w
      
    
    {\displaystyle w}
  
, thought of as a particle traveling through parameter space,[17] incurs acceleration from the gradient of the loss ("force"). Unlike in classical stochastic gradient descent, it tends to keep traveling in the same direction, preventing oscillations. Momentum has been used successfully by computer scientists in the training of artificial neural networks for several decades.[20]
The momentum method  is closely related to underdamped Langevin dynamics, and may be combined with Simulated Annealing. [21] 

Averaging[edit]
Averaged stochastic gradient descent, invented independently by Ruppert and Polyak in the late 1980s, is ordinary stochastic gradient descent that records an average of its parameter vector over time. That is, the update is the same as for ordinary stochastic gradient descent, but the algorithm also keeps track of[22]


  
    
      
        
          
            
              w
              Â¯
            
          
        
        =
        
          
            1
            t
          
        
        
          â
          
            i
            =
            0
          
          
            t
            â
            1
          
        
        
          w
          
            i
          
        
      
    
    {\displaystyle {\bar {w}}={\frac {1}{t}}\sum _{i=0}^{t-1}w_{i}}
  
.
When optimization is done, this averaged parameter vector takes the place of w.

AdaGrad[edit]
AdaGrad (for adaptive gradient algorithm) is a modified stochastic gradient descent algorithm with per-parameter learning rate, first published in 2011.[23] Informally, this increases the learning rate for sparser parameters and decreases the learning rate for ones that are less sparse. This strategy often improves convergence performance over standard stochastic gradient descent in settings where data is sparse and sparse parameters are more informative. Examples of such applications include natural language processing and image recognition.[23]  It still has a base learning rate Î·, but this is multiplied with the elements of a vector {Gj,j}  which is the diagonal of the outer product matrix


  
    
      
        G
        =
        
          â
          
            Ï
            =
            1
          
          
            t
          
        
        
          g
          
            Ï
          
        
        
          g
          
            Ï
          
          
            
              T
            
          
        
      
    
    {\displaystyle G=\sum _{\tau =1}^{t}g_{\tau }g_{\tau }^{\mathsf {T}}}
  

where 
  
    
      
        
          g
          
            Ï
          
        
        =
        â
        
          Q
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle g_{\tau }=\nabla Q_{i}(w)}
  
, the gradient, at iteration Ï. The diagonal is given by


  
    
      
        
          G
          
            j
            ,
            j
          
        
        =
        
          â
          
            Ï
            =
            1
          
          
            t
          
        
        
          g
          
            Ï
            ,
            j
          
          
            2
          
        
      
    
    {\displaystyle G_{j,j}=\sum _{\tau =1}^{t}g_{\tau ,j}^{2}}
  
.
This vector is updated after every iteration. The formula for an update is now


  
    
      
        w
        :=
        w
        â
        Î·
        
        
          d
          i
          a
          g
        
        (
        G
        
          )
          
            â
            
              
                1
                2
              
            
          
        
        â
        g
      
    
    {\displaystyle w:=w-\eta \,\mathrm {diag} (G)^{-{\frac {1}{2}}}\odot g}
  
[a]
or, written as per-parameter updates,


  
    
      
        
          w
          
            j
          
        
        :=
        
          w
          
            j
          
        
        â
        
          
            Î·
            
              
                G
                
                  j
                  ,
                  j
                
              
            
          
        
        
          g
          
            j
          
        
        .
      
    
    {\displaystyle w_{j}:=w_{j}-{\frac {\eta }{\sqrt {G_{j,j}}}}g_{j}.}
  

Each {G(i,i)}  gives rise to a scaling factor for the learning rate that applies to a single parameter wi. Since the denominator in this factor, 
  
    
      
        
          
            
              G
              
                i
              
            
          
        
        =
        
          
            
              â
              
                Ï
                =
                1
              
              
                t
              
            
            
              g
              
                Ï
              
              
                2
              
            
          
        
      
    
    {\displaystyle {\sqrt {G_{i}}}={\sqrt {\sum _{\tau =1}^{t}g_{\tau }^{2}}}}
  
 is the â2 norm of previous derivatives, extreme parameter updates get dampened, while parameters that get few or small updates receive higher learning rates.[20]
While designed for convex problems, AdaGrad has been successfully applied to non-convex optimization.[24]

RMSProp[edit]
RMSProp (for Root Mean Square Propagation) is also a method in which the learning rate is adapted for each of the parameters. The idea is to divide the learning rate for a weight by a running average of the magnitudes of recent gradients for that weight.[25]
So, first the running average is calculated in terms of means square,


  
    
      
        v
        (
        w
        ,
        t
        )
        :=
        Î³
        v
        (
        w
        ,
        t
        â
        1
        )
        +
        (
        1
        â
        Î³
        )
        (
        â
        
          Q
          
            i
          
        
        (
        w
        )
        
          )
          
            2
          
        
      
    
    {\displaystyle v(w,t):=\gamma v(w,t-1)+(1-\gamma )(\nabla Q_{i}(w))^{2}}
  

where, 
  
    
      
        Î³
      
    
    {\displaystyle \gamma }
  
 is the forgetting factor.
And the parameters are updated as,


  
    
      
        w
        :=
        w
        â
        
          
            Î·
            
              v
              (
              w
              ,
              t
              )
            
          
        
        â
        
          Q
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle w:=w-{\frac {\eta }{\sqrt {v(w,t)}}}\nabla Q_{i}(w)}
  

RMSProp has shown good adaptation of learning rate in different applications. RMSProp can be seen as a generalization of Rprop and is capable to work with mini-batches as well opposed to only full-batches.[26]

Adam[edit]
Adam[27] (short for Adaptive Moment Estimation) is an update to the RMSProp optimizer. In this optimization algorithm, running averages of both the gradients and the second moments of the gradients are used. Given parameters 
  
    
      
        
          w
          
            (
            t
            )
          
        
      
    
    {\displaystyle w^{(t)}}
  
 and a loss function 
  
    
      
        
          L
          
            (
            t
            )
          
        
      
    
    {\displaystyle L^{(t)}}
  
, where 
  
    
      
        t
      
    
    {\displaystyle t}
  
 indexes the current training iteration (indexed at 
  
    
      
        0
      
    
    {\displaystyle 0}
  
), Adam's parameter update is given by:


  
    
      
        
          m
          
            w
          
          
            (
            t
            +
            1
            )
          
        
        â
        
          Î²
          
            1
          
        
        
          m
          
            w
          
          
            (
            t
            )
          
        
        +
        (
        1
        â
        
          Î²
          
            1
          
        
        )
        
          â
          
            w
          
        
        
          L
          
            (
            t
            )
          
        
      
    
    {\displaystyle m_{w}^{(t+1)}\leftarrow \beta _{1}m_{w}^{(t)}+(1-\beta _{1})\nabla _{w}L^{(t)}}
  


  
    
      
        
          v
          
            w
          
          
            (
            t
            +
            1
            )
          
        
        â
        
          Î²
          
            2
          
        
        
          v
          
            w
          
          
            (
            t
            )
          
        
        +
        (
        1
        â
        
          Î²
          
            2
          
        
        )
        (
        
          â
          
            w
          
        
        
          L
          
            (
            t
            )
          
        
        
          )
          
            2
          
        
      
    
    {\displaystyle v_{w}^{(t+1)}\leftarrow \beta _{2}v_{w}^{(t)}+(1-\beta _{2})(\nabla _{w}L^{(t)})^{2}}
  


  
    
      
        
          
            
              
                m
                ^
              
            
          
          
            w
          
        
        =
        
          
            
              m
              
                w
              
              
                (
                t
                +
                1
                )
              
            
            
              1
              â
              
                Î²
                
                  1
                
              
            
          
        
      
    
    {\displaystyle {\hat {m}}_{w}={\frac {m_{w}^{(t+1)}}{1-\beta _{1}}}}
  


  
    
      
        
          
            
              
                v
                ^
              
            
          
          
            w
          
        
        =
        
          
            
              v
              
                w
              
              
                (
                t
                +
                1
                )
              
            
            
              1
              â
              
                Î²
                
                  2
                
              
            
          
        
      
    
    {\displaystyle {\hat {v}}_{w}={\frac {v_{w}^{(t+1)}}{1-\beta _{2}}}}
  


  
    
      
        
          w
          
            (
            t
            +
            1
            )
          
        
        â
        
          w
          
            (
            t
            )
          
        
        â
        Î·
        
          
            
              
                
                  
                    m
                    ^
                  
                
              
              
                w
              
            
            
              
                
                  
                    
                      
                        
                          v
                          ^
                        
                      
                    
                    
                      w
                    
                  
                
              
              +
              Ïµ
            
          
        
      
    
    {\displaystyle w^{(t+1)}\leftarrow w^{(t)}-\eta {\frac {{\hat {m}}_{w}}{{\sqrt {{\hat {v}}_{w}}}+\epsilon }}}
  

where 
  
    
      
        Ïµ
      
    
    {\displaystyle \epsilon }
  
 is a small scalar (e.g. 
  
    
      
        
          10
          
            â
            8
          
        
      
    
    {\displaystyle 10^{-8}}
  
) used to prevent division by 0, and 
  
    
      
        
          Î²
          
            1
          
        
      
    
    {\displaystyle \beta _{1}}
  
 (e.g. 0.9) and 
  
    
      
        
          Î²
          
            2
          
        
      
    
    {\displaystyle \beta _{2}}
  
 (e.g. 0.999) are the forgetting factors for gradients and second moments of gradients, respectively. Squaring and square-rooting is done element-wise. {

Backtracking line search[edit]
Backtracking line search is another variant of gradient descent. All of the below are sourced from the mentioned link. It is based on a condition known as the ArmijoâGoldstein condition. Both methods allow learning rates to change at each iteration; however, the manner of the change is different. Backtracking line search uses function evaluations to check Armijo's condition, and in principle the loop in the algorithm for determining the learning rates can be long and unknown in advance. Adaptive SGD does not need a loop in determining learning rates. On the other hand, adaptive SGD does not guarantee the "descent property" â which Backtracking line search enjoys â which is that 
  
    
      
        f
        (
        
          x
          
            n
            +
            1
          
        
        )
        â¤
        f
        (
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle f(x_{n+1})\leq f(x_{n})}
  
 for all n. If the gradient of the cost function is globally Lipschitz continuous, with Lipschitz constant L, and learning rate is chosen of the order 1/L, then the standard version of SGD is a special case of backtracking line search.

Second-order methods[edit]
A stochastic analogue of the standard (deterministic) NewtonâRaphson algorithm (a "second-order" method) provides an asymptotically optimal or near-optimal form of iterative optimization in the setting of stochastic approximation[citation needed]. A method that uses direct measurements of the Hessian matrices of the summands in the empirical risk function was developed by Byrd, Hansen, Nocedal, and Singer.[28] However, directly determining the required Hessian matrices for optimization may not be possible in practice. Practical and theoretically sound methods for second-order versions of SGD that do not require direct Hessian information are given by Spall and others.[29][30][31] (A less efficient method based on finite differences, instead of simultaneous perturbations, is given by Ruppert.[32]) These methods not requiring direct Hessian information are based on either values of the summands in the above empirical risk function or values of the gradients of the summands (i.e., the SGD inputs). In particular, second-order optimality is asymptotically achievable without direct calculation of the Hessian matrices of the summands in the empirical risk function.

Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ 
  
    
      
        â
      
    
    {\displaystyle \odot }
  
 is the element-wise product.


See also[edit]
Backtracking line search
Coordinate descent â changes one coordinate at a time, rather than one example
Linear classifier
Online machine learning
Stochastic hill climbing
References[edit]


^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Bottou, LÃ©on; Bousquet, Olivier (2012). "The Tradeoffs of Large Scale Learning".  In Sra, Suvrit; Nowozin, Sebastian; Wright, Stephen J. (eds.). Optimization for Machine Learning. Cambridge: MIT Press. pp.Â 351â368. ISBNÂ 978-0-262-01646-9.

^ Bottou, LÃ©on (1998). "Online Algorithms and Stochastic Approximations". Online Learning and Neural Networks. Cambridge University Press. ISBNÂ 978-0-521-65263-6.

^ Ferguson, Thomas S. (1982). "An inconsistent maximum likelihood estimate". Journal of the American Statistical Association. 77 (380): 831â834. doi:10.1080/01621459.1982.10477894. JSTORÂ 2287314.

^ Bottou, LÃ©on; Bousquet, Olivier (2008). The Tradeoffs of Large Scale Learning. Advances in Neural Information Processing Systems. Vol.Â 20. pp.Â 161â168.

^ Murphy, Kevin (2021). Probabilistic Machine Learning: An Introduction. Probabilistic Machine Learning: An Introduction. MIT Press. Retrieved 10 April 2021.

^ Bottou, LÃ©on (1998). "Online Algorithms and Stochastic Approximations". Online Learning and Neural Networks. Cambridge University Press. ISBNÂ 978-0-521-65263-6.

^ Kiwiel, Krzysztof C. (2001). "Convergence and efficiency of subgradient methods for quasiconvex minimization". Mathematical Programming, Series A. Vol.Â 90, no.Â 1. Berlin, Heidelberg: Springer. pp.Â 1â25. doi:10.1007/PL00011414. ISSNÂ 0025-5610. MRÂ 1819784.

^ Robbins, Herbert; Siegmund, David O. (1971). "A convergence theorem for non negative almost supermartingales and some applications".  In Rustagi, Jagdish S. (ed.). Optimizing Methods in Statistics. Academic Press. ISBNÂ 0-12-604550-X.

^ Jenny Rose Finkel, Alex Kleeman, Christopher D. Manning (2008). Efficient, Feature-based, Conditional Random Field Parsing. Proc. Annual Meeting of the ACL.

^ LeCun, Yann A., et al. "Efficient backprop." Neural networks: Tricks of the trade. Springer Berlin Heidelberg, 2012. 9-48

^ Jerome R. Krebs, John E. Anderson, David Hinkley, Ramesh Neelamani, Sunwoong Lee, Anatoly Baumstein, and Martin-Daniel Lacasse, (2009), "Fast full-wavefield seismic inversion using encoded sources," GEOPHYSICS 74: WCC177-WCC188.

^ Avi Pfeffer. "CS181 Lecture 5 â Perceptrons" (PDF). Harvard University.[permanent dead link]

^ Goodfellow, Ian; Bengio, Yoshua; Courville, Aaron (2016). Deep Learning. MIT Press. p.Â 291. ISBNÂ 978-0262035613.

^ Cited by Darken, Christian; Moody, John (1990). Fast adaptive k-means clustering: some empirical results. Int'l Joint Conf. on Neural Networks (IJCNN). IEEE. doi:10.1109/IJCNN.1990.137720.

^ Spall, J. C. (2003). Introduction to Stochastic Search and Optimization: Estimation, Simulation, and Control. Hoboken, NJ: Wiley. pp.Â Sections 4.4, 6.6, and 7.5. ISBNÂ 0-471-33052-3.

^ Toulis, Panos; Airoldi, Edoardo (2017). "Asymptotic and finite-sample properties of estimators based on stochastic gradients". Annals of Statistics. 45 (4): 1694â1727. arXiv:1408.2923. doi:10.1214/16-AOS1506. S2CIDÂ 10279395.

^ Jump up to: a b Rumelhart, David E.; Hinton, Geoffrey E.; Williams, Ronald J. (8 October 1986). "Learning representations by back-propagating errors". Nature. 323 (6088): 533â536. Bibcode:1986Natur.323..533R. doi:10.1038/323533a0. S2CIDÂ 205001834.

^ Sutskever, Ilya; Martens, James; Dahl, George; Hinton, Geoffrey E. (June 2013).  Sanjoy Dasgupta and David Mcallester (ed.). On the importance of initialization and momentum in deep learning (PDF). In Proceedings of the 30th international conference on machine learning (ICML-13). Vol.Â 28. Atlanta, GA. pp.Â 1139â1147. Retrieved 14 January 2016.

^ Sutskever, Ilya (2013). Training recurrent neural networks (PDF) (Ph.D.). University of Toronto. p.Â 74.

^ Jump up to: a b Zeiler, Matthew D. (2012). "ADADELTA: An adaptive learning rate method". arXiv:1212.5701 [cs.LG].

^ Borysenko, Oleksandr; Byshkin, Maksym (2021). "CoolMomentum: A Method for Stochastic Optimization by Langevin Dynamics with Simulated Annealing". Scientific Reports. 11 (1): 10705. arXiv:2005.14605. Bibcode:2021NatSR..1110705B. doi:10.1038/s41598-021-90144-3. PMCÂ 8139967. PMIDÂ 34021212.

^ Polyak, Boris T.; Juditsky, Anatoli B. (1992). "Acceleration of stochastic approximation by averaging" (PDF). SIAM J. Control Optim. 30 (4): 838â855. doi:10.1137/0330046.

^ Jump up to: a b Duchi, John; Hazan, Elad; Singer, Yoram (2011). "Adaptive subgradient methods for online learning and stochastic optimization" (PDF). JMLR. 12: 2121â2159.

^ Gupta, Maya R.; Bengio, Samy; Weston, Jason (2014). "Training highly multiclass classifiers" (PDF). JMLR. 15 (1): 1461â1492.

^ Hinton, Geoffrey. "Lecture 6e rmsprop: Divide the gradient by a running average of its recent magnitude" (PDF). p.Â 26. Retrieved 19 March 2020.

^ Hinton, Geoffrey. "Lecture 6e rmsprop: Divide the gradient by a running average of its recent magnitude" (PDF). p.Â 29. Retrieved 19 March 2020.

^ Kingma, Diederik; Ba, Jimmy (2014). "Adam: A Method for Stochastic Optimization". arXiv:1412.6980 [cs.LG].

^ Byrd, R. H.; Hansen, S. L.; Nocedal, J.; Singer, Y. (2016). "A Stochastic Quasi-Newton method for Large-Scale Optimization". SIAM Journal on Optimization. 26 (2): 1008â1031. arXiv:1401.7020. doi:10.1137/140954362. S2CIDÂ 12396034.

^ Spall, J. C. (2000). "Adaptive Stochastic Approximation by the Simultaneous Perturbation Method". IEEE Transactions on Automatic Control. 45 (10): 1839â1853. doi:10.1109/TAC.2000.880982.

^ Spall, J. C. (2009). "Feedback and Weighting Mechanisms for Improving Jacobian Estimates in the Adaptive Simultaneous Perturbation Algorithm". IEEE Transactions on Automatic Control. 54 (6): 1216â1229. doi:10.1109/TAC.2009.2019793.

^ Bhatnagar, S.; Prasad, H. L.; Prashanth, L. A. (2013). Stochastic Recursive Algorithms for Optimization: Simultaneous Perturbation Methods. London: Springer. ISBNÂ 978-1-4471-4284-3.

^ Ruppert, D. (1985). "A Newton-Raphson Version of the Multivariate Robbins-Monro Procedure". Annals of Statistics. 13 (1): 236â245. doi:10.1214/aos/1176346589.


Further reading[edit]
Bottou, LÃ©on (2004), "Stochastic Learning", Advanced Lectures on Machine Learning, LNAI, vol.Â 3176, Springer, pp.Â 146â168, ISBNÂ 978-3-540-23122-6
Buduma, Nikhil; Locascio, Nicholas (2017), "Beyond Gradient Descent", Fundamentals of Deep LearningÂ : Designing Next-Generation Machine Intelligence Algorithms, O'Reilly
LeCun, Yann A.; Bottou, LÃ©on; Orr, Genevieve B.; MÃ¼ller, Klaus-Robert (2012), "Efficient BackProp", Neural Networks: Tricks of the Trade, Springer, pp.Â 9â48, ISBNÂ 978-3-642-35288-1
Spall, James C. (2003), Introduction to Stochastic Search and Optimization, Wiley, ISBNÂ 978-0-471-33052-3
External links[edit]
Using stochastic gradient descent in C++, Boost, Ublas for linear regression
Machine Learning Algorithms
"Gradient Descent, How Neural Networks Learn". 3Blue1Brown. October 16, 2017. Archived from the original on 2021-12-22 â via YouTube.
Goh (April 4, 2017). "Why Momentum Really Works". Distill. 2 (4). doi:10.23915/distill.00006. Interactive paper explaining momentum.
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hide.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteDifferentiable computingGeneral
Differentiable programming
Neural Turing machine
Differentiable neural computer
Automatic differentiation
Neuromorphic engineering
Cable theory
Pattern recognition
Computational learning theory
Tensor calculus
Concepts
Gradient descent
SGD
Clustering
Regression
Overfitting
Adversary
Attention
Convolution
Loss functions
Backpropagation
Normalization
Activation
Softmax
Sigmoid
Rectifier
Regularization
Datasets
Augmentation
Programming languages
Python
Julia
Application
Machine learning
Artificial neural network
Deep learning
Scientific computing
Artificial Intelligence
Hardware
IPU
TPU
VPU
Memristor
SpiNNaker
Software library
TensorFlow
PyTorch
Keras
Theano
ImplementationAudio-visual
AlexNet
WaveNet
Human image synthesis
HWR
OCR
Speech synthesis
Speech recognition
Facial recognition
AlphaFold
DALL-E
Verbal
Word2vec
Transformer
BERT
NMT
Project Debater
Watson
GPT-2
GPT-3
Decisional
AlphaGo
AlphaZero
Q-learning
SARSA
OpenAI Five
Self-driving car
MuZero
Action selection
Robot control
People
Alex Graves
Ian Goodfellow
Yoshua Bengio
Geoffrey Hinton
Yann LeCun
Andrew Ng
Demis Hassabis
David Silver
Fei-Fei Li
Organizations
DeepMind
OpenAI
MIT CSAIL
Mila
Google Brain
FAIR

 Portals
Computer programming
Technology
 Category
Artificial neural networks
Machine learning





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Stochastic_gradient_descent&oldid=1064704823"
		Categories: Stochastic optimizationComputational statisticsGradient methodsM-estimatorsMachine learning algorithmsConvex optimizationStatistical approximationsHidden categories: All articles with dead external linksArticles with dead external links from June 2018Articles with permanently dead external linksArticles with short descriptionShort description matches WikidataAll articles with unsourced statementsArticles with unsourced statements from July 2015Articles with unsourced statements from April 2020
	
