
Title:
Word (computer architecture)
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Base memory unit handled by a computer


.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Computer architecture bit widths
Bit
1248121618242628303132364045486064128256512bit slicing

Application
8163264

Binary floating-point precision
16 (ÃÂ½)2432 (Ã1)4064 (Ã2)80128 (Ã4)256 (Ã8)

Decimal floating-point precision
3264128
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
In computing, a word is the natural unit of data used by a particular processor design. A word is a fixed-sized piece of data handled as a unit by the instruction set or the hardware of the processor. The number of bits in a word (the word size, word width, or word length) is an important characteristic of any specific processor design or computer architecture.  
The size of a word is reflected in many aspects of a computer's structure and operation; the majority of the registers in a processor are usually word sized and the largest piece of data that can be transferred to and from the working memory in a single operation is a word in many (not all) architectures. The largest possible address size, used to designate a location in memory, is typically a hardware word (here, "hardware word" means the full-sized natural word of the processor, as opposed to any other definition used).
Documentation for computers with fixed word size commonly stated memory sizes in words rather than bytes or characters. Terms such as kilowords (KW) meaning 1024 words (210) and megawords (MW) meaning 1,048,576 words (220) were normally used. With standardization on 8-bit bytes and byte addressability, stating memory sizes in bytes, kilobytes, and megabytes has become the norm.
Several of the earliest computers (and a few modern as well) used binary-coded decimal rather than plain binary, typically having a word size of 10 or 12 decimal digits, and some early decimal computers had no fixed word length at all. Early binary systems tended to use word lengths that were some multiple of 6-bits, with the 36-bit word being especially common on mainframe computers. The introduction of ASCII led to the move to systems with word lengths that were a multiple of 8-bits, with 16-bit machines being popular in the 1970s before the move to modern processors with 32 or 64 bits.[1] Special-purpose designs like digital signal processors, may have any word length from 4 to 80 bits.[1]
The size of a word can sometimes differ from the expected due to backward compatibility with earlier computers. If multiple compatible variations or a family of processors share a common architecture and instruction set but differ in their word sizes, their documentation and software may become notationally complex to accommodate the difference (see Size families below).

Contents

1 Uses of words
2 Word size choice

2.1 Variable-word architectures
2.2 Word, bit and byte addressing
2.3 Powers of two


3 Size families
4 Table of word sizes
5 See also
6 Notes
7 References



Uses of words[edit]
Depending on how a computer is organized, word-size units may be used for:

Fixed-point numbers
Holders for fixed point, usually integer, numerical values may be available in one or in several different sizes, but one of the sizes available will almost always be the word. The other sizes, if any, are likely to be multiples or fractions of the word size. The smaller sizes are normally used only for efficient use of memory; when loaded into the processor, their values usually go into a larger, word sized holder.
Floating-point numbers
Holders for floating-point numerical values are typically either a word or a multiple of a word.
Addresses
Holders for memory addresses must be of a size capable of expressing the needed range of values but not be excessively large, so often the size used is the word though it can also be a multiple or fraction of the word size.
Registers
Processor registers are designed with a size appropriate for the type of data they hold, e.g. integers, floating-point numbers, or addresses. Many computer architectures use general-purpose registers that are capable of storing data in multiple representations.
Memoryâprocessor transfer
When the processor reads from the memory subsystem into a register or writes a register's value to memory, the amount of data transferred is often a word. Historically, this amount of bits which could be transferred in one cycle was also called a catena in some environments (such as the Bull GAMMA 60Â [fr]).[2][3] In simple memory subsystems, the word is transferred over the memory data bus, which typically has a width of a word or half-word. In memory subsystems that use caches, the word-sized transfer is the one between the processor and the first level of cache; at lower levels of the memory hierarchy larger transfers (which are a multiple of the word size) are normally used.
Unit of address resolution
In a given architecture, successive address values designate successive units of memory; this unit is the unit of address resolution. In most computers, the unit is either a character (e.g. a byte) or a word. (A few computers have used bit resolution.) If the unit is a word, then a larger amount of memory can be accessed using an address of a given size at the cost of added complexity to access individual characters. On the other hand, if the unit is a byte, then individual characters can be addressed (i.e. selected during the memory operation).
Instructions
Machine instructions are normally the size of the architecture's word, such as in RISC architectures, or a multiple of the "char" size that is a fraction of it. This is a natural choice since instructions and data usually share the same memory subsystem. In Harvard architectures the word sizes of instructions and data need not be related, as instructions and data are stored in different memories; for example, the processor in the 1ESS electronic telephone switch had 37-bit instructions and 23-bit data words.
Word size choice[edit]
When a computer architecture is designed, the choice of a word size is of substantial importance.  There are design considerations which encourage particular bit-group sizes for particular uses (e.g. for addresses), and these considerations point to different sizes for different uses.  However, considerations of economy in design strongly push for one size, or a very few sizes related by multiples or fractions (submultiples) to a primary size.  That preferred size becomes the word size of the architecture.
Character size was in the past (pre-variable-sized character encoding) one of the influences on unit of address resolution and the choice of word size.  Before the mid-1960s, characters were most often stored in six bits; this allowed no more than 64 characters, so the alphabet was limited to upper case.  Since it is efficient in time and space to have the word size be a multiple of the character size, word sizes in this period were usually multiples of 6 bits (in binary machines).  A common choice then was the 36-bit word, which is also a good size for the numeric properties of a floating point format.
After the introduction of the IBM System/360 design, which used eight-bit characters and supported lower-case letters, the standard size of a character (or more accurately, a byte) became eight bits.  Word sizes thereafter were naturally multiples of eight bits, with 16, 32, and 64 bits being commonly used.

Variable-word architectures[edit]
Early machine designs included some that used what is often termed a variable word length.  In this type of organization, a numeric operand had no fixed length but rather its end was detected when a character with a special marking, often called word mark, was encountered.  Such machines often used binary-coded decimal for numbers.  This class of machines included the IBM 702, IBM 705, IBM 7080, IBM 7010, UNIVAC 1050, IBM 1401, and IBM 1620.
Most of these machines work on one unit of memory at a time and since each instruction or datum is several units long, each instruction takes several cycles just to access memory.  These machines are often quite slow because of this.  For example, instruction fetches on an IBM 1620 Model I take 8 cycles just to read the 12 digits of the instruction (the Model II reduced this to 6 cycles, or 4 cycles if the instruction did not need both address fields). Instruction execution took a completely variable number of cycles, depending on the size of the operands.

Word, bit and byte addressing[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main articles: word addressing and byte addressing
The memory model of an architecture is strongly influenced by the word size.  In particular, the resolution of a memory address, that is, the smallest unit that can be designated by an address, has often been chosen to be the word.  In this approach, the word-addressable machine approach, address values which differ by one designate adjacent memory words.  This is natural in machines which deal almost always in word (or multiple-word) units, and has the advantage of allowing instructions to use minimally sized fields to contain addresses, which can permit a smaller instruction size or a larger variety of instructions.
When byte processing is to be a significant part of the workload, it is usually more advantageous to use the byte, rather than the word, as the unit of address resolution. Address values which differ by one designate adjacent bytes in memory.  This allows an arbitrary character within a character string to be addressed straightforwardly.  A word can still be addressed, but the address to be used requires a few more bits than the word-resolution alternative.  The word size needs to be an integer multiple of the character size in this organization.  This addressing approach was used in the IBM 360, and has been the most common approach in machines designed since then.
When the workload involves processing fields of different sizes, it can be advantageous to address to the bit. Machines with bit addressing may have some instructions that use a programmer-defined byte size and other instructions that operate on fixed data sizes. As an example, on the IBM 7030[4] ("Stretch"), a floating point instruction can only address words while an integer arithmetic instruction can specify a field length of 1-64 bits, a byte size of 1-8 bits and an accumulator offset of 0-127 bits. 
In at byte-addressable machine with storage-to-storage (SS) instructions, there are typically move instructions to copy one or multiple bytes from one arbitrary location to another. In a byte-oriented (byte-addressable) machine without SS instructions, moving a single byte from one arbitrary location to another is typically:

LOAD the source byte
STORE the result back in the target byte
Individual bytes can be accessed on a word-oriented machine in one of two ways.  Bytes can be manipulated by a combination of shift and mask operations in registers. Moving a single byte from one arbitrary location to another may require the equivalent of the following:

LOAD the word containing the source byte
SHIFT the source word to align the desired byte to the correct position in the target word
AND the source word with a mask to zero out all but the desired bits
LOAD the word containing the target byte
AND the target word with a mask to zero out the target byte
OR the registers containing the source and target words to insert the source byte
STORE the result back in the target location
Alternatively many word-oriented machines implement byte operations with instructions using special byte pointers in registers or memory.  For example, the PDP-10 byte pointer contained the size of the byte in bits (allowing different-sized bytes to be accessed), the bit position of the byte within the word, and the word address of the data.  Instructions could automatically adjust the pointer to the next byte on, for example, load and deposit (store) operations.

Powers of two[edit]
Different amounts of memory are used to store data values with different degrees of precision. The commonly used sizes are usually a power of two multiple of the unit of address resolution (byte or word).  Converting the index of an item in an array into the memory address offset of the item then requires only a shift operation rather than a multiplication. In some cases this relationship can also avoid the use of division operations. As a result, most modern computer designs have word sizes (and other operand sizes) that are a power of two times the size of a byte.

Size families[edit]
As computer designs have grown more complex, the central importance of a single word size to an architecture has decreased.  Although more capable hardware can use a wider variety of sizes of data, market forces exert pressure to maintain backward compatibility while extending processor capability.  As a result, what might have been the central word size in a fresh design has to coexist as an alternative size to the original word size in a backward compatible design. The original word size remains available in future designs, forming the basis of a size family.
In the mid-1970s, DEC designed the VAX to be a 32-bit successor of the 16-bit PDP-11. They used word for a 16-bit quantity, while longword referred to a 32-bit quantity. This was in contrast to earlier machines, where the natural unit of addressing memory would be called a word, while a quantity that is one half a word would be called a halfword. In fitting with this scheme, a VAX quadword is 64 bits.  They continued this word/longword/quadword terminology with the 64-bit Alpha.
Another example is the x86 family, of which processors of three different word lengths (16-bit, later 32- and 64-bit) have been released, while word continues to designate a 16-bit quantity. As software is routinely ported from one word-length to the next, some APIs and documentation define or refer to an older (and thus shorter) word-length than the full word length on the CPU that software may be compiled for. Also, similar to how bytes are used for small numbers in many programs, a shorter word (16 or 32 bits) may be used in contexts where the range of a wider word is not needed (especially where this can save considerable stack space or cache memory space). For example, Microsoft's Windows API maintains the programming language definition of WORD as 16 bits, despite the fact that the API may be used on a 32- or 64-bit x86 processor, where the standard word size would be 32 or 64 bits, respectively. Data structures containing such different sized words refer to them as WORD (16 bits/2 bytes), DWORD (32 bits/4 bytes) and QWORD (64 bits/8 bytes) respectively. A similar phenomenon has developed in Intel's x86 assembly language â because of the support for various sizes (and backward compatibility) in the instruction set, some instruction mnemonics carry "d" or "q" identifiers denoting "double-", "quad-" or "double-quad-", which are in terms of the architecture's original 16-bit word size.
In general, new processors must use the same data word lengths and virtual address widths as an older processor to have binary compatibility with that older processor.
Often carefully written source code â written with source-code compatibility and software portability in mind â can be recompiled to run on a variety of processors, even ones with different data word lengths or different address widths or both.

Table of word sizes[edit]



key: bit: bits, d: decimal digits, w: word size of architecture, n: variable size


Year

Computer architecture

Word size w

Integer sizes

FloatingÂ­point sizes

Instruction sizes

Unit of addressresolution

Char size


1837

BabbageAnalytical engine

50 d

w

â

Five different cards were used for different functions, exact size of cards not known.

w

â


1941

Zuse Z3

22 bit

â

w

8 bit

w

â


1942

ABC

50 bit

w

â

â

â

â


1944

Harvard Mark I

23 d

w

â

24 bit

â

â


1946(1948){1953}

ENIAC(w/Panel #16[5]){w/Panel #26[6]}

10 d

w, 2w(w){w}

â

â(2 d, 4 d, 6 d, 8 d){2 d, 4 d, 6 d, 8 d}

ââ{w}

â


1948

Manchester Baby

32 bit

w

â

w

w

â


1951

UNIVAC I

12 d

w

â

.mw-parser-output .frac{white-space:nowrap}.mw-parser-output .frac .num,.mw-parser-output .frac .den{font-size:80%;line-height:0;vertical-align:super}.mw-parser-output .frac .den{vertical-align:sub}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}1â2w

w

1 d


1952

IAS machine

40 bit

w

â

1â2w

w

5 bit


1952

Fast Universal Digital Computer M-2

34 bit

w?

w

34 bit = 4-bit opcode plus 3Ã10Â bit address

10 bit

â


1952

IBM 701

36 bit

1â2w, w

â

1â2w

1â2w, w

6 bit


1952

UNIVAC 60

n d

1 d, ... 10 d

â

â

â

2 d, 3 d


1952

ARRA I

30 bit

w

â

w

w

5 bit


1953

IBM 702

n d

0 d, ... 511 d

â

5 d

d

1 d


1953

UNIVAC 120

n d

1 d, ... 10 d

â

â

â

2 d, 3 d


1953

ARRA II

30 bit

w

2w

1â2w

w

5 bit


1954(1955)

IBM 650(w/IBM 653)

10 d

w

â(w)

w

w

2 d


1954

IBM 704

36 bit

w

w

w

w

6 bit


1954

IBM 705

n d

0 d, ... 255 d

â

5 d

d

1 d


1954

IBM NORC

16 d

w

w, 2w

w

w

â


1956

IBM 305

n d

1 d, ... 100 d

â

10 d

d

1 d


1956

ARMAC

34 bit

w

w

1â2w

w

5 bit, 6 bit


1957

Autonetics Recomp I

40 bit

w, 79 bit, 8 d, 15 d

â

1â2w

1â2w, w

5 bit


1958

UNIVAC II

12 d

w

â

1â2w

w

1 d


1958

SAGE

32 bit

1â2w

â

w

w

6 bit


1958

Autonetics Recomp II

40 bit

w, 79 bit, 8 d, 15 d

2w

1â2w

1â2w, w

5 bit


1958

Setun

6Â trit (~9.5Â bits)[a]

up to 6Â tryte



up to 3Â trytes



4Â trit?


1958

Electrologica X1

27 bit

w

2w

w

w

5 bit, 6 bit


1959

IBM 1401

n d

1 d, ...

â

1 d, 2 d, 4 d, 5 d, 7 d, 8 d

d

1 d


1959(TBD)

IBM 1620

n d

2 d, ...

â(4 d, ... 102 d)

12 d

d

2 d


1960

LARC

12 d

w, 2w

w, 2w

w

w

2 d


1960

CDC 1604

48 bit

w

w

1â2w

w

6 bit


1960

IBM 1410

n d

1 d, ...

â

1 d, 2 d, 6 d, 7 d, 11 d, 12 d

d

1 d


1960

IBM 7070

10 d

w

w

w

w, d

2 d


1960

PDP-1

18 bit

w

â

w

w

6 bit


1960

Elliott 803

39 bit












1961

IBM 7030(Stretch)

64 bit

1 bit, ... 64 bit,1 d, ... 16 d

w

1â2w, w

b, 1â2w, w

1 bit, ... 8 bit


1961

IBM 7080

n d

0 d, ... 255 d

â

5 d

d

1 d


1962

GE-6xx

36 bit

w, 2 w

w, 2 w, 80 bit

w

w

6 bit, 9 bit


1962

UNIVAC III

25 bit

w, 2w, 3w, 4w, 6 d, 12 d

â

w

w

6 bit


1962

Autonetics D-17BMinuteman I Guidance Computer

27 bit

11 bit, 24 bit

â

24 bit

w

â


1962

UNIVAC 1107

36 bit

1â6w, 1â3w, 1â2w, w

w

w

w

6 bit


1962

IBM 7010

n d

1 d, ...

â

1 d, 2 d, 6 d, 7 d, 11 d, 12 d

d

1 d


1962

IBM 7094

36 bit

w

w, 2w

w

w

6 bit


1962

SDS 9 Series

24 bit

w

2w

w

w




1963(1966)

Apollo Guidance Computer

15 bit

w

â

w, 2w

w

â


1963

Saturn Launch Vehicle Digital Computer

26 bit

w

â

13 bit

w

â


1964/1966

PDP-6/PDP-10

36 bit

w

w, 2 w

w

w

6 bit, 9 bit (typical)


1964

 Titan 

48 bit

w

w

w

w

w


1964

CDC 6600

60 bit

w

w

1â4w, 1â2w

w

6 bit


1964

Autonetics D-37CMinuteman II Guidance Computer

27 bit

11 bit, 24 bit

â

24 bit

w

4 bit, 5 bit


1965

Gemini Guidance Computer

39 bit

26 bit

â

13 bit

13 bit, 26

âbit


1965

IBM 360

32 bit

1â2w, w,1 d, ... 16 d

w, 2w

1â2w, w, 11â2w

8 bit

8 bit


1965

UNIVAC 1108

36 bit

1â6w, 1â4w, 1â3w, 1â2w, w, 2w

w, 2w

w

w

6 bit, 9 bit


1965

PDP-8

12 bit

w

â

w

w

8 bit


1965

Electrologica X8

27 bit

w

2w

w

w

6 bit, 7 bit


1966

SDS Sigma 7

32 bit

1â2w, w

w, 2w

w

8 bit

8 bit


1969

Four-Phase Systems AL1

8 bit

w

â

?

?

?


1970

MP944

20 bit

w

â

?

?

?


1970

PDP-11

16 bit

w

2w, 4w

w, 2w, 3w

8 bit

8 bit


1971

TMS1802NC

4 bit

w

â

?

?

â


1971

Intel 4004

4 bit

w, d

â

2w, 4w

w

â


1972

Intel 8008

8 bit

w, 2 d

â

w, 2w, 3w

w

8 bit


1972

Calcomp 900

9 bit

w

â

w, 2w

w

8 bit


1974

Intel 8080

8 bit

w, 2w, 2 d

â

w, 2w, 3w

w

8 bit


1975

ILLIAC IV

64 bit

w

w, 1â2w

w

w

â


1975

Motorola 6800

8 bit

w, 2 d

â

w, 2w, 3w

w

8 bit


1975

MOS Tech. 6501MOS Tech. 6502

8 bit

w, 2 d

â

w, 2w, 3w

w

8 bit


1976

Cray-1

64 bit

24 bit, w

w

1â4w, 1â2w

w

8 bit


1976

Zilog Z80

8 bit

w, 2w, 2 d

â

w, 2w, 3w, 4w, 5w

w

8 bit


1978(1980)

16-bit x86 (Intel 8086)(w/floating point: Intel 8087)

16 bit

1â2w, w, 2 d

â(2w, 4w, 5w, 17 d)

1â2w, w, ... 7w

8 bit

8 bit


1978

VAX

32 bit

1â4w, 1â2w, w, 1 d, ... 31 d, 1 bit, ... 32 bit

w, 2w

1â4w, ... 141â4w

8 bit

8 bit


1979(1984)

Motorola 68000 series(w/floating point)

32 bit

1â4w, 1â2w, w, 2 d

â(w, 2w, 21â2w)

1â2w, w, ... 71â2w

8 bit

8 bit


1985

IA-32 (Intel 80386) (w/floating point)

32 bit

1â4w, 1â2w, w

â(w, 2w, 80 bit)

8 bit, ... 120 bit1â4w ... 33â4w

8 bit

8 bit


1985

ARMv1

32 bit

1â4w, w

â

w

8 bit

8 bit


1985

MIPS

32 bit

1â4w, 1â2w, w

w, 2w

w

8 bit

8 bit


1991

Cray C90

64 bit

32 bit, w

w

1â4w, 1â2w, 48 bit

w

8 bit


1992

Alpha

64 bit

8 bit, 1â4w, 1â2w, w

1â2w, w

1â2w

8 bit

8 bit


1992

PowerPC

32 bit

1â4w, 1â2w, w

w, 2w

w

8 bit

8 bit


1996

ARMv4(w/Thumb)

32 bit

1â4w, 1â2w, w

â

w(1â2w, w)

8 bit

8 bit


2000

IBM z/Architecture(w/vector facility)

64 bit

1â4w, 1â2w, w1 d, ... 31 d

1â2w, w, 2w

1â4w, 1â2w, 3â4w

8 bit

8 bit, UTF-16, UTF-32


2001

IA-64

64 bit

8 bit, 1â4w, 1â2w, w

1â2w, w

41 bit

8 bit

8 bit


2001

ARMv6(w/VFP)

32 bit

8 bit, 1â2w, w

â(w, 2w)

1â2w, w

8 bit

8 bit


2003

x86-64

64 bit

8 bit, 1â4w, 1â2w, w

1â2w, w, 80 bit

8 bit, ... 120 bit

8 bit

8 bit


2013

ARMv8-A and ARMv9-A

64 bit

8 bit, 1â4w, 1â2w, w

1â2w, w

1â2w

8 bit

8 bit


Year

Computer architecture

Word size w

Integer sizes

FloatingÂ­point sizes

Instruction sizes

Unit of addressresolution

Char size


key: bit: bits, d: decimal digits, w: word size of architecture, n: variable size
[7][8]
See also[edit]
Integer (computer science)
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ The bit equivalent is computed by taking the amount of information entropy provided by the trit, which is 
  
    
      
        
          log
          
            2
          
        
        â¡
        (
        3
        )
      
    
    {\displaystyle \log _{2}(3)}
  
. This gives an equivalent of about 9.51 bits for 6 trits.


References[edit]


^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Beebe, Nelson H. F. (2017-08-22). "Chapter I. Integer arithmetic". The Mathematical-Function Computation Handbook - Programming Using the MathCW Portable Software Library (1Â ed.). Salt Lake City, UT, USA: Springer International Publishing AG. p.Â 970. doi:10.1007/978-3-319-64110-2. ISBNÂ 978-3-319-64109-6. LCCNÂ 2017947446. S2CIDÂ 30244721.

^ Dreyfus, Phillippe (1958-05-08) [1958-05-06].  Written at Los Angeles, California, USA. System design of the Gamma 60 (PDF). Western Joint Computer Conference: Contrasts in Computers. ACM, New York, NY, USA. pp.Â 130â133. IRE-ACM-AIEE '58 (Western). Archived (PDF) from the original on 2017-04-03. Retrieved 2017-04-03. [...] Internal data code is used: Quantitative (numerical) data are coded in a 4-bit decimal code; qualitative (alpha-numerical) data are coded in a 6-bit alphanumerical code. The internal instruction code means that the instructions are coded in straight binary code.As to the internal information length, the information quantum is called a "catena," and it is composed of 24 bits representing either 6 decimal digits, or 4 alphanumerical characters. This quantum must contain a multiple of 4 and 6 bits to represent a whole number of decimal or alphanumeric characters. Twenty-four bits was found to be a good compromise between the minimum 12 bits, which would lead to a too-low transfer flow from a parallel readout core memory, and 36 bits or more, which was judged as too large an information quantum. The catena is to be considered as the equivalent of a character in variable word length machines, but it cannot be called so, as it may contain several characters. It is transferred in series to and from the main memory.Not wanting to call a "quantum" a word, or a set of characters a letter, (a word is a word, and a quantum is something else), a new word was made, and it was called a "catena." It is an English word and exists in Webster's although it does not in French. Webster's definition of the word catena is, "a connected series;" therefore, a 24-bit information item. The word catena will be used hereafter.The internal code, therefore, has been defined. Now what are the external data codes? These depend primarily upon the information handling device involved. The Gamma 60Â [fr] is designed to handle information relevant to any binary coded structure. Thus an 80-column punched card is considered as a 960-bit information item; 12 rows multiplied by 80 columns equals 960 possible punches; is stored as an exact image in 960 magnetic cores of the main memory with 2 card columns occupying one catena. [...]

^ Blaauw, Gerrit Anne; Brooks, Jr., Frederick Phillips; Buchholz, Werner (1962). "4: Natural Data Units" (PDF).  In Buchholz, Werner (ed.). Planning a Computer System â Project Stretch. McGraw-Hill Book Company, Inc. / The Maple Press Company, York, PA. pp.Â 39â40. LCCNÂ 61-10466. Archived (PDF) from the original on 2017-04-03. Retrieved 2017-04-03. [...] Terms used here to describe the structure imposed by the machine design, in addition to bit, are listed below.Byte denotes a group of bits used to encode a character, or the number of bits transmitted in parallel to and from input-output units. A term other than character is used here because a given character may be represented in different applications by more than one code, and different codes may use different numbers of bits (i.e., different byte sizes). In input-output transmission the grouping of bits may be completely arbitrary and have no relation to actual characters. (The term is coined from bite, but respelled to avoid accidental mutation to bit.)A word consists of the number of data bits transmitted in parallel from or to memory in one memory cycle. Word size is thus defined as a structural property of the memory. (The term catena was coined for this purpose by the designers of the Bull GAMMA 60Â [fr] computer.)Block refers to the number of words transmitted to or from an input-output unit in response to a single input-output instruction. Block size is a structural property of an input-output unit; it may have been fixed by the design or left to be varied by the program. [...]

^ "Format" (PDF). Reference Manual 7030 Data Processing System (PDF). IBM. August 1961. pp.Â 50â57. Retrieved 2021-12-15.

^ Clippinger, Richard F. (1948-09-29). "A Logical Coding System Applied to the ENIAC (Electronic Numerical Integrator and Computer)". Aberdeen Proving Ground, Maryland, US: Ballistic Research Laboratories. Report No. 673; Project No. TB3-0007 of the Research and Development Division, Ordnance Department. Retrieved 2017-04-05.{{cite web}}:  CS1 maint: url-status (link)

^ Clippinger, Richard F. (1948-09-29). "A Logical Coding System Applied to the ENIAC". Aberdeen Proving Ground, Maryland, US: Ballistic Research Laboratories. Section VIII: Modified ENIAC. Retrieved 2017-04-05.{{cite web}}:  CS1 maint: url-status (link)

^ Blaauw, Gerrit Anne; Brooks, Jr., Frederick Phillips (1997). Computer Architecture: Concepts and Evolution (1Â ed.). Addison-Wesley. ISBNÂ 0-201-10557-8. (1213 pages) (NB. This is a single-volume edition. This work was also available in a two-volume version.)

^ Ralston, Anthony; Reilly, Edwin D. (1993). Encyclopedia of Computer Science (3rdÂ ed.). Van Nostrand Reinhold. ISBNÂ 0-442-27679-6.


.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}vteUnits of informationPlatform-independent units
bit
hextet
octet
Platform-dependent units
nibble
byte
syllable
word
Metric bit units
kilobit
megabit
gigabit
terabit
petabit
exabit
zettabit
yottabit
Metric byte units
kilobyte
megabyte
gigabyte
IEC bit units
kibibit
mebibit
gibibit
tebibit
pebibit
exbibit
zebibit
yobibit

vteData typesUninterpreted
Bit
Byte
Trit
Tryte
Word
Bit array
Numeric
Arbitrary-precision or bignum
Complex
Decimal
Fixed point
Floating point
Reduced precision
Minifloat
Half precision
bfloat16
Single precision
Double precision
Quadruple precision
Octuple precision
Extended precision
Long double
Integer
signedness
Interval
Rational
Pointer
Address
physical
virtual
Reference
Text
Character
String
null-terminated
Composite
Algebraic data type
generalized
Array
Associative array
Class
Dependent
Equality
Inductive
Intersection
List
Object
metaobject
Option type
Product
Record or Struct
Refinement
Set
Union
tagged
Other
Boolean
Bottom type
Collection
Enumerated type
Exception
Function type
Opaque data type
Recursive data type
Semaphore
Stream
Top type
Type class
Unit type
Void
Relatedtopics
Abstract data type
Data structure
Generic
Kind
metaclass
Object type
Parametric polymorphism
Primitive data type
Protocol
interface
Subtyping
Type constructor
Type conversion
Type system
Type theory
Variable

vteProcessor technologiesModels
Abstract machine
Stored-program computer
Finite-state machine
with datapath
Hierarchical
Deterministic finite automaton
Queue automaton
Cellular automaton
Quantum cellular automaton
Turing machine
Alternating Turing machine
Universal
PostâTuring
Quantum
Nondeterministic Turing machine
Probabilistic Turing machine
Hypercomputation
Zeno machine
Belt machine
Stack machine
Register machines
Counter
Pointer
Random-access
Random-access stored program
Architecture
Microarchitecture
Von Neumann
Harvard
modified
Dataflow
Transport-triggered
Cellular
Endianness
Memory access
NUMA
HUMA
Loadâstore
Register/memory
Cache hierarchy
Memory hierarchy
Virtual memory
Secondary storage
Heterogeneous
Fabric
Multiprocessing
Cognitive
Neuromorphic
Instruction setarchitecturesTypes
Orthogonal instruction set
CISC
RISC
Application-specific
EDGE
TRIPS
VLIW
EPIC
MISC
OISC
NISC
ZISC
VISC architecture
Quantum computing
Comparison
Addressing modes
Instructionsets
Motorola 68000 series
VAX
PDP-11
x86
ARM
Stanford MIPS
MIPS
MIPS-X
Power
POWER
PowerPC
Power ISA
Clipper architecture
SPARC
SuperH
DEC Alpha
ETRAX CRIS
M32R
Unicore
Itanium
OpenRISC
RISC-V
MicroBlaze
LMC
System/3x0
S/360
S/370
S/390
z/Architecture
Tilera ISA
VISC architecture
Epiphany architecture
Others
ExecutionInstruction pipelining
Pipeline stall
Operand forwarding
Classic RISC pipeline
Hazards
Data dependency
Structural
Control
False sharing
Out-of-order
Scoreboarding
Tomasulo algorithm
Reservation station
Re-order buffer
Register renaming
Wide-issue
Speculative
Branch prediction
Memory dependence prediction
ParallelismLevel
Bit
Bit-serial
Word
Instruction
Pipelining
Scalar
Superscalar
Task
Thread
Process
Data
Vector
Memory
Distributed
Multithreading
Temporal
Simultaneous
Hyperthreading
Speculative
Preemptive
Cooperative
Flynn's taxonomy
SISD
SIMD
Array processing (SIMT)
Pipelined processing
Associative processing
SWAR
MISD
MIMD
SPMD
Processorperformance
Transistor count
Instructions per cycle (IPC)
Cycles per instruction (CPI)
Instructions per second (IPS)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic updates per second (SUPS)
Performance per watt (PPW)
Cache performance metrics
Computer performance by orders of magnitude
Types
Central processing unit (CPU)
Graphics processing unit (GPU)
GPGPU
Vector
Barrel
Stream
Tile processor
Coprocessor
PAL
ASIC
FPGA
FPOA
CPLD
Multi-chip module (MCM)
System in a package (SiP)
Package on a package (PoP)
By application
Embedded system
Microprocessor
Microcontroller
Mobile
Notebook
Ultra-low-voltage
ASIP
Soft microprocessor
Systemson chip
System on a chip (SoC)
Multiprocessor (MPSoC)
Programmable (PSoC)
Network on a chip (NoC)
Hardwareaccelerators
Coprocessor
AI accelerator
Graphics processing unit (GPU)
Image processor
Vision processing unit (VPU)
Physics processing unit (PPU)
Digital signal processor (DSP)
Tensor Processing Unit (TPU)
Secure cryptoprocessor
Network processor
Baseband processor

Word size
1-bit
4-bit
8-bit
12-bit
15-bit
16-bit
24-bit
32-bit
48-bit
64-bit
128-bit
256-bit
512-bit
bit slicing
others
variable
Core count
Single-core
Multi-core
Manycore
Heterogeneous architecture
Components
Core
Cache
CPU cache
Scratchpad memory
Data cache
Instruction cache
replacement policies
coherence
Bus
Clock rate
Clock signal
FIFO
Functionalunits
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Memory management unit (MMU)
Loadâstore unit
Translation lookaside buffer (TLB)
Branch predictor
Branch target predictor
Integrated memory controller (IMC)
Memory management unit
Instruction decoder
Logic
Combinational
Sequential
Glue
Logic gate
Quantum
Array
Registers
Processor register
Status register
Stack register
Register file
Memory buffer
Memory address register
Program counter
Control unit
Hardwired control unit
Instruction unit
Data buffer
Write buffer
Microcode ROM
Horizontal microcode
Counter
Datapath
Multiplexer
Demultiplexer
Adder
Multiplier
CPU
Binary decoder
Address decoder
Sum-addressed decoder
Barrel shifter
Circuitry
Integrated circuit
3D
Mixed-signal
Power management
Boolean
Digital
Analog
Quantum
Switch

Powermanagement
PMU
APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating
Performance per watt (PPW)
Related
History of general-purpose CPUs
Microprocessor chronology
Processor design
Digital electronics
Hardware security module
Semiconductor device fabrication
Tickâtock model
Pin grid array
Chip carrier





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Word_(computer_architecture)&oldid=1061573797"
		Categories: Data typesData unitPrimitive typesUnits of informationHidden categories: CS1 location testCS1 maint: url-statusArticles with short descriptionShort description matches WikidataUse dmy dates from August 2019
	
