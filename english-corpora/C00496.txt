
Title:
Pushdown automaton
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Type of automaton

Classes of automata (Clicking on each layer gets an article on that subject)
In the theory of computation, a branch of theoretical computer science, a pushdown automaton (PDA) is   
a type of automaton that employs a stack.
Pushdown automata are used in theories about what can be computed by machines. They are more capable than finite-state machines but less capable than Turing machines (see below).
Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages, with the former often used in parser design.
The term "pushdown" refers to the fact that the stack can be regarded as being "pushed down" like a tray dispenser at a cafeteria, since the operations never work on elements other than the top element.  A stack automaton, by contrast, does allow access to and operations on deeper elements.  Stack automata can recognize a strictly larger set of languages than pushdown automata.[1]
A nested stack automaton allows full access, and also allows stacked values to be entire sub-stacks rather than just single finite symbols.

Contents

1 Informal description
2 Formal definition
3 Example
4 Understanding the computation process
5 PDA and context-free languages
6 PDA and Turing machines
7 Generalized pushdown automaton (GPDA)
8 Stack automaton
9 Alternating pushdown automata
10 See also
11 Notes
12 References
13 External links



Informal description[edit]
  A diagram of a pushdown automaton
A finite-state machine just looks at the input signal and the current state: it has no stack to work with.  It chooses a new state, the result of following the transition. A pushdown automaton (PDA) differs from a finite state machine in two ways:

It can use the top of the stack to decide which transition to take.
It can manipulate the stack as part of performing a transition.
A pushdown automaton reads a given input string from left to right. In each step, it chooses a transition by indexing a table by input symbol, current state, and the symbol at the top of the stack.  A pushdown automaton can also manipulate the stack, as part of performing a transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. 
Put together: Given an input symbol, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack.
If, in every situation, at most one such transition action is possible, then the automaton is called a deterministic pushdown automaton (DPDA). In general, if several actions are possible, then the automaton is called a general, or nondeterministic, PDA. A given input string may drive a nondeterministic pushdown automaton to one of several configuration sequences; if one of them leads to an accepting configuration after reading the complete input string, the latter is said to belong to the language accepted by the automaton.

Formal definition[edit]
We use standard formal language notation: 
  
    
      
        
          Î
          
            â
          
        
      
    
    {\displaystyle \Gamma ^{*}}
  
 denotes the set of finite-length strings over alphabet 
  
    
      
        Î
      
    
    {\displaystyle \Gamma }
  
 and 
  
    
      
        Îµ
      
    
    {\displaystyle \varepsilon }
  
 denotes the empty string.
A PDA is formally defined as a 7-tuple:

  
    
      
        M
        =
        (
        Q
        ,
        Î£
        ,
        Î
        ,
        Î´
        ,
        
          q
          
            0
          
        
        ,
        Z
        ,
        F
        )
      
    
    {\displaystyle M=(Q,\Sigma ,\Gamma ,\delta ,q_{0},Z,F)}
  

where


  
    
      
        Q
      
    
    {\displaystyle Q}
  
 is a finite set of states

  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
 is a finite set which is called the input alphabet

  
    
      
        Î
      
    
    {\displaystyle \Gamma }
  
 is a finite set which is called the stack alphabet

  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 is a finite subset of 
  
    
      
        Q
        Ã
        (
        Î£
        âª
        {
        Îµ
        }
        )
        Ã
        Î
        Ã
        Q
        Ã
        
          Î
          
            â
          
        
      
    
    {\displaystyle Q\times (\Sigma \cup \{\varepsilon \})\times \Gamma \times Q\times \Gamma ^{*}}
  
, the transition relation

  
    
      
        
          q
          
            0
          
        
        â
        Q
      
    
    {\displaystyle q_{0}\in Q}
  
 is the start state

  
    
      
        Z
        â
        Î
      
    
    {\displaystyle Z\in \Gamma }
  
 is the initial stack symbol

  
    
      
        F
        â
        Q
      
    
    {\displaystyle F\subseteq Q}
  
 is the set of accepting states
An element 
  
    
      
        (
        p
        ,
        a
        ,
        A
        ,
        q
        ,
        Î±
        )
        â
        Î´
      
    
    {\displaystyle (p,a,A,q,\alpha )\in \delta }
  
 is a transition of 
  
    
      
        M
      
    
    {\displaystyle M}
  
. It has the intended meaning that 
  
    
      
        M
      
    
    {\displaystyle M}
  
, in state 
  
    
      
        p
        â
        Q
      
    
    {\displaystyle p\in Q}
  
, on the input 
  
    
      
        a
        â
        Î£
        âª
        {
        Îµ
        }
      
    
    {\displaystyle a\in \Sigma \cup \{\varepsilon \}}
  
 and with 
  
    
      
        A
        â
        Î
      
    
    {\displaystyle A\in \Gamma }
  
 as topmost stack symbol, may read 
  
    
      
        a
      
    
    {\displaystyle a}
  
, change the state to 
  
    
      
        q
      
    
    {\displaystyle q}
  
, pop 
  
    
      
        A
      
    
    {\displaystyle A}
  
, replacing it by pushing 
  
    
      
        Î±
        â
        
          Î
          
            â
          
        
      
    
    {\displaystyle \alpha \in \Gamma ^{*}}
  
. The 
  
    
      
        (
        Î£
        âª
        {
        Îµ
        }
        )
      
    
    {\displaystyle (\Sigma \cup \{\varepsilon \})}
  
 component of the transition relation is used to formalize that the PDA can either read a letter from the input, or proceed leaving the input untouched.[citation needed]
In many texts[2]:â110â the transition relation is replaced by an (equivalent) formalization, where


  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 is the transition function, mapping 
  
    
      
        Q
        Ã
        (
        Î£
        âª
        {
        Îµ
        }
        )
        Ã
        Î
      
    
    {\displaystyle Q\times (\Sigma \cup \{\varepsilon \})\times \Gamma }
  
 into finite subsets of 
  
    
      
        Q
        Ã
        
          Î
          
            â
          
        
      
    
    {\displaystyle Q\times \Gamma ^{*}}
  

Here 
  
    
      
        Î´
        (
        p
        ,
        a
        ,
        A
        )
      
    
    {\displaystyle \delta (p,a,A)}
  
 contains all possible actions in state 
  
    
      
        p
      
    
    {\displaystyle p}
  
 with 
  
    
      
        A
      
    
    {\displaystyle A}
  
 on the stack, while reading 
  
    
      
        a
      
    
    {\displaystyle a}
  
 on the input. One writes for example 
  
    
      
        Î´
        (
        p
        ,
        a
        ,
        A
        )
        =
        {
        (
        q
        ,
        B
        A
        )
        }
      
    
    {\displaystyle \delta (p,a,A)=\{(q,BA)\}}
  
 precisely when 
  
    
      
        (
        q
        ,
        B
        A
        )
        â
        {
        (
        q
        ,
        B
        A
        )
        }
        ,
        (
        q
        ,
        B
        A
        )
        â
        Î´
        (
        p
        ,
        a
        ,
        A
        )
        ,
      
    
    {\displaystyle (q,BA)\in \{(q,BA)\},(q,BA)\in \delta (p,a,A),}
  
 because 
  
    
      
        (
        (
        p
        ,
        a
        ,
        A
        )
        ,
        {
        (
        q
        ,
        B
        A
        )
        }
        )
        â
        Î´
      
    
    {\displaystyle ((p,a,A),\{(q,BA)\})\in \delta }
  
. Note that finite in this definition is essential.
 Computations 

  a step of the pushdown automaton
In order to formalize the semantics of the pushdown automaton a description of the current situation is introduced. Any 3-tuple 
  
    
      
        (
        p
        ,
        w
        ,
        Î²
        )
        â
        Q
        Ã
        
          Î£
          
            â
          
        
        Ã
        
          Î
          
            â
          
        
      
    
    {\displaystyle (p,w,\beta )\in Q\times \Sigma ^{*}\times \Gamma ^{*}}
  
 is called an instantaneous description (ID) of 
  
    
      
        M
      
    
    {\displaystyle M}
  
, which includes the current state, the part of the input tape that has not been read, and the contents of the stack (topmost symbol written first). The transition relation 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 defines the step-relation 
  
    
      
        
          â¢
          
            M
          
        
      
    
    {\displaystyle \vdash _{M}}
  
 of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 on instantaneous descriptions. For instruction 
  
    
      
        (
        p
        ,
        a
        ,
        A
        ,
        q
        ,
        Î±
        )
        â
        Î´
      
    
    {\displaystyle (p,a,A,q,\alpha )\in \delta }
  
 there exists a step 
  
    
      
        (
        p
        ,
        a
        x
        ,
        A
        Î³
        )
        
          â¢
          
            M
          
        
        (
        q
        ,
        x
        ,
        Î±
        Î³
        )
      
    
    {\displaystyle (p,ax,A\gamma )\vdash _{M}(q,x,\alpha \gamma )}
  
, for every 
  
    
      
        x
        â
        
          Î£
          
            â
          
        
      
    
    {\displaystyle x\in \Sigma ^{*}}
  
 and every 
  
    
      
        Î³
        â
        
          Î
          
            â
          
        
      
    
    {\displaystyle \gamma \in \Gamma ^{*}}
  
.
In general pushdown automata are nondeterministic meaning that in a given instantaneous description 
  
    
      
        (
        p
        ,
        w
        ,
        Î²
        )
      
    
    {\displaystyle (p,w,\beta )}
  
 there may be several possible steps. Any of these steps can be chosen in a computation.
With the above definition in each step always a single symbol (top of the stack) is popped, replacing it with as many symbols as necessary. As a consequence no step is defined when the stack is empty.
Computations of the pushdown automaton are sequences of steps. The computation starts in the initial state 
  
    
      
        
          q
          
            0
          
        
      
    
    {\displaystyle q_{0}}
  
 with the initial stack symbol 
  
    
      
        Z
      
    
    {\displaystyle Z}
  
 on the stack, and a string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 on the input tape, thus with initial description 
  
    
      
        (
        
          q
          
            0
          
        
        ,
        w
        ,
        Z
        )
      
    
    {\displaystyle (q_{0},w,Z)}
  
. 
There are two modes of accepting. The pushdown automaton either accepts by final state, which means after reading its input the automaton reaches an accepting state (in 
  
    
      
        F
      
    
    {\displaystyle F}
  
), or it accepts by empty stack (
  
    
      
        Îµ
      
    
    {\displaystyle \varepsilon }
  
), which means after reading its input the automaton empties its stack. The first acceptance mode uses the internal memory (state), the second the external memory (stack).
Formally one defines


  
    
      
        L
        (
        M
        )
        =
        {
        w
        â
        
          Î£
          
            â
          
        
        
          |
        
        (
        
          q
          
            0
          
        
        ,
        w
        ,
        Z
        )
        
          â¢
          
            M
          
          
            â
          
        
        (
        f
        ,
        Îµ
        ,
        Î³
        )
      
    
    {\displaystyle L(M)=\{w\in \Sigma ^{*}|(q_{0},w,Z)\vdash _{M}^{*}(f,\varepsilon ,\gamma )}
  
 with 
  
    
      
        f
        â
        F
      
    
    {\displaystyle f\in F}
  
 and 
  
    
      
        Î³
        â
        
          Î
          
            â
          
        
        }
      
    
    {\displaystyle \gamma \in \Gamma ^{*}\}}
  
 (final state)

  
    
      
        N
        (
        M
        )
        =
        {
        w
        â
        
          Î£
          
            â
          
        
        
          |
        
        (
        
          q
          
            0
          
        
        ,
        w
        ,
        Z
        )
        
          â¢
          
            M
          
          
            â
          
        
        (
        q
        ,
        Îµ
        ,
        Îµ
        )
      
    
    {\displaystyle N(M)=\{w\in \Sigma ^{*}|(q_{0},w,Z)\vdash _{M}^{*}(q,\varepsilon ,\varepsilon )}
  
 with 
  
    
      
        q
        â
        Q
        }
      
    
    {\displaystyle q\in Q\}}
  
 (empty stack)
Here 
  
    
      
        
          â¢
          
            M
          
          
            â
          
        
      
    
    {\displaystyle \vdash _{M}^{*}}
  
 represents the reflexive and transitive closure of the step relation 
  
    
      
        
          â¢
          
            M
          
        
      
    
    {\displaystyle \vdash _{M}}
  
 meaning any number of consecutive steps (zero, one or more).
For each single pushdown automaton these two languages need to have no relation: they may be equal but usually this is not the case. A specification of the automaton should also include the intended mode of acceptance. Taken over all pushdown automata both acceptance conditions define the same family of languages.
Theorem. For each pushdown automaton 
  
    
      
        M
      
    
    {\displaystyle M}
  
 one may construct a pushdown automaton 
  
    
      
        
          M
          â²
        
      
    
    {\displaystyle M'}
  
 such that 
  
    
      
        L
        (
        M
        )
        =
        N
        (
        
          M
          â²
        
        )
      
    
    {\displaystyle L(M)=N(M')}
  
, and vice versa, for each pushdown automaton 
  
    
      
        M
      
    
    {\displaystyle M}
  
 one may construct a pushdown automaton 
  
    
      
        
          M
          â²
        
      
    
    {\displaystyle M'}
  
 such that 
  
    
      
        N
        (
        M
        )
        =
        L
        (
        
          M
          â²
        
        )
      
    
    {\displaystyle N(M)=L(M')}
  


Example[edit]
The following is the formal description of the PDA which recognizes the language 
  
    
      
        {
        
          0
          
            n
          
        
        
          1
          
            n
          
        
        â£
        n
        â¥
        0
        }
      
    
    {\displaystyle \{0^{n}1^{n}\mid n\geq 0\}}
  
 by final state:

  PDA for 
  
    
      
        {
        
          0
          
            n
          
        
        
          1
          
            n
          
        
        â£
        n
        â¥
        0
        }
      
    
    {\displaystyle \{0^{n}1^{n}\mid n\geq 0\}}
  
(by final state)

  
    
      
        M
        =
        (
        Q
        ,
        Â 
        Î£
        ,
        Â 
        Î
        ,
        Â 
        Î´
        ,
        Â 
        
          q
          
            0
          
        
        ,
        Â 
        Z
        ,
        Â 
        F
        )
      
    
    {\displaystyle M=(Q,\ \Sigma ,\ \Gamma ,\ \delta ,\ q_{0},\ Z,\ F)}
  
, where

states: 
  
    
      
        Q
        =
        {
        p
        ,
        q
        ,
        r
        }
      
    
    {\displaystyle Q=\{p,q,r\}}
  

input alphabet: 
  
    
      
        Î£
        =
        {
        0
        ,
        1
        }
      
    
    {\displaystyle \Sigma =\{0,1\}}
  

stack alphabet: 
  
    
      
        Î
        =
        {
        A
        ,
        Z
        }
      
    
    {\displaystyle \Gamma =\{A,Z\}}
  

start state: 
  
    
      
        
          q
          
            0
          
        
        =
        p
      
    
    {\displaystyle q_{0}=p}
  

start stack symbol: Z
accepting states: 
  
    
      
        F
        =
        {
        r
        }
      
    
    {\displaystyle F=\{r\}}
  

The transition relation 
  
    
      
        Î´
      
    
    {\displaystyle \delta }
  
 consists of the following six instructions:


  
    
      
        (
        p
        ,
        0
        ,
        Z
        ,
        p
        ,
        A
        Z
        )
      
    
    {\displaystyle (p,0,Z,p,AZ)}
  
,

  
    
      
        (
        p
        ,
        0
        ,
        A
        ,
        p
        ,
        A
        A
        )
      
    
    {\displaystyle (p,0,A,p,AA)}
  
,

  
    
      
        (
        p
        ,
        Ïµ
        ,
        Z
        ,
        q
        ,
        Z
        )
      
    
    {\displaystyle (p,\epsilon ,Z,q,Z)}
  
,

  
    
      
        (
        p
        ,
        Ïµ
        ,
        A
        ,
        q
        ,
        A
        )
      
    
    {\displaystyle (p,\epsilon ,A,q,A)}
  
,

  
    
      
        (
        q
        ,
        1
        ,
        A
        ,
        q
        ,
        Ïµ
        )
      
    
    {\displaystyle (q,1,A,q,\epsilon )}
  
, and

  
    
      
        (
        q
        ,
        Ïµ
        ,
        Z
        ,
        r
        ,
        Z
        )
      
    
    {\displaystyle (q,\epsilon ,Z,r,Z)}
  
.
In words, the first two instructions say that in state p any time the symbol 0 is read, one A is pushed onto the stack. Pushing symbol A on top of another A is formalized as replacing top A by AA (and similarly for pushing symbol A on top of a Z).
The third and fourth instructions say that, at any moment the automaton may move from state p to state q.
The fifth instruction says that in state q, for each symbol 1 read, one A is popped.
Finally, the sixth instruction says that the machine may move from state q to accepting state r only when the stack consists of a single Z.
There seems to be no generally used representation for PDA. Here we have depicted the instruction 
  
    
      
        (
        p
        ,
        a
        ,
        A
        ,
        q
        ,
        Î±
        )
      
    
    {\displaystyle (p,a,A,q,\alpha )}
  
 by an edge from state p to state q labelled by  
  
    
      
        a
        ;
        A
        
          /
        
        Î±
      
    
    {\displaystyle a;A/\alpha }
  
 (read a; replace A by 
  
    
      
        Î±
      
    
    {\displaystyle \alpha }
  
).

Understanding the computation process[edit]
  accepting computation for 0011
The following illustrates how the above PDA computes on different input strings. The subscript M from the step symbol 
  
    
      
        â¢
      
    
    {\displaystyle \vdash }
  
 is here omitted.

Input string = 0011. There are various computations, depending on the moment the move from state p to state q is made. Only one of these is accepting.

  
    
      
        (
        p
        ,
        0011
        ,
        Z
        )
        â¢
        (
        q
        ,
        0011
        ,
        Z
        )
        â¢
        (
        r
        ,
        0011
        ,
        Z
        )
      
    
    {\displaystyle (p,0011,Z)\vdash (q,0011,Z)\vdash (r,0011,Z)}
  
The final state is accepting, but the input is not accepted this way as it has not been read.
  
    
      
        (
        p
        ,
        0011
        ,
        Z
        )
        â¢
        (
        p
        ,
        011
        ,
        A
        Z
        )
        â¢
        (
        q
        ,
        011
        ,
        A
        Z
        )
      
    
    {\displaystyle (p,0011,Z)\vdash (p,011,AZ)\vdash (q,011,AZ)}
  
No further steps possible.
  
    
      
        (
        p
        ,
        0011
        ,
        Z
        )
        â¢
        (
        p
        ,
        011
        ,
        A
        Z
        )
        â¢
        (
        p
        ,
        11
        ,
        A
        A
        Z
        )
        â¢
        (
        q
        ,
        11
        ,
        A
        A
        Z
        )
        â¢
        (
        q
        ,
        1
        ,
        A
        Z
        )
        â¢
        (
        q
        ,
        Ïµ
        ,
        Z
        )
        â¢
        (
        r
        ,
        Ïµ
        ,
        Z
        )
      
    
    {\displaystyle (p,0011,Z)\vdash (p,011,AZ)\vdash (p,11,AAZ)\vdash (q,11,AAZ)\vdash (q,1,AZ)\vdash (q,\epsilon ,Z)\vdash (r,\epsilon ,Z)}
  
Accepting computation: ends in accepting state, while complete input has been read.Input string = 00111. Again there are various computations. None of these is accepting.

  
    
      
        (
        p
        ,
        00111
        ,
        Z
        )
        â¢
        (
        q
        ,
        00111
        ,
        Z
        )
        â¢
        (
        r
        ,
        00111
        ,
        Z
        )
      
    
    {\displaystyle (p,00111,Z)\vdash (q,00111,Z)\vdash (r,00111,Z)}
  
The final state is accepting, but the input is not accepted this way as it has not been read.
  
    
      
        (
        p
        ,
        00111
        ,
        Z
        )
        â¢
        (
        p
        ,
        0111
        ,
        A
        Z
        )
        â¢
        (
        q
        ,
        0111
        ,
        A
        Z
        )
      
    
    {\displaystyle (p,00111,Z)\vdash (p,0111,AZ)\vdash (q,0111,AZ)}
  
No further steps possible.
  
    
      
        (
        p
        ,
        00111
        ,
        Z
        )
        â¢
        (
        p
        ,
        0111
        ,
        A
        Z
        )
        â¢
        (
        p
        ,
        111
        ,
        A
        A
        Z
        )
        â¢
        (
        q
        ,
        111
        ,
        A
        A
        Z
        )
        â¢
        (
        q
        ,
        11
        ,
        A
        Z
        )
        â¢
        (
        q
        ,
        1
        ,
        Z
        )
        â¢
        (
        r
        ,
        1
        ,
        Z
        )
      
    
    {\displaystyle (p,00111,Z)\vdash (p,0111,AZ)\vdash (p,111,AAZ)\vdash (q,111,AAZ)\vdash (q,11,AZ)\vdash (q,1,Z)\vdash (r,1,Z)}
  
The final state is accepting, but the input is not accepted this way as it has not been (completely) read.
PDA and context-free languages[edit]
Every context-free grammar can be transformed into an equivalent nondeterministic pushdown automaton. The derivation process of the grammar is simulated in a leftmost way. Where the grammar rewrites a nonterminal, the PDA takes the topmost nonterminal from its stack and replaces it by the right-hand part of a grammatical rule (expand). Where the grammar generates a terminal symbol, the PDA reads a symbol from input when it is the topmost symbol on the stack (match). In a sense the stack of the PDA contains the unprocessed data of the grammar, corresponding to a pre-order traversal of a derivation tree.
Technically, given a context-free grammar, the PDA has a single state, 1, and its transition relation is constructed as follows.


  
    
      
        (
        1
        ,
        Îµ
        ,
        A
        ,
        1
        ,
        Î±
        )
      
    
    {\displaystyle (1,\varepsilon ,A,1,\alpha )}
  
 for each rule 
  
    
      
        A
        â
        Î±
      
    
    {\displaystyle A\to \alpha }
  
 (expand)

  
    
      
        (
        1
        ,
        a
        ,
        a
        ,
        1
        ,
        Îµ
        )
      
    
    {\displaystyle (1,a,a,1,\varepsilon )}
  
 for each terminal symbol 
  
    
      
        a
      
    
    {\displaystyle a}
  
 (match)
The PDA accepts by empty stack. Its initial stack symbol is the grammar's start symbol.[citation needed]
For a context-free grammar in Greibach normal form, defining (1,Î³) â Î´(1,a,A) for each grammar rule A â aÎ³ also yields an equivalent nondeterministic pushdown automaton.[2]:â115â
The converse, finding a grammar for a given PDA, is not that easy. The trick is to code two states of the PDA into the nonterminals of the grammar.
Theorem. For each pushdown automaton 
  
    
      
        M
      
    
    {\displaystyle M}
  
 one may construct a context-free grammar 
  
    
      
        G
      
    
    {\displaystyle G}
  
 such that 
  
    
      
        N
        (
        M
        )
        =
        L
        (
        G
        )
      
    
    {\displaystyle N(M)=L(G)}
  
.[2]:â116â
The language of strings accepted by a deterministic pushdown automaton is called a deterministic context-free language. Not all context-free languages are deterministic.[note 1] As a consequence, the DPDA is a strictly weaker variant of the PDA and there exists no algorithm for converting a PDA to an equivalent DPDA, if such a DPDA exists.[citation needed]
A finite automaton with access to two stacks is a more powerful device, equivalent in power to a Turing machine.[2]:â171â  A linear bounded automaton is a device which is more powerful than a pushdown automaton but less so than a Turing machine.[note 2]

PDA and Turing machines[edit]
A pushdown automaton is computationally equivalent to a 'restricted' Turing Machine (TM) with two tapes which is restricted in the following manner- On the first tape, the TM can only read the input and move from left to right (it cannot make changes). On the second tape, it can only 'push' and 'pop' data. Or equivalently, it can read, write and move left and right with the restriction that the only action it can perform at each step is to either delete the left-most character in the string (pop) or add an extra character left to the left-most character in the string (push).
That a PDA is weaker than a TM can be brought down to the fact that the procedure 'pop' deletes some data. In order to make a PDA as strong as a TM, we need to save somewhere the data lost through 'pop'. We can achieve this by introducing a second stack. In the TM model of PDA of last paragraph, this is equivalent to a TM with 3 tapes, where the first tape is the read-only input tape, and the 2nd and the 3rd tape are the 'push and pop' (stack) tapes. In order for such a PDA to simulate any given TM, we give the input of the PDA to the first tape, while keeping both the stacks empty. It then goes on to push all the input from the input tape to the first stack. When the entire input is transferred to the 1st stack, now we proceed like a normal TM, where moving right on the tape is the same as popping a symbol from the 1st stack and pushing a (possibly updated) symbol into the second stack, and moving left corresponds to popping a symbol from the 2nd stack and pushing (a possibly updated) symbol into the first stack. We hence have a PDA with 2 stacks that can simulate any TM.

Generalized pushdown automaton (GPDA)[edit]
A GPDA is a PDA that writes an entire string of some known length to the stack or removes an entire string from the stack in one step.
A GPDA is formally defined as a 6-tuple: 


  
    
      
        M
        =
        (
        Q
        ,
        Â 
        Î£
        ,
        Â 
        Î
        ,
        Â 
        Î´
        ,
        Â 
        
          q
          
            0
          
        
        ,
        Â 
        F
        )
      
    
    {\displaystyle M=(Q,\ \Sigma ,\ \Gamma ,\ \delta ,\ q_{0},\ F)}
  

where 
  
    
      
        Q
        ,
        Î£
        
        ,
        Î
        
        ,
        
          q
          
            0
          
        
      
    
    {\displaystyle Q,\Sigma \,,\Gamma \,,q_{0}}
  
, and 
  
    
      
        F
      
    
    {\displaystyle F}
  
 are defined the same way as a PDA.


  
    
      
        
        Î´
      
    
    {\displaystyle \,\delta }
  
: 
  
    
      
        Q
        Ã
        
          Î£
          
            Ïµ
          
        
        Ã
        
          Î
          
            â
          
        
        â¶
        P
        (
        Q
        Ã
        
          Î
          
            â
          
        
        )
      
    
    {\displaystyle Q\times \Sigma _{\epsilon }\times \Gamma ^{*}\longrightarrow P(Q\times \Gamma ^{*})}
  

is the transition function.
Computation rules for a GPDA are the same as a PDA except that the 
  
    
      
        
          a
          
            i
            +
            1
          
        
      
    
    {\displaystyle a_{i+1}}
  
's and 
  
    
      
        
          b
          
            i
            +
            1
          
        
      
    
    {\displaystyle b_{i+1}}
  
's are now strings instead of symbols.
GPDA's and PDA's are equivalent in that if a language is recognized by a PDA, it is also recognized by a GPDA and vice versa.
One can formulate an analytic proof for the equivalence of GPDA's and PDA's using the following simulation:
Let 
  
    
      
        Î´
        (
        
          q
          
            1
          
        
        ,
        w
        ,
        
          x
          
            1
          
        
        
          x
          
            2
          
        
        â
        
          x
          
            m
          
        
        )
        â¶
        (
        
          q
          
            2
          
        
        ,
        
          y
          
            1
          
        
        
          y
          
            2
          
        
        .
        .
        .
        
          y
          
            n
          
        
        )
      
    
    {\displaystyle \delta (q_{1},w,x_{1}x_{2}\cdot x_{m})\longrightarrow (q_{2},y_{1}y_{2}...y_{n})}
  
 be a transition of the GPDA
where 
  
    
      
        
          q
          
            1
          
        
        ,
        
          q
          
            2
          
        
        â
        Q
        ,
        w
        â
        
          Î£
          
            Ïµ
          
        
        ,
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            m
          
        
        â
        
          Î
          
            â
          
        
        ,
        m
        â¥
        0
        ,
        
          y
          
            1
          
        
        ,
        
          y
          
            2
          
        
        ,
        â¦
        ,
        
          y
          
            n
          
        
        â
        
          Î
          
            â
          
        
        ,
        n
        â¥
        0
      
    
    {\displaystyle q_{1},q_{2}\in Q,w\in \Sigma _{\epsilon },x_{1},x_{2},\ldots ,x_{m}\in \Gamma ^{*},m\geq 0,y_{1},y_{2},\ldots ,y_{n}\in \Gamma ^{*},n\geq 0}
  
.
Construct the following transitions for the PDA:


  
    
      
        
          
            
              
                
                  Î´
                  â²
                
                (
                
                  q
                  
                    1
                  
                
                ,
                w
                ,
                
                  x
                  
                    1
                  
                
                )
              
              
                â¶
              
              
                (
                
                  p
                  
                    1
                  
                
                ,
                Ïµ
                )
              
            
            
              
                
                  Î´
                  â²
                
                (
                
                  p
                  
                    1
                  
                
                ,
                Ïµ
                ,
                
                  x
                  
                    2
                  
                
                )
              
              
                â¶
              
              
                (
                
                  p
                  
                    2
                  
                
                ,
                Ïµ
                )
              
            
            
              
              
                â®
              
              
            
            
              
                
                  Î´
                  â²
                
                (
                
                  p
                  
                    m
                    â
                    1
                  
                
                ,
                Ïµ
                ,
                
                  x
                  
                    m
                  
                
                )
              
              
                â¶
              
              
                (
                
                  p
                  
                    m
                  
                
                ,
                Ïµ
                )
              
            
            
              
                
                  Î´
                  â²
                
                (
                
                  p
                  
                    m
                  
                
                ,
                Ïµ
                ,
                Ïµ
                )
              
              
                â¶
              
              
                (
                
                  p
                  
                    m
                    +
                    1
                  
                
                ,
                
                  y
                  
                    n
                  
                
                )
              
            
            
              
                
                  Î´
                  â²
                
                (
                
                  p
                  
                    m
                    +
                    1
                  
                
                ,
                Ïµ
                ,
                Ïµ
                )
              
              
                â¶
              
              
                (
                
                  p
                  
                    m
                    +
                    2
                  
                
                ,
                
                  y
                  
                    n
                    â
                    1
                  
                
                )
              
            
            
              
              
                â®
              
              
            
            
              
                
                  Î´
                  â²
                
                (
                
                  p
                  
                    m
                    +
                    n
                    â
                    1
                  
                
                ,
                Ïµ
                ,
                Ïµ
                )
              
              
                â¶
              
              
                (
                
                  q
                  
                    2
                  
                
                ,
                
                  y
                  
                    1
                  
                
                )
                .
              
            
          
        
      
    
    {\displaystyle {\begin{array}{lcl}\delta '(q_{1},w,x_{1})&\longrightarrow &(p_{1},\epsilon )\\\delta '(p_{1},\epsilon ,x_{2})&\longrightarrow &(p_{2},\epsilon )\\&\vdots &\\\delta '(p_{m-1},\epsilon ,x_{m})&\longrightarrow &(p_{m},\epsilon )\\\delta '(p_{m},\epsilon ,\epsilon )&\longrightarrow &(p_{m+1},y_{n})\\\delta '(p_{m+1},\epsilon ,\epsilon )&\longrightarrow &(p_{m+2},y_{n-1})\\&\vdots &\\\delta '(p_{m+n-1},\epsilon ,\epsilon )&\longrightarrow &(q_{2},y_{1}).\end{array}}}
  

Stack automaton[edit]
As a generalization of pushdown automata, Ginsburg, Greibach, and Harrison (1967) investigated stack automata, which may additionally step left or right in the input string (surrounded by special endmarker symbols to prevent slipping out), and step up or down in the stack in read-only mode.[4][5] 
A stack automaton is called nonerasing if it never pops from the stack. The class of languages accepted by nondeterministic, nonerasing stack automata is NSPACE(n2), which is a superset of the context-sensitive languages.[1] The class of languages accepted by deterministic, nonerasing stack automata is DSPACE(nâlog(n)).[1]

Alternating pushdown automata [edit]
An alternating pushdown automaton (APDA) is a pushdown automaton with a state set


  
    
      
        Q
        =
        
          Q
          
            â
          
        
        âª
        
          Q
          
            â
          
        
      
    
    {\displaystyle Q=Q_{\exists }\cup Q_{\forall }}
  
 where 
  
    
      
        
          Q
          
            â
          
        
        â©
        
          Q
          
            â
          
        
        =
        â
      
    
    {\displaystyle Q_{\exists }\cap Q_{\forall }=\emptyset }
  
.
States in 
  
    
      
        
          Q
          
            â
          
        
      
    
    {\displaystyle Q_{\exists }}
  
 and 
  
    
      
        
          Q
          
            â
          
        
      
    
    {\displaystyle Q_{\forall }}
  
 are called existential resp. universal. In an existential state an APDA nondeterministically chooses the next state and accepts if at least one of the resulting computations accepts. In a universal state APDA moves to all next states and accepts if all the resulting computations accept.
The model was introduced by Chandra, Kozen and Stockmeyer.[6] Ladner, Lipton and Stockmeyer[7] proved that this model is equivalent to EXPTIME i.e. a language is accepted by some APDA if, and only if, it can be decided by an exponential-time algorithm.
Aizikowitz and Kaminski[8] introduced synchronized alternating pushdown automata (SAPDA) that are equivalent to conjunctive grammars in the same way as nondeterministic PDA are equivalent to context-free grammars.

See also[edit]
Stack machine
Context-free grammar
Finite automaton
Counter automaton
Queue automaton
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ The set of even-length palindromes of bits can't be recognized by a deterministic PDA, but is a context-free language, with the grammar S â Îµ | 0S0 | 1S1.[3]

^ Linear bounded automata are acceptors for the class of context-sensitive languages,[2]:â225â which is a proper superclass of the context-free languages, and a proper subclass of Turing-recognizable (i.e. recursively enumerable) languages.[2]:â228â


References[edit]

^ Jump up to: a b c .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}John E. Hopcroft; Jeffrey D. Ullman (1967). "Nonerasing Stack Automata". Journal of Computer and System Sciences. 1 (2): 166â186. doi:10.1016/s0022-0000(67)80013-8.

^ Jump up to: a b c d e f John E. Hopcroft and Jeffrey D. Ullman (1979). Introduction to Automata Theory, Languages, and Computation. Reading/MA: Addison-Wesley. ISBNÂ 0-201-02988-X.

^ John E. Hopcroft; Rajeev Motwani; Jeffrey D. Ullman (2003). Introduction to Automata Theory, Languages, and Computation. Addison Wesley. Here: Sect.6.4.3, p.249

^ Seymour Ginsburg, Sheila A. Greibach and Michael A. Harrison (1967). "Stack Automata and Compiling". J. ACM. 14 (1): 172â201. doi:10.1145/321371.321385.

^ Seymour Ginsburg, Sheila A. Greibach and Michael A. Harrison (1967). "One-Way Stack Automata". J. ACM. 14 (2): 389â418. doi:10.1145/321386.321403.

^ Chandra, Ashok K.; Kozen, Dexter C.; Stockmeyer, Larry J. (1981). "Alternation". Journal of the ACM. 28 (1): 114â133. doi:10.1145/322234.322243. ISSNÂ 0004-5411.

^ Ladner, Richard E.; Lipton, Richard J.; Stockmeyer, Larry J. (1984). "Alternating Pushdown and Stack Automata". SIAM Journal on Computing. 13 (1): 135â155. doi:10.1137/0213010. ISSNÂ 0097-5397.

^ Aizikowitz, Tamar; Kaminski, Michael (2011). "LR(0) Conjunctive Grammars and Deterministic Synchronized Alternating Pushdown Automata". Computer Science â Theory and Applications. Lecture Notes in Computer Science. Vol.Â 6651. pp.Â 345â358. doi:10.1007/978-3-642-20712-9_27. ISBNÂ 978-3-642-20711-2. ISSNÂ 0302-9743.


Michael Sipser (1997). Introduction to the Theory of Computation. PWS Publishing. ISBNÂ 0-534-94728-X. Section 2.2: Pushdown Automata, pp.Â 101â114.
Jean-Michel Autebert, Jean Berstel, Luc Boasson, Context-Free Languages and Push-Down Automata, in: G. Rozenberg, A. Salomaa (eds.), Handbook of Formal Languages, Vol. 1, Springer-Verlag, 1997, 111â174.
External links[edit]
JFLAP, simulator for several types of automata including nondeterministic pushdown automata
CoAn, another simulator for several machine types including nondeterministic pushdown automata (C++, Windows, Linux, MacOS)
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hide.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteAutomata theory: formal languages and formal grammarsChomsky hierarchyGrammarsLanguagesAbstract machines
Type-0
â
Type-1
â
â
â
â
â
Type-2
â
â
Type-3
â
â

Unrestricted
(no common name)
Context-sensitive
Positive range concatenation
Indexed
â
Linear context-free rewriting systems
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
â
Non-recursive

Recursively enumerable
Decidable
Context-sensitive
Positive range concatenation*
Indexed*
â
Linear context-free rewriting language
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
Star-free
Finite

Turing machine
Decider
Linear-bounded
PTIME Turing Machine
Nested stack
Thread automaton
restricted Tree stack automaton
Embedded pushdown
Nondeterministic pushdown
Deterministic pushdown
Visibly pushdown
Finite
Counter-free (with aperiodic finite monoid)
Acyclic finite
Each category of languages, except those marked by a *, is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line.




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Pushdown_automaton&oldid=1069562737"
		Categories: Automata (computation)Models of computationHidden categories: Articles with short descriptionShort description matches WikidataAll articles with unsourced statementsArticles with unsourced statements from January 2019Articles with unsourced statements from December 2016
	
