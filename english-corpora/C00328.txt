
Title:
APL (programming language)
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Not to be confused with Address programming language.
Array programming language
.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}APLParadigmArray, functional, structured, modularDesignedÂ byKenneth E. IversonDeveloperLarry Breed, Dick Lathwell, Roger Moore and othersFirstÂ appearedNovemberÂ 27, 1966; 55 years agoÂ (1966-11-27)[1]Stable releaseISO/IEC 13751:2001
   / FebruaryÂ 1, 2001; 21 years agoÂ (2001-02-01)
Typing disciplineDynamicPlatformCross platformLicenseProprietary, open sourceMajor implementations
APL\360
APL\1130
APL*Plus
Sharp APL
APL2
Dyalog APL
NARS2000
APLX
GNU APL
Influenced byMathematical notationInfluenced
A and A+
C++[2]
FP
J
K
LYaPAS[citation needed]
MATLAB
Nial
PPL
Python
S
Speakeasy
Wolfram Language




This article contains APL source code. Without proper rendering support, you may see question marks, boxes, or other symbols instead of APL symbols.

APL (named after the book A Programming Language)[3] is a programming language developed in the 1960s by Kenneth E. Iverson. Its central datatype is the multidimensional array. It uses a large range of special graphic symbols[4] to represent most functions and operators, leading to very concise code. It has been an important influence on the development of concept modeling, spreadsheets, functional programming,[5] and computer math packages.[6] It has also inspired several other programming languages.[7][8]

Contents

1 History

1.1 Mathematical notation
1.2 Development into a computer programming language
1.3 Hardware
1.4 Commercial availability
1.5 Microcomputers
1.6 APL2
1.7 Modern implementations
1.8 Derivative languages


2 Language characteristics

2.1 Character set
2.2 Design
2.3 Terminology
2.4 Syntax
2.5 Examples

2.5.1 Hello, world
2.5.2 Exponentiation
2.5.3 Simple statistics
2.5.4 Pick 6 lottery numbers
2.5.5 Prime numbers
2.5.6 Sorting
2.5.7 Game of Life
2.5.8 HTML tags removal




3 Naming
4 Logo
5 Use
6 Notable implementations

6.1 APL\360
6.2 APL\1130
6.3 APL*Plus and Sharp APL
6.4 APL2
6.5 APLGOL
6.6 Dyalog APL
6.7 NARS2000
6.8 APLX
6.9 GNU APL


7 Interpretation and compilation of APL

7.1 Idiom recognition
7.2 Optimised bytecode
7.3 Compilation


8 Standards
9 References
10 Further reading

10.1 Video


11 External links

11.1 Online resources
11.2 Providers
11.3 User groups and societies





History[edit]
Mathematical notation[edit]
A mathematical notation for manipulating arrays was developed by Kenneth E. Iverson, starting in 1957 at Harvard University. In 1960, he began work for IBM where he developed this notation with Adin Falkoff and published it in his book A Programming Language in 1962.[3] The preface states its premise:

.mw-parser-output .templatequote{overflow:hidden;margin:1em 0;padding:0 40px}.mw-parser-output .templatequote .templatequotecite{line-height:1.5em;text-align:left;padding-left:1.6em;margin-top:0}Applied mathematics is largely concerned with the design and analysis of explicit procedures for calculating the exact or approximate values of various functions. Such explicit procedures are called algorithms or programs. Because an effective notation for the description of programs exhibits considerable syntactic structure, it is called a programming language.

This notation was used inside IBM for short research reports on computer systems, such as the Burroughs B5000 and its stack mechanism when stack machines versus register machines were being evaluated by IBM for upcoming computers.
Iverson also used his notation in a draft of the chapter A Programming Language, written for a book he was writing with Fred Brooks, Automatic Data Processing, which would be published in 1963.[9][10]
In 1979, Iverson received the Turing Award for his work on APL.[11]

Development into a computer programming language[edit]
As early as 1962, the first attempt to use the notation to describe a complete computer system happened after Falkoff discussed with William C. Carter his work to standardize the instruction set for the machines that later became the IBM System/360 family.
In 1963, Herbert Hellerman, working at the IBM Systems Research Institute, implemented a part of the notation on an IBM 1620 computer, and it was used by students in a special high school course on calculating transcendental functions by series summation. Students tested their code in Hellerman's lab. This implementation of a part of the notation was called Personalized Array Translator (PAT).[12]
In 1963, Falkoff, Iverson, and Edward H. Sussenguth Jr., all working at IBM, used the notation for a formal description of the IBM System/360 series machine architecture and functionality, which resulted in a paper published in IBM Systems Journal in 1964. After this was published, the team turned their attention to an implementation of the notation on a computer system. One of the motivations for this focus of implementation was the interest of John L. Lawrence who had new duties with Science Research Associates, an educational company bought by IBM in 1964. Lawrence asked Iverson and his group to help use the language as a tool to develop and use computers in education.[13]
After Lawrence M. Breed and Philip S. Abrams of Stanford University joined the team at IBM Research, they continued their prior work on an implementation programmed in FORTRAN IV for a part of the notation which had been done for the IBM 7090 computer running on the IBSYS operating system. This work was finished in late 1965 and later named IVSYS (for Iverson system). The basis of this implementation was described in detail by Abrams in a Stanford University Technical Report, "An Interpreter for Iverson Notation" in 1966, the academic aspect of this was formally supervised by Niklaus Wirth.[14] Like Hellerman's PAT system earlier, this implementation did not include the APL character set but used special English reserved words for functions and operators. The system was later adapted for a time-sharing system and, by November 1966, it had been reprogrammed for the IBM System/360 Model 50 computer running in a time-sharing mode and was used internally at IBM.[15]

Hardware[edit]
  IBM typeballs and typewheel containing APL Greek characters.
  A programmer's view of the IBM 2741 keyboard layout with the APL typing element print head inserted
A key development in the ability to use APL effectively, before the wide use of cathode ray tube (CRT) terminals, was the development of a special IBM Selectric typewriter interchangeable typing element with all the special APL characters on it. This was used on paper printing terminal workstations using the Selectric typewriter and typing element mechanism, such as the IBM 1050 and IBM 2741 terminal. Keycaps could be placed over the normal keys to show which APL characters would be entered and typed when that key was struck. For the first time, a programmer could type in and see proper APL characters as used in Iverson's notation and not be forced to use awkward English keyword representations of them. Falkoff and Iverson had the special APL Selectric typing elements, 987 and 988, designed in late 1964, although no APL computer system was available to use them.[16] Iverson cited Falkoff as the inspiration for the idea of using an IBM Selectric typing element for the APL character set.[17]
Many APL symbols, even with the APL characters on the Selectric typing element, still had to be typed in by over-striking two extant element characters. An example is the grade up character, which had to be made from a delta (shift-H) and a Sheffer stroke (shift-M). This was necessary because the APL character set was much larger than the 88 characters allowed on the typing element, even when letters were restricted to upper-case (capitals).

Commercial availability[edit]
The first APL interactive login and creation of an APL workspace was in 1966 by Larry Breed using an IBM 1050 terminal at the IBM Mohansic Labs near Thomas J. Watson Research Center, the home of APL, in Yorktown Heights, New York.[16]
IBM was chiefly responsible for introducing APL to the marketplace. The first publicly available version of APL was released in 1968  for the IBM 1130. IBM provided APL\1130 for free but without liability or support.[18][19] It would run in as little as 8k 16-bit words of memory, and used a dedicated 1 megabyte hard disk.
APL gained its foothold on mainframe timesharing systems from the late 1960s through the early 1980s, in part because it would support multiple users on lower-specification systems that had no dynamic address translation hardware.[20] Additional improvements in performance for selected IBM System/370 mainframe systems included the APL Assist Microcode in which some support for APL execution was included in the processor's firmware, as distinct from being implemented entirely by higher-level software. Somewhat later, as suitably performing hardware was finally growing available in the mid- to late-1980s, many users migrated their applications to the personal computer environment.
Early IBM APL interpreters for IBM 360 and IBM 370 hardware implemented their own multi-user management instead of relying on the host services, thus they were their own timesharing systems. First introduced for use at IBM in 1966, the APL\360[21][22][23] system was a multi-user interpreter. The ability to programmatically communicate with the operating system for information and setting interpreter system variables was done through special privileged "I-beam" functions, using both monadic and dyadic operations.[24]
In 1973, IBM released APL.SV, which was a continuation of the same product, but which offered shared variables as a means to access facilities outside of the APL system, such as operating system files. In the mid-1970s, the IBM mainframe interpreter was even adapted for use on the IBM 5100 desktop computer, which had a small CRT and an APL keyboard, when most other small computers of the time only offered BASIC. In the 1980s, the VSAPL program product enjoyed wide use with Conversational Monitor System (CMS), Time Sharing Option (TSO), VSPC, MUSIC/SP, and CICS users.
In 1973â1974, Patrick E. Hagerty directed the implementation of the University of Maryland APL interpreter for the 1100 line of the Sperry UNIVAC 1100/2200 series mainframe computers.[25] At the time, Sperry had nothing. In 1974, student Alan Stebbens was assigned the task of implementing an internal function.[26] Xerox APL was available from June 1975 for Xerox 560 and Sigma 6, 7, and 9 mainframes running CP-V and for Honeywell CP-6.[27]
In the 1960s and 1970s, several timesharing firms arose that sold APL services using modified versions of the IBM APL\360[23] interpreter. In North America, the better-known ones were IP Sharp Associates, Scientific Time Sharing Corporation (STSC), Time Sharing Resources (TSR), and The Computer Company (TCC). CompuServe also entered the market in 1978 with an APL Interpreter based on a modified version of Digital Equipment Corp and Carnegie Mellon's, which ran on DEC's KI and KL 36-bit machines. CompuServe's APL was available both to its commercial market and the consumer information service. With the advent first of less expensive mainframes such as the IBM 4300, and later the personal computer, by the mid-1980s, the timesharing industry was all but gone.
Sharp APL was available from IP Sharp Associates, first as a timesharing service in the 1960s, and later as a program product starting around 1979. Sharp APL was an advanced APL implementation with many language extensions, such as packages (the ability to put one or more objects into a single variable), file system, nested arrays, and shared variables.
APL interpreters were available from other mainframe and mini-computer manufacturers also, notably Burroughs, Control Data Corporation (CDC), Data General, Digital Equipment Corporation (DEC), Harris, Hewlett-Packard (HP), Siemens, Xerox and others.
Garth Foster of Syracuse University sponsored regular meetings of the APL implementers' community at Syracuse's Minnowbrook Conference Center in Blue Mountain Lake, New York. In later years, Eugene McDonnell organized similar meetings at the Asilomar Conference Grounds near Monterey, California, and at Pajaro Dunes near Watsonville, California. The SIGAPL special interest group of the Association for Computing Machinery continues to support the APL community.[28]

Microcomputers[edit]
On microcomputers, which became available from the mid 1970s onwards, BASIC became the dominant programming language.[29] Nevertheless, some microcomputers provided APL instead - the first being the Intel 8008-based MCM/70 which was released in 1974[30][31] and which was primarily used in education.[32] Another machine of this time was the VideoBrain Family Computer, released in 1977, which was supplied with its dialect of APL called APL/S.[33]
The Commodore SuperPET, introduced in 1981, included an APL interpreter developed by the University of Waterloo.[34]
In 1976, Bill Gates claimed in his Open Letter to Hobbyists that Microsoft Corporation was implementing APL for the Intel 8080 and Motorola 6800 but had "very little incentive to make [it] available to hobbyists" because of software piracy.[35] It was never released.

APL2[edit]
Starting in the early 1980s, IBM APL development, under the leadership of Jim Brown, implemented a new version of the APL language that contained as its primary enhancement the concept of nested arrays, where an array can contain other arrays, and new language features which facilitated integrating nested arrays into program workflow. Ken Iverson, no longer in control of the development of the APL language, left IBM and joined I. P. Sharp Associates, where one of his major contributions was directing the evolution of Sharp APL to be more in accord with his vision.[36][37][38] APL2 was first released for CMS and TSO in 1984.[39] The APL2 Workstation edition (Windows, OS/2, AIX, Linux, and Solaris) followed later.[40][41]
As other vendors were busy developing APL interpreters for new hardware, notably Unix-based microcomputers, APL2 was almost always the standard chosen for new APL interpreter developments. Even today, most APL vendors or their users cite APL2 compatibility, as a selling point for those products.[42][43] IBM cites its use for problem solving, system design, prototyping, engineering and scientific computations, expert systems,[44] for teaching mathematics and other subjects, visualization and database access.[45]

Modern implementations[edit]
Various implementations of APL by APLX, Dyalog, et al., include extensions for object-oriented programming, support for .NET Framework, XML-array conversion primitives, graphing, operating system interfaces, and lambda calculus expressions.

Derivative languages[edit]
APL has formed the basis of, or influenced, the following languages:[citation needed]

A and A+, an alternative APL, the latter with graphical extensions.
FP, a functional programming language.
Ivy, an interpreter for an APL-like language developed by Rob Pike, and which uses ASCII as input.[46]
J, which was also designed by Iverson, and which uses ASCII with digraphs instead of special symbols.[7]
K, a proprietary variant of APL developed by Arthur Whitney.[8]
LYaPAS, a Soviet extension to APL.[citation needed]
MATLAB, a numerical computation tool.[6]
Nial, a high-level array programming language with a functional programming notation.
Polymorphic Programming Language, an interactive, extensible language with a similar base language.
S, a statistical programming language (usually now seen in the open-source version known as R).
Speakeasy, a numerical computing interactive environment.
Wolfram Language, the programming language of Mathematica.[47]
Language characteristics[edit]
Character set[edit]
Main articles: APL (codepage) and syntax and symbols.
APL has been criticized and praised for its choice of a unique, non-standard character set. Some who learn it become ardent adherents. In the 1960s and 1970s, few terminal devices or even displays could reproduce the APL character set. The most popular ones employed the IBM Selectric print mechanism used with a special APL type element. One of the early APL line terminals (line-mode operation only, not full screen) was the Texas Instruments TI Model 745 (circa 1977) with the full APL character set[48] which featured half and full duplex telecommunications modes, for interacting with an APL time-sharing service or remote mainframe to run a remote computer job, called an RJE.
Over time, with the universal use of high-quality graphic displays, printing devices and Unicode support, the APL character font problem has largely been eliminated. However, entering APL characters requires the use of input method editors, keyboard mappings, virtual/on-screen APL symbol sets,[49][50] or easy-reference printed keyboard cards which can frustrate beginners accustomed to other programming languages.[51][52][53] With beginners who have no prior experience with other programming languages, a study involving high school students found that typing and using APL characters did not hinder the students in any measurable way.[54]
In defense of APL, it requires fewer characters to type, and keyboard mappings become memorized over time. Special APL keyboards are also made and in use today, as are freely downloadable fonts for operating systems such as Microsoft Windows.[55] The reported productivity gains assume that one spends enough time working in the language to make it worthwhile to memorize the symbols, their semantics, and keyboard mappings, not to mention a substantial number of idioms for common tasks.[citation needed]

Design[edit]
Unlike traditionally structured programming languages, APL code is typically structured as chains of monadic or dyadic functions, and operators[56] acting on arrays.[57] APL has many nonstandard primitives (functions and operators) that are indicated by a single symbol or a combination of a few symbols. All primitives are defined to have the same precedence, and always associate to the right. Thus, APL is read or best understood from right-to-left.
Early APL implementations (circa 1970 or so) had no programming loop-flow control structures, such as do or while loops, and if-then-else constructs. Instead, they used array operations, and use of structured programming constructs was often not necessary, since an operation could be performed on a full array in one statement. For example, the iota function (Î¹) can replace for-loop iteration: Î¹N when applied to a scalar positive integer yields a one-dimensional array (vector), 1 2 3Â ... N. More recent implementations of APL generally include comprehensive control structures, so that data structure and program control flow can be clearly and cleanly separated.
The APL environment is called a workspace. In a workspace the user can define programs and data, i.e., the data values exist also outside the programs, and the user can also manipulate the data without having to define a program.[58] In the examples below, the APL interpreter first types six spaces before awaiting the user's input. Its own output starts in column one.




      n â 4 5 6 7


Assigns vector of values, {4 5 6 7}, to variable n, an array create operation. An equivalent yet more concise APL expression would be n â 3 + â³4. Multiple values are stored in array n, the operation performed without formal loops or control flow language.


      n 
4 5 6 7


Display the contents of n, currently an array or vector.


      n+4
8 9 10 11


4 is now added to all elements of vector n, creating a 4-element vector {8 9 10 11}. As above, APL's interpreter displays the result because the expression's value was not assigned to a variable (with a â).


      +/n
22


APL displays the sum of components of the vector n, i.e., 22 (= 4 + 5 + 6 + 7) using a very compact notation: read +/ as "plus, over..." and a slight change would be "multiply, over..."


      m â +/3+â³4
      m
22


These operations can be combined into one statement, remembering that APL evaluates expressions right to left: first â³4 creates an array, [1,2,3,4], then 3 is added to each component, which are summed together and the result stored in variable m, finally displayed.
In normal mathematical notation, it is equivalent to: 
  
    
      
        
          m
          =
          
            â
            
              i
              =
              1
            
            
              4
            
          
          (
          i
          +
          3
          )
        
      
    
    {\displaystyle \displaystyle m=\sum \limits _{i=1}^{4}(i+3)}
  
. Recall that mathematical expressions are not read or evaluated from right-to-left.


The user can save the workspace with all values, programs, and execution status.
APL uses a set of non-ASCII symbols, which are an extension of traditional arithmetic and algebraic notation. Having single character names for single instruction, multiple data (SIMD) vector functions is one way that APL enables compact formulation of algorithms for data transformation such as computing Conway's Game of Life in one line of code.[59] In nearly all versions of APL, it is theoretically possible to express any computable function in one expression, that is, in one line of code.[citation needed]
Because of the unusual character set, many programmers use special keyboards with APL keytops to write APL code.[60] Although there are various ways to write APL code using only ASCII characters,[61] in practice it is almost never done. (This may be thought to support Iverson's thesis about notation as a tool of thought.[62]) Most if not all modern implementations use standard keyboard layouts, with special mappings or input method editors to access non-ASCII characters. Historically, the APL font has been distinctive, with uppercase italic alphabetic characters and upright numerals and symbols. Most vendors continue to display the APL character set in a custom font.
Advocates of APL[who?] claim that the examples of so-called write-only code (badly written and almost incomprehensible code) are almost invariably examples of poor programming practice or novice mistakes, which can occur in any language. Advocates also claim that they are far more productive with APL than with more conventional computer languages, and that working software can be implemented in far less time and with far fewer programmers than using other technology.[citation needed]
They also may claim that because it is compact and terse, APL lends itself well to larger-scale software development and complexity, because the number of lines of code can be reduced greatly. Many APL advocates and practitioners also view standard programming languages such as COBOL and Java as being comparatively tedious. APL is often found where time-to-market is important, such as with trading systems.[63][64][65][66]

Terminology[edit]
APL makes a clear distinction between functions and operators.[56][67] Functions take arrays (variables or constants or expressions) as arguments, and return arrays as results. Operators (similar to higher-order functions) take functions or arrays as arguments, and derive related functions. For example, the sum function is derived by applying the reduction operator to the addition function. Applying the same reduction operator to the maximum function (which returns the larger of two numbers) derives a function which returns the largest of a group (vector) of numbers. In the J language, Iverson substituted the terms verb for function and adverb or conjunction for operator.
APL also identifies those features built into the language, and represented by a symbol, or a fixed combination of symbols, as primitives. Most primitives are either functions or operators. Coding APL is largely a process of writing non-primitive functions and (in some versions of APL) operators. However a few primitives are considered to be neither functions nor operators, most noticeably assignment.
Some words used in APL literature have meanings that differ from those in both mathematics and the generality of computer science.


Terminology of APL operators


Term

Description


function

operation or mapping that takes zero, one (right) or two (left & right) arguments which may be scalars, arrays, or more complicated structures, and may return a similarly complex result. A function may be:
Primitive: built-in and represented by a single glyph;[68]
Defined: as a named and ordered collection of program statements;[68]
Derived: as a combination of an operator with its arguments.[68]


array

data valued object of zero or more orthogonal dimensions in row-major order in which each item is a primitive scalar datum or another array.[69]


niladic

not taking or requiring any arguments, nullary[70]


monadic

requiring only one argument; on the right for a function, on the left for an operator, unary[70]


dyadic

requiring both a left and a right argument, binary[70]


ambivalent or monadic

capable of use in a monadic or dyadic context, permitting its left argument to be elided[68]


operator

operation or mapping that takes one (left) or two (left & right) function or array valued arguments (operands) and derives a function. An operator may be:
Primitive: built-in and represented by a single glyph;[68]
Defined: as a named and ordered collection of program statements.[68]

Syntax[edit]
Main article: APL syntax and symbols
APL has explicit representations of functions, operators, and syntax, thus providing a basis for the clear and explicit statement of extended facilities in the language, and tools to experiment on them.[71]

Examples[edit]
Hello, world[edit]
This displays "Hello, world":

'Hello, world'
A design theme in APL is to define default actions in some cases that would produce syntax errors in most other programming languages.
The 'Hello, world' string constant above displays, because display is the default action on any expression for which no action is specified explicitly (e.g. assignment, function parameter).

Exponentiation[edit]
Another example of this theme is that exponentiation in APL is written as 2*3, which indicates raising 2 to the power 3 (this would be written as 2^3 in some other languages and 2**3 in FORTRAN and Python). Many languages use * to signify multiplication, as in 2*3, but APL chooses to use 2Ã3. However, if no base is specified (as with the statement *3 in APL, or ^3 in other languages), most programming languages one would see this as a syntax error. APL, however, assumes the missing base to be the natural logarithm constant e, and interprets *3 as 2.71828*3.

Simple statistics[edit]
Suppose that X is an array of numbers. Then (+/X)Ã·â´X gives its average. Reading right-to-left, â´X gives the number of elements in X, and since Ã· is a dyadic operator, the term to its left is required as well. It is surrounded by parentheses since otherwise X would be taken (so that the summation would be of XÃ·â´X â each element of X divided by the number of elements in X), and +/X gives the sum of the elements of X. Building on this, the following expression computes standard deviation: ((+/((X - (+/X)Ã·â´X)*2))Ã·â´X)*0.5

Naturally, one would define this expression as a function for repeated use rather than rewriting it each time. Further, since assignment is an operator, it can appear within an expression, so the following would place suitable values into T, AV and SD: SDâ((+/((X - AVâ(Tâ+/X)Ã·â´X)*2))Ã·â´X)*0.5

Pick 6 lottery numbers[edit]
This following immediate-mode expression generates a typical set of Pick 6 lottery numbers: six pseudo-random integers ranging from 1 to 40, guaranteed non-repeating, and displays them sorted in ascending order:

x[âxâ6?40]

The above does a lot, concisely, although it may seem complex to a new APLer. It combines the following APL functions (also called primitives[72] and glyphs[73]):

The first to be executed (APL executes from rightmost to leftmost) is dyadic function ? (named deal when dyadic) that returns a vector consisting of a select number (left argument: 6 in this case) of random integers ranging from 1 to a specified maximum (right argument: 40 in this case), which, if said maximum â¥ vector length, is guaranteed to be non-repeating; thus, generate/create 6 random integers ranging from 1-40.[74]
This vector is then assigned (â) to the variable x, because it is needed later.
This vector is then sorted in ascending order by a monadic â function, which has as its right argument everything to the right of it up to the next unbalanced close-bracket or close-parenthesis. The result of â is the indices that will put its argument into ascending order.
Then the output of â is used to index the variable x, which we saved earlier for this purpose, thereby selecting its items in ascending sequence.
Since there is no function to the left of the left-most x to tell APL what to do with the result, it simply outputs it to the display (on a single line, separated by spaces) without needing any explicit instruction to do that.
? also has a monadic equivalent called roll, which simply returns one random integer between 1 and its sole operand [to the right of it], inclusive. Thus, a role-playing game program might use the expression ?20 to roll a twenty-sided die.

Prime numbers[edit]
The following expression finds all prime numbers from 1 to R. In both time and space, the calculation complexity is 
  
    
      
        O
        (
        
          R
          
            2
          
        
        )
        
        
      
    
    {\displaystyle O(R^{2})\,\!}
  
 (in Big O notation).

(~RâRâ.ÃR)/Râ1ââ³R

Executed from right to left, this means:

Iota â³ creates a vector containing integers from 1 to R (if R= 6 at the start of the program, â³R is 1 2 3 4 5 6)
Drop first element of this vector (â function), i.e., 1. So 1ââ³R is 2 3 4 5 6
Set R to the new vector (â, assignment primitive), i.e., 2 3 4 5 6
The / replicate operator is dyadic (binary) and the interpreter first evaluates its left argument (fully in parentheses):
Generate outer product of R multiplied by R, i.e., a matrix that is the multiplication table of R by R (Â°.Ã operator), i.e.,



4

6

8

10

12


6

9

12

15

18


8

12

16

20

24


10

15

20

25

30


12

18

24

30

36

Build a vector the same length as R with 1 in each place where the corresponding number in R is in the outer product matrix (â, set inclusion or element of or Epsilon operator), i.e., 0 0 1 0 1
Logically negate (not) values in the vector (change zeros to ones and ones to zeros) (â¼, logical not or Tilde operator), i.e., 1 1 0 1 0
Select the items in R for which the corresponding element is 1 (/ replicate operator), i.e., 2 3 5
(Note, this assumes the APL origin is 1, i.e., indices start with 1. APL can be set to use 0 as the origin, so that Î¹6 is 0 1 2 3 4 5, which is convenient for some calculations.)

Sorting[edit]
The following expression sorts a word list stored in matrix X according to word length:

X[âX+.â ' ';]

Game of Life[edit]
The following function "life", written in Dyalog APL,[75][76] takes a boolean matrix and calculates the new generation according to Conway's Game of Life. It demonstrates the power of APL to implement a complex algorithm in very little code, but it is also very hard to follow unless one has advanced knowledge of APL.

life â {â1 âµ â¨.â§ 3 4 = +/ +â¿ Â¯1 0 1 â.â Â¯1 0 1 â½Â¨ ââµ}

HTML tags removal[edit]
In the following example, also Dyalog, the first line assigns some HTML code to a variable txt and then uses an APL expression to remove all the HTML tags (explanation):

      txtâ'<html><body><p>This is <em>emphasized</em> text.</p></body></html>'
      {âµ /â¨ ~{âµâ¨â \âµ}âµâ'<>'} txt
This is emphasized text.

Naming[edit]
APL derives its name from the initials of Iverson's book A Programming Language,[3] even though the book describes Iverson's mathematical notation, rather than the implemented programming language described in this article. The name is used only for actual implementations, starting with APL\360.
Adin Falkoff coined the name in 1966 during the implementation of APL\360 at IBM:

As I walked by the office the three students shared, I could hear sounds of an argument going on. I poked my head in the door, and Eric asked me, "Isn't it true that everyone knows the notation we're using is called APL?â I was sorry to have to disappoint him by confessing that I had never heard it called that. Where had he got the idea it was well known? And who had decided to call it that? In fact, why did it have to be called anything? Quite a while later I heard how it was named. When the implementation effort started in June of 1966, the documentation effort started, too. I suppose when they had to write about "it", Falkoff and Iverson realized that they would have to give "it" a name. There were probably many suggestions made at the time, but I have heard of only two. A group in SRA in Chicago which was developing instructional materials using the notation was in favor of the name "Mathlab". This did not catch on. Another suggestion was to call it "Iverson's Better Math" and then let people coin the appropriate acronym. This was deemed facetious.
Then one day Adin Falkoff walked into Ken's office and wrote "A Programming Language" on the board, and underneath it the acronym "APL". Thus it was born. It was just a week or so after this that Eric Iverson asked me his question, at a time when the name hadn't yet found its way the thirteen miles up the Taconic Parkway from IBM Research to IBM Mohansic.ââEugene McDonnell, [77]
APL is occasionally re-interpreted as Array Programming Language or Array Processing Language,[78] thereby making APL into a backronym.

  British APL Association (BAPLA) conference laptop bag.
Logo[edit]
There has always been cooperation between APL vendors, and joint conferences were held on a regular basis from 1969 until 2010.[79] At such conferences, APL merchandise was often handed out, featuring APL motifs or collection of vendor logos. Common were apples (as a pun on the similarity in pronunciation of apple and APL) and the code snippet âº*â which are the symbols produced by the classic APL keyboard layout when holding the APL modifier key and typing "APL".
Despite all these community efforts, no universal vendor-agnostic logo for the programming language emerged. As popular programming languages increasingly have established recognisable logos, Fortran getting one in 2020,[80] British APL Association launched a campaign in the second half of 2021, to establish such a logo for APL.[81]

Use[edit]
APL is used for many purposes including financial and insurance applications,[82] artificial intelligence,[83][84]
neural networks[85]
and robotics.[86] It has been argued that APL is a calculation tool and not a programming language;[87] its symbolic nature and array capabilities have made it popular with domain experts and data scientists[88] who do not have or require the skills of a computer programmer.
APL is well suited to image manipulation and computer animation, where graphic transformations can be encoded as matrix multiplications. One of the first commercial computer graphics houses, Digital Effects, produced an APL graphics product named Visions, which was used to create television commercials and animation for the 1982 film Tron.[89] Latterly, the Stormwind boating simulator uses APL to implement its core logic, its interfacing to the rendering pipeline middleware and a major part of its physics engine.[90]
Today, APL remains in use in a wide range of commercial and scientific applications, for example
investment management,[82]
asset management,[91]
health care,[92]
and DNA profiling,[93][94] 
and by hobbyists.[95]

Notable implementations[edit]
APL\360[edit]
The first implementation of APL using recognizable APL symbols was APL\360 which ran on the IBM System/360, and was completed in November 1966[1] though at that time remained in use only within IBM.[39] In 1973 its implementors, Larry Breed, Dick Lathwell and Roger Moore, were awarded the Grace Murray Hopper Award from the Association for Computing Machinery (ACM). It was given "for their work in the design and implementation of APL\360, setting new standards in simplicity, efficiency, reliability and response time for interactive systems."[96][97][98]
In 1975, the IBM 5100 microcomputer offered APL\360[99] as one of two built-in ROM-based interpreted languages for the computer, complete with a keyboard and display that supported all the special symbols used in the language.[100]
Significant developments to APL\360 included CMS/APL, which made use of the virtual storage capabilities of CMS and APLSV, which introduced shared variables, system variables and system functions. It was subsequently ported to the IBM System/370 and VSPC platforms until its final release in 1983, after which it was replaced by APL2.[39]

APL\1130[edit]
In 1968, APL\1130 became the first publicly available APL system,[101] created by IBM for the IBM 1130. It became the most popular IBM Type-III Library software that IBM released.[102]

APL*Plus and Sharp APL[edit]
Main articles: I. P. Sharp Associates and Scientific Time Sharing Corporation
APL*Plus and Sharp APL are versions of APL\360 with added business-oriented extensions such as data formatting and facilities to store APL arrays in external files. They were jointly developed by two companies, employing various members of the original IBM APL\360 development team.[103]
The two companies were I. P. Sharp Associates (IPSA), an APL\360 services company formed in 1964 by Ian Sharp, Roger Moore and others, and STSC, a time-sharing and consulting service company formed in 1969 by Lawrence Breed and others. Together the two developed APL*Plus and thereafter continued to work together but develop APL separately as APL*Plus and Sharp APL. STSC ported APL*Plus to many platforms with versions being made for the VAX 11,[104] PC and UNIX, whereas IPSA took a different approach to the arrival of the personal computer and made Sharp APL available on this platform using additional PC-XT/360 hardware. In 1993, Soliton Incorporated was formed to support Sharp APL and it developed Sharp APL into SAX (Sharp APL for Unix). As of 2018[update], APL*Plus continues as APL2000 APL+Win.
In 1985, Ian Sharp, and Dan Dyer of STSC, jointly received the Kenneth E. Iverson Award for Outstanding Contribution to APL.[105]

APL2[edit]
APL2 was a significant re-implementation of APL by IBM which was developed from 1971 and first released in 1984. It provides many additions to the language, of which the most notable is nested (non-rectangular) array support.[39] The entire APL2 Products and Services Team was awarded the Iverson Award in 2007.[105]
In 2021, IBM sold APL2 to Log-On Software, who develop and sell the product as Log-On APL2.[106]

APLGOL[edit]
In 1972, APLGOL was released as an experimental version of APL that added structured programming language constructs to the language framework. New statements were added for interstatement control, conditional statement execution, and statement structuring, as well as statements to clarify the intent of the algorithm.[107] It was implemented for Hewlett-Packard in 1977.[108]

Dyalog APL[edit]
Dyalog APL was first released by British company Dyalog Ltd.[109] in 1983[110] and, as of 2018[update], is available for AIX, Linux (including on the Raspberry Pi), macOS and Microsoft Windows platforms. It is based on APL2, with extensions to support object-oriented programming[111] and functional programming.[112] Licences are free for personal/non-commercial use.[113]
In 1995, two of the development team - John Scholes and Peter Donnelly - were awarded the Iverson Award for their work on the interpreter.[105] Gitte Christensen and Morten Kromberg were joint recipients of the Iverson Award in 2016.[114]

NARS2000[edit]
NARS2000 is an open-source APL interpreter written by Bob Smith, a prominent APL developer and implementor from STSC in the 1970s and 1980s. NARS2000 contains advanced features and new datatypes and runs natively on Microsoft Windows, and other platforms under Wine. It is named after a development tool from the 1980s, NARS (Nested Arrays Research System).[115]

APLX[edit]
Main article: APLX
APLX is a cross-platform dialect of APL, based on APL2 and with several extensions, which was first released by British company MicroAPL in 2002. Although no longer in development or on commercial sale it is now available free of charge from Dyalog.[116]

GNU APL[edit]
GNU APL is a free implementation of Extended APL as specified in ISO/IEC 13751:2001 and is thus an implementation of APL2. It runs on Linux (including on the Raspberry Pi), macOS, several BSD dialects, and on Windows (either using Cygwin for full support of all its system functions or as a native 64-bit Windows binary with some of its system functions missing). GNU APL uses Unicode internally and can be scripted. It was written by JÃ¼rgen Sauermann.[117]
Richard Stallman, founder of the GNU Project, was an early adopter of APL, using it to write a text editor as a high school student in the summer of 1969.[118]

Interpretation and compilation of APL[edit]
APL is traditionally an interpreted language, having language characteristics such as weak variable typing not well suited to compilation.[119] However, with arrays as its core data structure[120] it provides opportunities for performance gains through parallelism,[121] parallel computing,[122][123] massively parallel applications,[124][125] and very-large-scale integration (VLSI),[126][127] and from the outset APL has been regarded as a high-performance language[128] - for example, it was noted for the speed with which it could perform complicated matrix operations "because it operates on arrays and performs operations like matrix inversion internally".[129]
Nevertheless, APL is rarely purely interpreted and compilation or partial compilation techniques that are, or have been, used include the following:

Idiom recognition[edit]
Most APL interpreters support idiom recognition[130] and evaluate common idioms as single operations.[131][132] For example, by evaluating the idiom BV/â³â´A as a single operation (where BV is a Boolean vector and A is an array), the creation of two intermediate arrays is avoided.[133]

Optimised bytecode[edit]
Weak typing in APL means that a name may reference an array (of any datatype), a function or an operator. In general, the interpreter cannot know in advance which form it will be and must therefore perform analysis, syntax checking etc. at run-time.[134] However, in certain circumstances, it is possible to deduce in advance what type a name is expected to reference and then generate bytecode which can be executed with reduced run-time overhead. This bytecode can also be optimised using compilation techniques such as constant folding or common subexpression elimination.[135] The interpreter will execute the bytecode when present and when any assumptions which have been made are met. Dyalog APL includes support for optimised bytecode.[135]

Compilation[edit]
Compilation of APL has been the subject of research and experiment since the language first became available; the first compiler is considered to be the Burroughs APL-700[136] which was released around 1971.[137] In order to be able to compile APL, language limitations have to be imposed.[136][138] APEX is a research APL compiler which was written by Robert Bernecky and is available under the GNU Public License.[139]
The STSC APL Compiler is a hybrid of a bytecode optimiser and a compiler - it enables compilation of functions to machine code provided that its sub-functions and globals are declared, but the interpreter is still used as a runtime library and to execute functions which do not meet the compilation requirements.[140]

Standards[edit]
APL has been standardized by the American National Standards Institute (ANSI) working group X3J10 and International Organization for Standardization (ISO) and International Electrotechnical Commission (IEC), ISO/IEC Joint Technical Committee 1 Subcommittee 22 Working Group 3. The Core APL language is specified in ISO 8485:1989, and the Extended APL language is specified in ISO/IEC 13751:2001.

References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"APL Quotations and Anecdotes". jsoftware.com. jsoftware. Retrieved April 14, 2018.

^ "std::iota". cppreference.com.

^ Jump up to: a b c Iverson, Kenneth E. (1962). A Programming Language. Wiley. ISBNÂ 978-0-471-43014-8. Archived from the original on 2014-10-27. Retrieved 2014-10-27.

^ McIntyre, Donald B. (1991). "Language as an Intellectual Tool: From Hieroglyphics to APL". IBM Systems Journal. 30 (4): 554â581. doi:10.1147/sj.304.0554. Archived from the original on March 4, 2016. Retrieved January 9, 2015.

^ "ACM Award CitationÂ â John Backus". Awards.acm.org. 1977. Archived from the original on February 12, 2008. Retrieved February 3, 2010.

^ Jump up to: a b Moler, Cleve. "The Growth of MATLAB" (PDF). Archived from the original (PDF) on April 11, 2009. Retrieved February 3, 2010.

^ Jump up to: a b "A Bibliography of APL and J". Jsoftware.com. Retrieved March 2, 2010.

^ Jump up to: a b "An Interview with Arthur Whitney". Kx Systems. January 4, 2004. Archived from the original on April 4, 2009. Retrieved March 2, 2010.

^ Iverson, Kenneth E., "Automatic Data Processing: Chapter 6: A programming language" Archived June 4, 2009, at the Wayback Machine, 1960, Draft copy for Brooks and Iverson 1963 book, Automatic Data Processing.

^ Brooks, Fred; Iverson, Kenneth, (1963), Automatic Data Processing, John Wiley & Sons Inc.

^ "Turing Award Citation 1979". Awards.acm.org. Archived from the original on 2009-12-23. Retrieved February 3, 2010.

^ Hellerman, H. (July 1964). "Experimental Personalized Array Translator System". Communications of the ACM. 7 (7): 433â438. doi:10.1145/364520.364573. S2CIDÂ 2181070.

^ Falkoff, Adin D.; Iverson, Kenneth E., "The Evolution of APL", ACM SIGPLAN Notices 13, 1978-08.

^ Abrams, Philip S., An interpreter for "Iverson notation", Technical Report: CS-TR-66-47, Department of Computer Science, Stanford University, August 1966;

^ Haigh, Thomas (2005). "Biographies: Kenneth E. Iverson". IEEE Annals of the History of Computing. doi:10.1109/MAHC.2005.4.

^ Jump up to: a b Breed, Larry, "The First APL Terminal Session", APL Quote Quad, Association for Computing Machinery, Volume 22, Number 1, September 1991, p.2-4.

^ 19, 2009 Adin Falkoff â Computer History Museum. "Iverson credited him for choosing the name APL and the introduction of the IBM golf-ball typewriter with the replacement typehead, which provided the famous character set to represent programs."

^ Breed, Larry (August 2006). "How We Got to APL\1130". Vector (British APL Association). 22 (3). ISSNÂ 0955-1433. Archived from the original on 2008-05-12. Retrieved 2007-04-02.

^ APL\1130 Manual Archived 2011-02-21 at the Wayback Machine, May 1969

^ "Remembering APL". Quadibloc.com. Retrieved June 17, 2013.

^ Falkoff, Adin; Iverson, Kenneth E., "APL\360 Users Guide" Archived 2012-02-29 at the Wayback Machine, IBM Research, Thomas J. Watson Research Center, Yorktown Heights, NY, August 1968.

^ "APL\360 Terminal System" Archived 2010-07-11 at the Wayback Machine, IBM Research, Thomas J. Watson Research Center, March 1967.

^ Jump up to: a b Pakin, Sandra (1968). APL\360 Reference Manual. Science Research Associates, Inc. ISBNÂ 978-0-574-16135-2.

^ Falkoff, Adin D.; Iverson, Kenneth E.,The Design of APL, IBM Journal of Research and Development, Volume 17, Number 4, July 1973. "These environmental defined functions were based on the use of still another class of functionsâcalled "I-beams" because of the shape of the symbol used for themâwhich provide a more general facility for communication between APL programs and the less abstract parts of the system. The I-beam functions were first introduced by the system programmers to allow them to execute System/360 instructions from within APL programs, and thus use APL as a direct aid in their programming activity. The obvious convenience of functions of this kind, which appeared to be part of the language, led to the introduction of the monadic I-beam function for direct use by anyone. Various arguments to this function yielded information about the environment such as available space and time of day."

^ Minker, Jack (January 2004). "Beginning of Computing and Computer Sciences at the University of Maryland" (PDF). Section 2.3.4: University of Maryland. p.Â 38. Archived from the original (PDF) on June 10, 2011. Retrieved May 23, 2011.{{cite web}}:  CS1 maint: location (link)

^ Stebbens, Alan. "How it all began". Archived from the original on 2016-03-04. Retrieved 2011-05-22.

^ "Xerox APL Language and Operations Reference Manual" (PDF).

^ "SIGAPL". Sigapl.org. Retrieved June 17, 2013.

^ "Fifty Years of BASIC, the Programming Language That Made Computers Personal". Time. April 29, 2014. Retrieved April 29, 2018.

^ "MCM Computers M70/M700". old-computers.com. Archived from the original on April 3, 2018. Retrieved April 8, 2018.

^ Stachniak, Stachniak (2011). Inventing the PC: The MCM/70 Story. McGill Queens's University Press. ISBNÂ 978-0-7735-3852-8.

^ Miller, Michael (December 17, 2014). "PCs That Paved the Way for the Altair". PC Magazine. Ziff Davis. Retrieved April 29, 2018.

^ "VideoBrain Family Computer", Popular Science, November 1978, advertisement.

^ "A Look at SuperPet". Compute!. Small System Services Inc. December 1981. Retrieved April 29, 2018.

^ Gates, Bill (January 31, 1976). "An Open Letter to Hobbyists". Homebrew Computer Club Newsletter. Retrieved April 29, 2018.

^ Hui, Roger. "Remembering Ken Iverson". keiapl.org. KEIAPL. Retrieved January 10, 2015.

^ ACM A.M. Turing Award. "Kenneth E. Iverson â Citation". amturing.acm.org. ACM. Retrieved January 10, 2015.

^ ACM SIGPLAN. "APL2: The Early Years". www.sigapl.org. ACM. Retrieved January 10, 2015.

^ Jump up to: a b c d Falkoff, Adin D. (1991). "The IBM family of APL systems". IBM Systems Journal. 30 (4): 416â432. doi:10.1147/sj.304.0416. S2CIDÂ 19030940.

^ "IBM APL2". EDM2. 2019-10-09. Retrieved 2021-11-17.

^ "APL2: What's New". ibm.com. ibm. Retrieved April 22, 2018.

^ Micro APL. "Overview of the APL System". www.microapl.co.uk. Micro APL. Retrieved January 10, 2015.

^ Robertson, Graeme. "A Personal View of APL2010". archive.vector.org.uk. Vector â Journal of the British APL Association. Archived from the original on April 2, 2015. Retrieved January 10, 2015.

^ Rodriguez, P.; Rojas, J.; Alfonseca, M.; Burgos, J. I. (1989). "An Expert System in Chemical Synthesis written in APL2/PC". ACM SIGAPL APL Quote Quad. 19 (4): 299â303. doi:10.1145/75144.75185. S2CIDÂ 16876053.

^ IBM. "APL2: A Programming Language for Problem Solving, Visualization and Database Access". www-03.ibm.com. IBM. Retrieved January 10, 2015.

^ Pike, Rob (2018-03-25). "Ivy". GoDoc. Archived from the original on 2019-08-13.

^ "Wolfram Language FAQ". Wolfram. Retrieved February 20, 2020. LISP and APL were two early influences

^ Texas Instruments (1977). "TI 745 full page ad: Introducing a New Set of Characters". Computerworld. 11 (27): 32. Retrieved January 20, 2015.

^ Dyalog. "APL Fonts and Keyboards". www.dyalog.com. Dyalog. Retrieved January 19, 2015.

^ Smith, Bob. "NARS2000 Keyboard". www.sudleyplace.com. Bob Smith / NARS2000. Retrieved January 19, 2015.

^ MicroAPL Ltd. "Introduction to APL â APL Symbols". www.microapl.co.uk. MicroAPL Ltd. Retrieved January 8, 2015.

^ Brown, James A.; Hawks, Brent; Trimble, Ray (1993). "Extending the APL character set". ACM SIGAPL APL Quote Quad. 24 (1): 41â46. doi:10.1145/166198.166203.

^ Kromberg, Morten. "Unicode Support for APL". archive.vector.org.uk. Vector, Journal of the British APL Association. Archived from the original on January 20, 2015. Retrieved January 8, 2015.

^ Hsu, Aaron. "Computer Science Outreach and Education with APL". Dyalog, Ltd. Retrieved July 15, 2016.

^ Dyalog, Inc. APL fonts and keyboards. http://www.dyalog.com/apl-font-keyboard.htm

^ Jump up to: a b MicroAPL. "Operators". www.microapl.co.uk. MicroAPL. Retrieved January 12, 2015.

^ Primitive Functions. "Primitive Functions". www.microapl.co.uk/. Retrieved January 1, 2015.

^ Workspace. "The Workspace". www.microapl.co.uk. Retrieved January 1, 2015.

^ "example". Catpad.net. Archived from the original on July 8, 2013. Retrieved June 17, 2013.

^ APL Symbols. "Entering APL Symbols". www.microapl.co.uk. Retrieved January 1, 2015.

^ Dickey, Lee, A list of APL Transliteration Schemes Archived 2006-09-29 at the Wayback Machine, 1993

^ Iverson K.E.,
"Notation as a Tool of Thought Archived 2013-09-20 at the Wayback Machine", Communications of the ACM, 23: 444-465 (August 1980).

^ Batenburg. "APL Efficiency". www.ekevanbatenburg.nl. Retrieved January 1, 2015.

^ Vaxman. "APL Great Programming" (PDF). www.vaxman.de. Retrieved January 1, 2015.

^ Janko, Wolfgang (May 1987). "Investigation into the efficiency of using APL for the programming of an inference machine". ACM SIGAPL APL Quote Quad. 17 (4): 450â456. doi:10.1145/384282.28372.

^ Borealis. "Why APL?". www.aplborealis.com. Retrieved January 1, 2015.

^ Iverson, Kenneth E. "A Dictionary of APL". www.jsoftware.com. JSoftware; Iverson Estate. Retrieved January 20, 2015.

^ Jump up to: a b c d e f "APL concepts". Microapl.co.uk. Retrieved February 3, 2010.

^ "Nested array theory". Nial.com. Archived from the original on 2011-07-09. Retrieved February 3, 2010.

^ Jump up to: a b c "Programmera i APL", Bohman, FrÃ¶berg, Studentlitteratur, ISBNÂ 91-44-13162-3

^ Iverson, Kenneth E. "APL Syntax and Semantics". www.jsoftware.com. I. P. Sharp Associates. Retrieved January 11, 2015.

^ MicroAPL. "APL Primitives". www.microapl.co.uk. MicroAPL. Retrieved January 11, 2015.

^ NARS2000. "APL Font â Extra APL Glyphs". wiki.nars2000.org. NARS2000. Retrieved January 11, 2015.

^ Fox, Ralph L. "Systematically Random Numbers". www.sigapl.org. SIGAPL. Retrieved January 11, 2015.

^ Scholes, John (January 26, 2009). Conway's Game of Life in APL (video). YouTube. Retrieved November 20, 2021.

^ Further technical details in APL Wiki's article "Conway's Game of Life". Retrieved November 20, 2021.

^ McDonnell, E.E. The introduction to A Source Book in APL, APL Press, 1981. (full book scan)

^ Acharya, R; Pereira, (904567457) 
N.E. APL Programming Language. Paper for CS5314 (Concepts of Programming Languages) at Virginia Tech.

^ APL Wiki. APL Conference. Retrieved 13 Oct 2021.

^ Jacob Williams. Degenerate Conic: New Blood. Retrieved 13 Oct 2021.

^ APL Wiki. APL logo. Retrieved 13 Oct 2021.

^ Jump up to: a b "2017 Annual Report" (PDF). SimCorp. February 1, 2018. Retrieved April 3, 2018. Sofia is a front-to-back investment management platform like SimCorp Dimension.Â ... Sofia is based on the APL coding language just like some parts of SimCorp Dimension.

^ Lee, Georges; Lelouche, Ruddy; Meissonnier, Vincent; Zarri, Gian Piero (September 1, 1982). "Using APL in an Artificial Intelligence environment". ACM SIGAPL APL Quote Quad. 13 (1): 183â191. doi:10.1145/390006.802242. Retrieved April 3, 2018.

^ Fordyce, K.; Sullivan, G. (1985). "Artificial Intelligence Development Aids". APL Quote Quad. APL 85 Conf. Proc. (15): 106â113. doi:10.1145/255315.255347.

^ Alfonseca, Manuel (July 1990). "Neural networks in APL". ACM SIGAPL APL Quote Quad. 20 (4): 2â6. doi:10.1145/97811.97816. Retrieved April 3, 2018.

^ Kromberg, Morten. "Robot Programming in APL". www.dyalog.com/. Retrieved January 6, 2015.

^ Holmes, W N (May 1978). "Is APL a Programming Language?". The Computer Journal. 21 (2): 128â131. doi:10.1093/comjnl/21.2.128.

^ Hsu, Aaron (November 18, 2017). "Design Patterns vs. Anti-pattern in APL". functionalconf.com. Archived from the original on March 23, 2018. Retrieved 2018-04-07.

^ Magnenat-Thalmann, Nadia; Thalmann, Daniel (1985). Computer Animation Theory and Practice. Springer-Verlag. p.Â 38. ISBNÂ 9784431684336. Retrieved April 3, 2018. Digital Effects is another production house that worked on Tron. They used a laser-scanning system to digitize, store and reproduce images. Judson Rosebush, president of Digital Effects, is the primary designer of APL VISION and FORTRAN VISION, two computer animation packages that are currently used.

^ Gutsell, Sam (October 17, 2017). "Stormwind Simulator at Dyalog '16". www.optima-systems.co.uk. Optima Systems. Retrieved April 3, 2018. Stormwind is a [3D boating simulator] that has gained a huge amount of interest in the APL community.

^ "OP-Pohjola ja Tieto hoitivat sovelluksen muutostyÃ¶t sujuvalla yhteistyÃ¶llÃ¤" [Smooth cooperation between OP-Pohjola and Tieto enabled app modification] (PDF). www.tieto.com (in Finnish). Tieto. Retrieved April 3, 2018.[permanent dead link]

^ "Vi idag" [We today]. profdoccare.se (in Swedish). Retrieved April 3, 2018. Through the choice of APL as a technical platform, it is relatively easy to quickly build a solution that can be called a executable prototype (translated from the original)

^ Brenner, Charles. "DNA Identification Technology and APL". dna-view.com. Presentation at the 2005 APL User Conference. Retrieved January 9, 2015.

^ Brenner, Charles. "There's DNA Everywhere â an Opportunity for APL". www.youtube.com. YouTube. Archived from the original on 2021-11-14. Retrieved January 9, 2015.

^ "Tips for golfing in APL". stackexchange.com. Retrieved April 3, 2018.

^ "Awards â 1973 â Lawrence Breed". Association for Computing Machinery. Archived from the original on April 2, 2012.

^ "Awards â 1973 â Richard Lathwell". Association for Computing Machinery. Archived from the original on April 2, 2012.

^ "Awards â 1973 â Roger Moore". Association for Computing Machinery. Archived from the original on April 2, 2012.

^ "IBM 5100". old-computers.com. Archived from the original on April 30, 2018. Retrieved April 8, 2018.

^ "Welcome, IBM, to personal computing". Byte. December 1975. p.Â 90. Retrieved April 29, 2018.

^ "Chronology of APL and its Influences on Computer Language Development". www.sigapl.org. ACM. Retrieved April 29, 2018.

^ Larry Breed (August 2006). "How We Got To APL\1130". Vector (British APL Association). 22 (3). ISSNÂ 0955-1433. Archived from the original on May 12, 2008. Retrieved April 29, 2018.

^ Roger Moore (2005). "History of I. P. Sharp Associates Timesharing and Network". Rogerdmoore.ca. Roger Moore. Archived from the original on April 4, 2019. Retrieved March 7, 2018.

^ Blumenthal, Marcia (May 18, 1981). "VAX-11s Acquire APL Processor". Computerworld. Retrieved April 22, 2018.

^ Jump up to: a b c "Kenneth E. Iverson Award for Outstanding Contribution to APL". SIGPLAN Chapter on Array Programming Languages (SIGAPL). Archived from the original on February 26, 2012.

^ Mark Schora (2021-01-26). "Log-On Software announces Log-On APL2". Log-On Software. Retrieved 2021-11-17.

^ Kelley, R.A. "APLGOL, an Experimental Structured Programming Language". IBM Journal of Research and Development.

^ Johnston, Ronald L. "APLGOL: Structured Programming Facilities for APL". Hewlett-Packard Journal.

^ "Dyalog Ltd website". Retrieved 6 June 2018.

^ "Dyalog at 25" (PDF). Vector Magazine. British APL Association. September 2008. Retrieved April 14, 2018.[permanent dead link]

^ Kromberg, Morten (22 October 2007). "Arrays of Objects" (PDF). Proceedings of the 2007 Symposium on Dynamic Languages: 20. doi:10.1145/1297081.1297087. ISBNÂ 9781595938688. S2CIDÂ 18484472. Retrieved 27 August 2018.

^ Scholes, John. "D: A functional subset of Dyalog APL". British APL Asscociation.

^ "Dyalog - Prices and Licences".

^ "2016 Iverson Award Recognises Dyalog's CEO and CXO". Retrieved 6 June 2018.

^ "Nested Arrays Research System â NARS2000: An Experimental APL Interpreter". NARS2000. Sudley Place Software. Retrieved July 10, 2015.

^ "APLX has been withdrawn from commercial sale but can be downloaded free of charge". Microapl.com. Retrieved April 14, 2018.

^ "GNU APL". directory.fsf.org. Free Software Directory. Retrieved September 28, 2013.

^ Stallman, Richard M. "RMS BerÃ¤ttar". Archived from the original on November 26, 2018. Retrieved April 22, 2018.

^ Budd, Timothy (1988). An APL Compiler. Springer-Verlag. ISBNÂ 978-0-387-96643-4.

^ SIGAPL. "What is APL?". www.sigapl.org. SIGAPL. Retrieved January 20, 2015.

^ Ju, Dz-Ching; Ching, Wai-Mee (1991). "Exploitation of APL data parallelism on a shared-memory MIMD machine". Newsletter ACM SIGPLAN Notices. 26 (7): 61â72. doi:10.1145/109625.109633. S2CIDÂ 8584353.

^ Hsu, Aaron W.; Bowman, William J. "Revisiting APL in the Modern Era" (PDF). www.cs.princeton.edu. Indiana University / Princeton. Retrieved January 20, 2015.

^ Ching, W.-M.; Ju, D. (1991). "Execution of automatically parallelized APL programs on RP3". IBM Journal of Research & Development. 35 (5/6): 767â777. doi:10.1147/rd.355.0767. Retrieved January 20, 2015.

^ Blelloch, Guy E.; Sabot, Gary W. (1990). "Compiling Collection-Oriented Languages onto Massively Parallel Computers". Journal of Parallel and Distributed Computing. 8 (2): 119â134. CiteSeerXÂ 10.1.1.51.5088. doi:10.1016/0743-7315(90)90087-6. Collection oriented languages include APL, APL2

^ Jendrsczok, Johannes; Hoffmann, Rolf; Ediger, Patrick; Keller, JÃ¶rg. "Implementing APL-like data parallel functions on a GCA machine" (PDF). www.fernuni-hagen.de. Fernuni-Hagen.De. pp.Â 1â6. Archived from the original (PDF) on January 22, 2015. Retrieved January 22, 2015. GCA â Global Cellular Automation. Inherently massively parallel. 'APL has been chosen because of the ability to express matrix and vector' structures.

^ Brenner of IBM T.J.Watson Research Center, Norman (1984). "VLSI circuit design using APL with fortran subroutines". Proceedings of the international conference on APL - APL '84. ACM SIGAPL APL Quote Quad. Vol.Â 14. ACM SIGAPL. pp.Â 77â79. doi:10.1145/800058.801079. ISBNÂ 978-0897911375. S2CIDÂ 30863491. APL for interactiveness and ease of coding

^ Gamble, D.J.; Hobson, R.F. (1989). "Towards a graphics/Procedural environment for constructing VLSI module generators". Conference Proceeding IEEE Pacific Rim Conference on Communications, Computers and Signal Processing. pp.Â 606â611. doi:10.1109/PACRIM.1989.48437. S2CIDÂ 7921438. VLSI module generators are described. APL and C, as examples of interpreted and compiled languages, can be interfaced to an advanced graphics display

^ Lee, Robert S. (1983). "Two Implementations of APL". PC Magazine. 2 (5): 379. Retrieved January 20, 2015.

^ MARTHA and LLAMA. "The APL Computer Language". marthallama.org. MarthaLlama. Retrieved January 20, 2015.

^ Metzger, Robert; Wen, Zhaofang (2000). Automatic Algorithm Recognition and Replacement: A New Approach to Program Optimization. The MIT press. ISBNÂ 9780262133685. Retrieved May 6, 2018.

^ Snyder, Lawrence (1982). "Recognition and Selection of Idioms for Code Optimization". Acta Informatica. 17 (3). doi:10.1007/BF00264357. S2CIDÂ 8369972.

^ Cheng, Feng Sheng (1981). "Idiom matching: an optimization technique for an APL compiler". Iowa State University. Retrieved May 6, 2018. {{cite journal}}: Cite journal requires |journal= (help)

^ "Idiom Recognition". dyalog.com. Retrieved May 6, 2018.

^ Strawn, George O. (March 1977). "Does APL really need runâtime parsing?". Journal of Software: Practice and Experience. 7 (2): 193â200. doi:10.1002/spe.4380070207. S2CIDÂ 1463012.

^ Jump up to: a b "Compiler User Guide" (PDF). www.dyalog.com. Dyalog Ltd. Retrieved May 7, 2018.

^ Jump up to: a b 
Driscoll Jr., Graham C.; Orth, Donald L. (November 1986). "Compiling APL: The Yorktown APL Translator". IBM Journal of Research and Development. 30 (6): 583â593. doi:10.1147/rd.306.0583. S2CIDÂ 2299699.

^ "Chronology of APL". www.sigapl.org. ACM. Retrieved May 7, 2018.

^ 
Wai-Mee, Ching (November 1986). "Program Analysis and Code Generation in an APL/370 Compiler". IBM Journal of Research and Development. 30 (6): 594â602. doi:10.1147/rd.306.0594. S2CIDÂ 17306407.

^ "The APEX Project".

^ "APL Compiler (message from Jim Weigang to the comp.lang.apl Newsgroup)". Apr 5, 1994.


Further reading[edit]
An APL Machine (1970 Stanford doctoral dissertation by Philip Abrams)
A Personal History Of APL (1982 article by Michael S. Montalbano)
McIntyre, Donald B. (1991). "Language as an intellectual tool: From hieroglyphics to APL" (PDF). IBM Systems Journal. 30 (4): 554â581. doi:10.1147/sj.304.0554. Archived from the original (PDF) on May 4, 2006.
Iverson, Kenneth E. (1991). "A Personal view of APL" (PDF). IBM Systems Journal. 30 (4): 582â593. doi:10.1147/sj.304.0582. Archived from the original (PDF) on February 27, 2008.
A Programming Language by Kenneth E. Iverson
APL in Exposition by Kenneth E. Iverson
Brooks, Frederick P.; Kenneth Iverson (1965). Automatic Data Processing, System/360 Edition. ISBNÂ 0-471-10605-4.
Askoolum, Ajay (August 2006). System Building with APL + Win. Wiley. ISBNÂ 978-0-470-03020-2.
Falkoff, Adin D.; Iverson, Kenneth E.; Sussenguth, Edward H. (1964). "A Formal Description of System/360" (PDF). IBM Systems Journal. 3 (2): 198â261. doi:10.1147/sj.32.0198. Archived from the original (PDF) on February 27, 2008.
History of Programming Languages, chapter 14[clarification needed]
Banon, Gerald Jean Francis (1989). Bases da Computacao Grafica. Rio de Janeiro: Campus. p.Â 141.
LePage, Wilbur R. (1978). Applied A.P.L. Programming. Prentice Hall.
Mougin, Philippe; Ducasse, Stephane (November 2003). "OOPAL: Integrating Array Programming in ObjectOriented Programming" (PDF). Proceeding OOPSLA '03 Proceedings of the 18th Annual ACM SIGPLAN Conference on Object-oriented Programing, Systems, Languages, and Applications. 38 (11): 65â77. doi:10.1145/949343.949312. Archived from the original (PDF) on November 14, 2006.
Dyalog Limited (September 2006). An Introduction to Object Oriented Programming For APL Programmers (PDF). Dyalog Limited. Archived from the original (PDF) on October 4, 2007.
Shustek, Len (October 10, 2012). "The APL Programming Language Source Code". Computer History Museum (CHM). Archived from the original on September 6, 2017. Retrieved September 6, 2017.
Svoboda, AntonÃ­n; White, Donnamaie E. (2016) [2012, 1985, 1979-08-01]. Advanced Logical Circuit Design Techniques (PDF) (retyped electronic reissueÂ ed.). Garland STPM Press (original issue) / WhitePubs Enterprises, Inc. (reissue). ISBNÂ 978-0-8240-7014-4. LCCNÂ 78-31384. Archived (PDF) from the original on 2017-04-14. Retrieved 2017-04-15. [1] [2]
Video[edit]
The Origins of APL - a 1974 talk show style interview with the original developers of APL.
APL demonstration - a 1975 live demonstration of APL by Professor Bob Spence, Imperial College London.
Conway's Game Of Life in APL - a 2009 tutorial by John Scholes of Dyalog Ltd. which implements Conway's Game of Life in a single line of APL.
50 Years of APL - a 2009 introduction to APL by Graeme Robertson.
External links[edit]
This article's use of external links may not follow Wikipedia's policies or guidelines. Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references.  (August 2020) (Learn how and when to remove this template message)



Wikimedia Commons has media related to APL (programming language).

Online resources[edit]
TryAPL.org, an online APL primer
APL Wiki
APL at Curlie
APL2C, a source of links to APL compilers
Providers[edit]
Log-On APL2
Dyalog APL
APLX
APL2000
NARS2000
GNU APL
OpenAPL
User groups and societies[edit]
Finland: Finnish APL Association (FinnAPL)
France: APL et J
Germany: APL-Germany e.V.
Japan: Japan APL Association (JAPLA)
Sweden: Swedish APL User Group (SwedAPL) Archived 2018-04-02 at the Wayback Machine
Switzerland: Swiss APL User Group (SAUG)
United Kingdom: The British APL Association
United States: ACM SIGPLAN chapter on Array Programming Languages (SIGAPL)
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteAPL programming languageFeatures
APL syntax and symbols
Direct function (dfn)
Code pages
Iverson bracket
Rank
Shared Variables
ImplementationsMajor
Dyalog APL
IBM APL2
APL2000
SHARP APL
APLX
NARS2000
Dialects
A+
APLNext
ELI
GNU APL
J
K, Q; kdb+
LYaPAS
Polymorphic Programming Language (PPL)
CommunityProfessionalassociations
Association for Computing Machinery: SIGAPL
British APL Association
OrganizationsBusiness
Analogic Corporation
CompuServe
Digital Equipment Corporation (DEC)
DNA Systems
Dyalog Ltd.
IBM
I. P. Sharp Associates
Kx Systems
Micro Computer Machines (MCM)
Science Research Associates
Scientific Time Sharing Corporation (STSC)
Soliton Incorporated
Telecompute Integrated Systems, Inc.
Time Sharing Resources (TSR)
Education
Carnegie Mellon University (CMU)
University of Maryland
People
Phil Abrams
Bob Bernecky
Larry Breed
Charles Brenner
Fred Brooks
Jim Brown
Adin Falkoff
Patrick E. Hagerty
Herbert Hellerman
Roger Hui
Kenneth E. Iverson
Dick Lathwell
Eugene McDonnell
Robert Metzger
Roger Moore
Alan Perlis
John Scholes
J. Henri Schueler
Bob Smith
Edward H. Sussenguth Jr.
Arthur Whitney
William Yerazunis
Rodnay Zaks
Other
Iverson Award

 Category
 Commons

vteProgramming languages
Comparison
Timeline
History

Ada
ALGOL
APL
Assembly
BASIC
C
C++
C#
COBOL
Erlang
Forth
Fortran
Go
Haskell
Java
JavaScript
Kotlin
Lisp
Lua
ML
Pascal
Perl
PHP
Prolog
Python
R
Ruby
Rust
SQL
Shell
Simula
Smalltalk
Swift
more...

 Category
 Lists: Alphabetical
Categorical
Generational
Non-English-based

vteISO standards .mw-parser-output .nobold{font-weight:normal}by standard numberList of ISO standardsÂ / ISO romanizationsÂ / IEC standards1â9999
1
2
3
4
5
6
7
9
16
17
31
-0
-1
-2
-3
-4
-5
-6
-7
-8
-9
-10
-11
-12
-13
68-1
128
216
217
226
228
233
259
261
262
269
302
306
361
428
500
518
519
639
-1
-2
-3
-5
-6
646
657
668
690
704
732
764
838
843
860
898
965
999
1000
1004
1007
1073-1
1073-2
1155
1413
1538
1629
1745
1989
2014
2015
2022
2033
2047
2108
2145
2146
2240
2281
2533
2709
2711
2720
2788
2848
2852
3029
3103
3166
-1
-2
-3
3297
3307
3601
3602
3864
3901
3950
3977
4031
4157
4165
4217
4909
5218
5426
5427
5428
5725
5775
5776
5800
5807
5964
6166
6344
6346
6385
6425
6429
6438
6523
6709
6943
7001
7002
7010
7027
7064
7098
7185
7200
7498
-1
7637
7736
7810
7811
7812
7813
7816
7942
8000
8093
8178
8217
8373
8501-1
8571
8583
8601
8613
8632
8651
8652
8691
8805/8806
8807
8820-5
8859
-1
-2
-3
-4
-5
-6
-7
-8
-8-I
-9
-10
-11
-12
-13
-14
-15
-16
8879
9000/9001
9036
9075
9126
9141
9227
9241
9293
9314
9362
9407
9496
9506
9529
9564
9592/9593
9594
9660
9797-1
9897
9899
9945
9984
9985
9995
10000â19999
10005
10006
10007
10116
10118-3
10160
10161
10165
10179
10206
10218
10303
-11
-21
-22
-28
-238
10383
10487
10585
10589
10628
10646
10664
10746
10861
10957
10962
10967
11073
11170
11179
11404
11544
11783
11784
11785
11801
11889
11898
11940 (-2)
11941
11941 (TR)
11992
12006
12182
12207
12234-2
12620
13211
-1
-2
13216
13250
13399
13406-2
13450
13485
13490
13567
13568
13584
13616
13816
14000
14031
14224
14289
14396
14443
14496
-2
-3
-6
-10
-11
-12
-14
-17
-20
14617
14644
14649
14651
14698
14764
14882
14971
15022
15189
15288
15291
15292
15398
15408
15444
-3
15445
15438
15504
15511
15686
15693
15706
-2
15707
15897
15919
15924
15926
15926 WIP
15930
16023
16262
16355-1
16612-2
16750
16949 (TS)
17024
17025
17100
17203
17369
17442
17799
18000
18004
18014
18245
18629
18916
19005
19011
19092
-1
-2
19114
19115
19125
19136
19407
19439
19500
19501
19502
19503
19505
19506
19507
19508
19509
19510
19600
19752
19757
19770
19775-1
19794-5
19831
20000â29999
20000
20022
20121
20400
20802
21000
21047
21500
21827
22000
22300
22395
23090-3
23270
23271
23360
24517
24613
24617
24707
25178
25964
26000
26262
26300
26324
27000 series
27000
27001
27002
27005
27006
27729
28000
29110
29148
29199-2
29500
30000+
30170
31000
32000
37001
38500
40500
42010
45001
50001
55000
56000
80000

 Category

vteIEC standardsIEC standards
60027
60034
60038
60062
60063
60068
60112
60228
60269
60297
60309
60320
60364
60446
60559
60601
60870
60870-5
60870-6
60906-1
60908
60929
60958
61030
61131
61131-3
61131-9
61158
61162
61334
61355
61360
61400
61499
61508
61511
61784
61850
61851
61883
61960
61968
61970
62014-4
62026
62056
62061
62196
62262
62264
62304
62325
62351
62365
62366
62379
62386
62455
62680
62682
62700
63110
63119
63382
ISO/IEC standards
646
2022
4909
5218
6429
6523
7810
7811
7812
7813
7816
7942
8613
8632
8652
8859
9126
9293
9496
9529
9592
9593
9899
9945
9995
10021
10116
10165
10179
10646
10967
11172
11179
11404
11544
11801
12207
13250
13346
13522-5
13568
13816
13818
14443
14496
14651
14882
15288
15291
15408
15444
15445
15504
15511
15693
15897
15938
16262
17024
17025
18000
18004
18014
19752
19757
19770
19788
20000
20802
21000
21827
23000
23003
23008
23270
23360
24707
24727
24744
24752
26300
27000
27000-series
27002
27040
29110
29119
33001
38500
42010
80000
81346
Related
International Electrotechnical Commission





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=APL_(programming_language)&oldid=1068476945"
		Categories: .NET programming languagesAPL programming language familyArray programming languagesCommand shellsDynamic programming languagesDynamically typed programming languagesFunctional languagesIBM softwareProgramming languages created in 1964Programming languages with an ISO standardProgramming languagesHidden categories: Webarchive template wayback linksCS1 maint: locationCS1: long volume valueCS1 Finnish-language sources (fi)All articles with dead external linksArticles with dead external links from August 2019Articles with permanently dead external linksCS1 Swedish-language sources (sv)Articles with dead external links from April 2019CS1 errors: missing periodicalArticles with short descriptionShort description is different from WikidataAll articles with unsourced statementsArticles with unsourced statements from September 2020Articles with unsourced statements from February 2020Articles with unsourced statements from July 2015Articles with unsourced statements from May 2021All articles with specifically marked weasel-worded phrasesArticles with specifically marked weasel-worded phrases from March 2015Articles with unsourced statements from December 2019Articles containing potentially dated statements from 2018All articles containing potentially dated statementsWikipedia articles needing clarification from June 2010Wikipedia external links cleanup from August 2020Wikipedia spam cleanup from August 2020Commons category link is on WikidataArticles with Curlie links
	
