
Title:
Support-vector machine
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Set of methods for supervised statistical learning
.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Part of a series onMachine learningand data mining
showProblems
Classification
Clustering
Regression
Anomaly detection
Data Cleaning
AutoML
Association rules
Reinforcement learning
Structured prediction
Feature engineering
Feature learning
Online learning
Semi-supervised learning
Unsupervised learning
Learning to rank
Grammar induction

hideSupervised learning.mw-parser-output .nobold{font-weight:normal}(classificationÂ â¢ regression) 
Decision trees
Ensembles
Bagging
Boosting
Random forest
k-NN
Linear regression
Naive Bayes
Artificial neural networks
Logistic regression
Perceptron
Relevance vector machine (RVM)
Support vector machine (SVM)

showClustering
BIRCH
CURE
Hierarchical
k-means
Expectationâmaximization (EM)
DBSCAN
OPTICS
Mean shift

showDimensionality reduction
Factor analysis
CCA
ICA
LDA
NMF
PCA
PGD
t-SNE

showStructured prediction
Graphical models
Bayes net
Conditional random field
Hidden Markov

showAnomaly detection
k-NN
Local outlier factor

showArtificial neural network
Autoencoder
Cognitive computing
Deep learning
DeepDream
Multilayer perceptron
RNN
LSTM
GRU
ESN
Restricted Boltzmann machine
GAN
SOM
Convolutional neural network
U-Net
Transformer
Vision
Spiking neural network
Memtransistor
Electrochemical RAM (ECRAM)

showReinforcement learning
Q-learning
SARSA
Temporal difference (TD)

showTheory
Kernel machines
Biasâvariance tradeoff
Computational learning theory
Empirical risk minimization
Occam learning
PAC learning
Statistical learning
VC theory

showMachine-learning venues
NeurIPS
ICML
ML
JMLR
ArXiv:cs.LG

showRelated articles
Glossary of artificial intelligence
List of datasets for machine-learning research
Outline of machine learning
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
In machine learning, support-vector machines (SVMs, also support-vector networks[1]) are supervised learning models with associated learning algorithms that analyze data for classification and regression analysis. Developed at AT&T Bell Laboratories by Vladimir Vapnik with colleagues (Boser et al., 1992, Guyon et al., 1993, Cortes and Vapnik, 1995,[2]  Vapnik et al., 1997[citation needed]) SVMs are one of the most robust prediction methods, being based on statistical learning frameworks or VC theory proposed by Vapnik (1982, 1995) and Chervonenkis (1974). Given a set of training examples, each marked as belonging to one of two categories, an SVM training algorithm builds a model that assigns new examples to one category or the other, making it a non-probabilistic binary linear classifier (although methods such as Platt scaling exist to use SVM in a probabilistic classification setting). SVM maps training examples to points in space so as to maximise the width of the gap between the two categories. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall.
In addition to performing linear classification, SVMs can efficiently perform a non-linear classification using what is called the kernel trick, implicitly mapping their inputs into high-dimensional feature spaces.
When data are unlabelled, supervised learning is not possible, and an unsupervised learning approach is required, which attempts to find natural clustering of the data to groups, and then map new data to these formed groups. The support-vector clustering[3] algorithm, created by Hava Siegelmann and Vladimir Vapnik, applies the statistics of support vectors, developed in the support vector machines algorithm, to categorize unlabeled data.[citation needed]

Contents

1 Motivation
2 Definition
3 Applications
4 History
5 Linear SVM

5.1 Hard-margin
5.2 Soft-margin


6 Nonlinear Kernels
7 Computing the SVM classifier

7.1 Primal
7.2 Dual
7.3 Kernel trick
7.4 Modern methods

7.4.1 Sub-gradient descent
7.4.2 Coordinate descent




8 Empirical risk minimization

8.1 Risk minimization
8.2 Regularization and stability
8.3 SVM and the hinge loss

8.3.1 Target functions




9 Properties

9.1 Parameter selection
9.2 Issues


10 Extensions

10.1 Support-vector clustering (SVC)
10.2 Multiclass SVM
10.3 Transductive support-vector machines
10.4 Structured SVM
10.5 Regression
10.6 Bayesian SVM


11 Implementation
12 See also
13 References
14 Further reading
15 External links



Motivation[edit]
  H1 does not separate the classes. H2 does, but only with a small margin.  H3 separates them with the maximal margin.
Classifying data is a common task in machine learning.
Suppose some given data points each belong to one of two classes, and the goal is to decide which class a new data point will be in. In the case of support-vector machines, a data point is viewed as a 
  
    
      
        p
      
    
    {\displaystyle p}
  
-dimensional vector (a list of 
  
    
      
        p
      
    
    {\displaystyle p}
  
 numbers), and we want to know whether we can separate such points with a 
  
    
      
        (
        p
        â
        1
        )
      
    
    {\displaystyle (p-1)}
  
-dimensional hyperplane. This is called a linear classifier. There are many hyperplanes that might classify the data. One reasonable choice as the best hyperplane is the one that represents the largest separation, or margin, between the two classes. So we choose the hyperplane so that the distance from it to the nearest data point on each side is maximized. If such a hyperplane exists, it is known as the maximum-margin hyperplane and the linear classifier it defines is known as a maximum-margin classifier; or equivalently, the perceptron of optimal stability.[citation needed]

Definition[edit]
More formally, a support-vector machine constructs a hyperplane or set of hyperplanes in a high- or infinite-dimensional space, which can be used for classification, regression, or other tasks like outliers detection.[4] Intuitively, a good separation is achieved by the hyperplane that has the largest distance to the nearest training-data point of any class (so-called functional margin), since in general the larger the margin, the lower the generalization error of the classifier.[5]

  Kernel machine
Whereas the original problem may be stated in a finite-dimensional space, it often happens that the sets to discriminate are not linearly separable in that space. For this reason, it was proposed[6] that the original finite-dimensional space be mapped into a much higher-dimensional space, presumably making the separation easier in that space. To keep the computational load reasonable, the mappings used by SVM schemes are designed to ensure that dot products of pairs of input data vectors may be computed easily in terms of the variables in the original space, by defining them in terms of a kernel function 
  
    
      
        k
        (
        x
        ,
        y
        )
      
    
    {\displaystyle k(x,y)}
  
 selected to suit the problem.[7] The hyperplanes in the higher-dimensional space are defined as the set of points whose dot product with a vector in that space is constant, where such a set of vectors is an orthogonal (and thus minimal) set of vectors that defines a hyperplane. The vectors defining the hyperplanes can be chosen to be linear combinations with parameters 
  
    
      
        
          Î±
          
            i
          
        
      
    
    {\displaystyle \alpha _{i}}
  
 of images of feature vectors 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 that occur in the data base. With this choice of a hyperplane, the points 
  
    
      
        x
      
    
    {\displaystyle x}
  
 in the feature space that are mapped into the hyperplane are defined by the relation 
  
    
      
        
          
            â
            
              i
            
          
          
            Î±
            
              i
            
          
          k
          (
          
            x
            
              i
            
          
          ,
          x
          )
          =
          
            constant
          
          .
        
      
    
    {\displaystyle \textstyle \sum _{i}\alpha _{i}k(x_{i},x)={\text{constant}}.}
  
  Note that if 
  
    
      
        k
        (
        x
        ,
        y
        )
      
    
    {\displaystyle k(x,y)}
  
 becomes small as 
  
    
      
        y
      
    
    {\displaystyle y}
  
 grows further away from 
  
    
      
        x
      
    
    {\displaystyle x}
  
, each term in the sum measures the degree of closeness of the test point 
  
    
      
        x
      
    
    {\displaystyle x}
  
 to the corresponding data base point 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
. In this way, the sum of kernels above can be used to measure the relative nearness of each test point to the data points originating in one or the other of the sets to be discriminated. Note the fact that the set of points 
  
    
      
        x
      
    
    {\displaystyle x}
  
 mapped into any hyperplane can be quite convoluted as a result, allowing much more complex discrimination between sets that are not convex at all in the original space.

Applications[edit]
SVMs can be used to solve various real-world problems:

SVMs are helpful in text and hypertext categorization, as their application can significantly reduce the need for labeled training instances in both the standard inductive and transductive settings.[8] Some methods for shallow semantic parsing are based on support vector machines.[9]
Classification of images can also be performed using SVMs. Experimental results show that SVMs achieve significantly higher search accuracy than traditional query refinement schemes after just three to four rounds of relevance feedback. This is also true for image segmentation systems, including those using a modified version SVM that uses the privileged approach as suggested by Vapnik.[10][11]
Classification of satellite data like SAR data using supervised SVM.[12]
Hand-written characters can be recognized using SVM.[13][14]
The SVM algorithm has been widely applied in the biological and other sciences.  They have been used to classify proteins with up to 90% of the compounds classified correctly. Permutation tests based on SVM weights have been suggested as a mechanism for interpretation of SVM models.[15][16] Support-vector machine weights have also been used to interpret SVM models in the past.[17] Posthoc interpretation of support-vector machine models in order to identify features used by the model to make predictions is a relatively new area of research with special significance in the biological sciences.
History[edit]
The original SVM algorithm was invented by Vladimir N. Vapnik and Alexey Ya. Chervonenkis in 1963. In 1992, Bernhard Boser, Isabelle Guyon and Vladimir Vapnik suggested a way to create nonlinear classifiers by applying the kernel trick to maximum-margin hyperplanes.[6] The "soft margin" incarnation, as is commonly used software packages, was proposed by Corinna Cortes and Vapnik in 1993 and published in 1995.[1]

Linear SVM[edit]
  Maximum-margin hyperplane and margins for an SVM trained with samples from two classes. Samples on the margin are called the support vectors.
We are given a training dataset of 
  
    
      
        n
      
    
    {\displaystyle n}
  
 points of the form


  
    
      
        (
        
          
            x
          
          
            1
          
        
        ,
        
          y
          
            1
          
        
        )
        ,
        â¦
        ,
        (
        
          
            x
          
          
            n
          
        
        ,
        
          y
          
            n
          
        
        )
        ,
      
    
    {\displaystyle (\mathbf {x} _{1},y_{1}),\ldots ,(\mathbf {x} _{n},y_{n}),}
  

where the 
  
    
      
        
          y
          
            i
          
        
      
    
    {\displaystyle y_{i}}
  
 are either 1 or â1, each indicating the class to which the point 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 belongs. Each 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 is a 
  
    
      
        p
      
    
    {\displaystyle p}
  
-dimensional real vector. We want to find the "maximum-margin hyperplane" that divides the group of points 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 for which 
  
    
      
        
          y
          
            i
          
        
        =
        1
      
    
    {\displaystyle y_{i}=1}
  
 from the group of points for which 
  
    
      
        
          y
          
            i
          
        
        =
        â
        1
      
    
    {\displaystyle y_{i}=-1}
  
, which is defined so that the distance between the hyperplane and the nearest point 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 from either group is maximized.
Any hyperplane can be written as the set of points 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 satisfying


  
    
      
        
          
            w
          
          
            T
          
        
        
          x
        
        â
        b
        =
        0
        ,
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} -b=0,}
  

where 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 is the (not necessarily normalized) normal vector to the hyperplane. This is much like Hesse normal form, except that 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 is not necessarily a unit vector. The parameter 
  
    
      
        
          
            
              b
              
                â
                
                  w
                
                â
              
            
          
        
      
    
    {\displaystyle {\tfrac {b}{\|\mathbf {w} \|}}}
  
 determines the offset of the hyperplane from the origin along the normal vector 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
.

Hard-margin[edit]
If the training data is linearly separable, we can select two parallel hyperplanes that separate the two classes of data, so that the distance between them is as large as possible. The region bounded by these two hyperplanes is called the "margin", and the maximum-margin hyperplane is the hyperplane that lies halfway between them. With a normalized or standardized dataset, these hyperplanes can be described by the equations


  
    
      
        
          
            w
          
          
            T
          
        
        
          x
        
        â
        b
        =
        1
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} -b=1}
  
 (anything on or above this boundary is of one class, with label 1)
and


  
    
      
        
          
            w
          
          
            T
          
        
        
          x
        
        â
        b
        =
        â
        1
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} -b=-1}
  
 (anything on or below this boundary is of the other class, with label â1).
Geometrically, the distance between these two hyperplanes is 
  
    
      
        
          
            
              2
              
                â
                
                  w
                
                â
              
            
          
        
      
    
    {\displaystyle {\tfrac {2}{\|\mathbf {w} \|}}}
  
,[18] so to maximize the distance between the planes we want to minimize 
  
    
      
        â
        
          w
        
        â
      
    
    {\displaystyle \|\mathbf {w} \|}
  
. The distance is computed using the distance from a point to a plane equation. We also have to prevent data points from falling into the margin, we add the following constraint: for each 
  
    
      
        i
      
    
    {\displaystyle i}
  
 either


  
    
      
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        â¥
        1
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} _{i}-b\geq 1}
  
, if 
  
    
      
        
          y
          
            i
          
        
        =
        1
      
    
    {\displaystyle y_{i}=1}
  
,
or


  
    
      
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        â¤
        â
        1
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} _{i}-b\leq -1}
  
, if 
  
    
      
        
          y
          
            i
          
        
        =
        â
        1
      
    
    {\displaystyle y_{i}=-1}
  
.
These constraints state that each data point must lie on the correct side of the margin.
This can be rewritten as


  
    
      
        
          y
          
            i
          
        
        (
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        )
        â¥
        1
        ,
        
        
          Â for allÂ 
        
        1
        â¤
        i
        â¤
        n
        .
        
        
        (
        1
        )
      
    
    {\displaystyle y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\geq 1,\quad {\text{ for all }}1\leq i\leq n.\qquad \qquad (1)}
  

We can put this together to get the optimization problem:

"Minimize 
  
    
      
        â
        
          w
        
        â
      
    
    {\displaystyle \|\mathbf {w} \|}
  
 subject to 
  
    
      
        
          y
          
            i
          
        
        (
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        )
        â¥
        1
      
    
    {\displaystyle y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\geq 1}
  
 for 
  
    
      
        i
        =
        1
        ,
        â¦
        ,
        n
      
    
    {\displaystyle i=1,\ldots ,n}
  
."
The 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 and 
  
    
      
        b
      
    
    {\displaystyle b}
  
 that solve this problem determine our classifier, 
  
    
      
        
          x
        
        â¦
        sgn
        â¡
        (
        
          
            w
          
          
            T
          
        
        
          x
        
        â
        b
        )
      
    
    {\displaystyle \mathbf {x} \mapsto \operatorname {sgn}(\mathbf {w} ^{T}\mathbf {x} -b)}
  
 where 
  
    
      
        sgn
        â¡
        (
        â
        )
      
    
    {\displaystyle \operatorname {sgn}(\cdot )}
  
 is the sign function.
An important consequence of this geometric description is that the max-margin hyperplane is completely determined by those 
  
    
      
        
          
            
              
                x
                â
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\vec {x}}_{i}}
  
 that lie nearest to it. These 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 are called support vectors.

Soft-margin[edit]
To extend SVM to cases in which the data are not linearly separable, the hinge loss function is helpful


  
    
      
        max
        
          (
          
            0
            ,
            1
            â
            
              y
              
                i
              
            
            (
            
              
                w
              
              
                T
              
            
            
              
                x
              
              
                i
              
            
            â
            b
            )
          
          )
        
        .
      
    
    {\displaystyle \max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\right).}
  

Note that 
  
    
      
        
          y
          
            i
          
        
      
    
    {\displaystyle y_{i}}
  
 is the i-th target (i.e., in this case, 1 or â1), and 
  
    
      
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
      
    
    {\displaystyle \mathbf {w} ^{T}\mathbf {x} _{i}-b}
  
 is the i-th output.
This function is zero if the constraint in (1) is satisfied, in other words, if 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 lies on the correct side of the margin. For data on the wrong side of the margin, the function's value is proportional to the distance from the margin.
The goal of the optimization then is to minimize


  
    
      
        Î»
        â
        
          w
        
        
          â
          
            2
          
        
        +
        
          [
          
            
              
                1
                n
              
            
            
              â
              
                i
                =
                1
              
              
                n
              
            
            max
            
              (
              
                0
                ,
                1
                â
                
                  y
                  
                    i
                  
                
                (
                
                  
                    w
                  
                  
                    T
                  
                
                
                  
                    x
                  
                  
                    i
                  
                
                â
                b
                )
              
              )
            
          
          ]
        
        ,
      
    
    {\displaystyle \lambda \lVert \mathbf {w} \rVert ^{2}+\left[{\frac {1}{n}}\sum _{i=1}^{n}\max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\right)\right],}
  

where the parameter 
  
    
      
        Î»
        >
        0
      
    
    {\displaystyle \lambda >0}
  
 determines the trade-off between increasing the margin size and ensuring that the 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 lie on the correct side of the margin. Thus, for sufficiently small values of 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
, it will behave similar to the hard-margin SVM, if the input data are linearly classifiable, but will still learn if a classification rule is viable or not. (This parameter 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 is also called C, e.g. in LIBSVM.)

Nonlinear Kernels[edit]
  Kernel machine
The original maximum-margin hyperplane algorithm proposed by Vapnik in 1963 constructed a linear classifier. However, in 1992, Bernhard Boser, Isabelle Guyon and Vladimir Vapnik suggested a way to create nonlinear classifiers by applying the kernel trick (originally proposed by Aizerman et al.[19]) to maximum-margin hyperplanes.[6] The resulting algorithm is formally similar, except that every dot product is replaced by a nonlinear kernel function. This allows the algorithm to fit the maximum-margin hyperplane in a transformed feature space. The transformation may be nonlinear and the transformed space high-dimensional; although the classifier is a hyperplane in the transformed feature space, it may be nonlinear in the original input space.
It is noteworthy that working in a higher-dimensional feature space increases the generalization error of support-vector machines, although given enough samples the algorithm still performs well.[20]
Some common kernels include:

Polynomial (homogeneous): 
  
    
      
        k
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        ,
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
        =
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        â
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        
          )
          
            d
          
        
      
    
    {\displaystyle k({\vec {x_{i}}},{\vec {x_{j}}})=({\vec {x_{i}}}\cdot {\vec {x_{j}}})^{d}}
  
. Particularly, when 
  
    
      
        d
        =
        1
      
    
    {\displaystyle d=1}
  
, this becomes the linear kernel.
Polynomial (inhomogeneous): 
  
    
      
        k
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        ,
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
        =
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        â
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        +
        r
        
          )
          
            d
          
        
      
    
    {\displaystyle k({\vec {x_{i}}},{\vec {x_{j}}})=({\vec {x_{i}}}\cdot {\vec {x_{j}}}+r)^{d}}
  
.
Gaussian radial basis function: 
  
    
      
        k
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        ,
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
        =
        exp
        â¡
        (
        â
        Î³
        â
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        â
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        
          â
          
            2
          
        
        )
      
    
    {\displaystyle k({\vec {x_{i}}},{\vec {x_{j}}})=\exp(-\gamma \|{\vec {x_{i}}}-{\vec {x_{j}}}\|^{2})}
  
 for 
  
    
      
        Î³
        >
        0
      
    
    {\displaystyle \gamma >0}
  
. Sometimes parametrized using 
  
    
      
        Î³
        =
        1
        
          /
        
        (
        2
        
          Ï
          
            2
          
        
        )
      
    
    {\displaystyle \gamma =1/(2\sigma ^{2})}
  
.
Sigmoid function (Hyperbolic tangent): 
  
    
      
        k
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        ,
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
        =
        tanh
        â¡
        (
        Îº
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        â
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        +
        c
        )
      
    
    {\displaystyle k({\vec {x_{i}}},{\vec {x_{j}}})=\tanh(\kappa {\vec {x_{i}}}\cdot {\vec {x_{j}}}+c)}
  
 for some (not every) 
  
    
      
        Îº
        >
        0
      
    
    {\displaystyle \kappa >0}
  
 and 
  
    
      
        c
        <
        0
      
    
    {\displaystyle c<0}
  
.
The kernel is related to the transform 
  
    
      
        Ï
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        )
      
    
    {\displaystyle \varphi ({\vec {x_{i}}})}
  
 by the equation 
  
    
      
        k
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        ,
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
        =
        Ï
        (
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        )
        â
        Ï
        (
        
          
            
              
                x
                
                  j
                
              
              â
            
          
        
        )
      
    
    {\displaystyle k({\vec {x_{i}}},{\vec {x_{j}}})=\varphi ({\vec {x_{i}}})\cdot \varphi ({\vec {x_{j}}})}
  
. The value w is also in the transformed space, with 
  
    
      
        
          
            
              
                w
                â
              
            
          
          =
          
            â
            
              i
            
          
          
            Î±
            
              i
            
          
          
            y
            
              i
            
          
          Ï
          (
          
            
              
                
                  x
                  â
                
              
            
            
              i
            
          
          )
        
      
    
    {\displaystyle \textstyle {\vec {w}}=\sum _{i}\alpha _{i}y_{i}\varphi ({\vec {x}}_{i})}
  
. Dot products with w for classification can again be computed by the kernel trick, i.e. 
  
    
      
        
          
            
              
                w
                â
              
            
          
          â
          Ï
          (
          
            
              
                x
                â
              
            
          
          )
          =
          
            â
            
              i
            
          
          
            Î±
            
              i
            
          
          
            y
            
              i
            
          
          k
          (
          
            
              
                
                  x
                  â
                
              
            
            
              i
            
          
          ,
          
            
              
                x
                â
              
            
          
          )
        
      
    
    {\displaystyle \textstyle {\vec {w}}\cdot \varphi ({\vec {x}})=\sum _{i}\alpha _{i}y_{i}k({\vec {x}}_{i},{\vec {x}})}
  
.

Computing the SVM classifier[edit]
Computing the (soft-margin) SVM classifier amounts to minimizing an expression of the form


  
    
      
        
          [
          
            
              
                1
                n
              
            
            
              â
              
                i
                =
                1
              
              
                n
              
            
            max
            
              (
              
                0
                ,
                1
                â
                
                  y
                  
                    i
                  
                
                (
                
                  
                    w
                  
                  
                    T
                  
                
                
                  
                    x
                  
                  
                    i
                  
                
                â
                b
                )
              
              )
            
          
          ]
        
        +
        Î»
        â
        
          w
        
        
          â
          
            2
          
        
        .
        
        (
        2
        )
      
    
    {\displaystyle \left[{\frac {1}{n}}\sum _{i=1}^{n}\max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\right)\right]+\lambda \|\mathbf {w} \|^{2}.\qquad (2)}
  

We focus on the soft-margin classifier since, as noted above, choosing a sufficiently small value for 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 yields the hard-margin classifier for linearly classifiable input data. The classical approach, which involves reducing (2) to a quadratic programming problem, is detailed below. Then, more recent approaches such as sub-gradient descent and coordinate descent will be discussed.

Primal[edit]
Minimizing (2) can be rewritten as a constrained optimization problem with a differentiable objective function in the following way.
For each 
  
    
      
        i
        â
        {
        1
        ,
        
        â¦
        ,
        
        n
        }
      
    
    {\displaystyle i\in \{1,\,\ldots ,\,n\}}
  
 we introduce a variable 
  
    
      
        
          Î¶
          
            i
          
        
        =
        max
        
          (
          
            0
            ,
            1
            â
            
              y
              
                i
              
            
            (
            
              
                w
              
              
                T
              
            
            
              
                x
              
              
                i
              
            
            â
            b
            )
          
          )
        
      
    
    {\displaystyle \zeta _{i}=\max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\right)}
  
. Note that 
  
    
      
        
          Î¶
          
            i
          
        
      
    
    {\displaystyle \zeta _{i}}
  
 is the smallest nonnegative number satisfying 
  
    
      
        
          y
          
            i
          
        
        (
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        )
        â¥
        1
        â
        
          Î¶
          
            i
          
        
        .
      
    
    {\displaystyle y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\geq 1-\zeta _{i}.}
  

Thus we can rewrite the optimization problem as follows


  
    
      
        
          minimizeÂ 
        
        
          
            1
            n
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          Î¶
          
            i
          
        
        +
        Î»
        â
        
          w
        
        
          â
          
            2
          
        
      
    
    {\displaystyle {\text{minimize }}{\frac {1}{n}}\sum _{i=1}^{n}\zeta _{i}+\lambda \|\mathbf {w} \|^{2}}
  


  
    
      
        
          subject toÂ 
        
        
          y
          
            i
          
        
        (
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        )
        â¥
        1
        â
        
          Î¶
          
            i
          
        
        
        
          Â andÂ 
        
        
        
          Î¶
          
            i
          
        
        â¥
        0
        ,
        
        
          for allÂ 
        
        i
        .
      
    
    {\displaystyle {\text{subject to }}y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\geq 1-\zeta _{i}\,{\text{ and }}\,\zeta _{i}\geq 0,\,{\text{for all }}i.}
  

This is called the primal problem.

Dual[edit]
By solving for the Lagrangian dual of the above problem, one obtains the simplified problem


  
    
      
        
          maximize
        
        
        
        f
        (
        
          c
          
            1
          
        
        â¦
        
          c
          
            n
          
        
        )
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        â
        
          
            1
            2
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          â
          
            j
            =
            1
          
          
            n
          
        
        
          y
          
            i
          
        
        
          c
          
            i
          
        
        (
        
          
            x
          
          
            i
          
          
            T
          
        
        
          
            x
          
          
            j
          
        
        )
        
          y
          
            j
          
        
        
          c
          
            j
          
        
        ,
      
    
    {\displaystyle {\text{maximize}}\,\,f(c_{1}\ldots c_{n})=\sum _{i=1}^{n}c_{i}-{\frac {1}{2}}\sum _{i=1}^{n}\sum _{j=1}^{n}y_{i}c_{i}(\mathbf {x} _{i}^{T}\mathbf {x} _{j})y_{j}c_{j},}
  


  
    
      
        
          subject toÂ 
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        
          y
          
            i
          
        
        =
        0
        ,
        
        
          andÂ 
        
        0
        â¤
        
          c
          
            i
          
        
        â¤
        
          
            1
            
              2
              n
              Î»
            
          
        
        
        
          for allÂ 
        
        i
        .
      
    
    {\displaystyle {\text{subject to }}\sum _{i=1}^{n}c_{i}y_{i}=0,\,{\text{and }}0\leq c_{i}\leq {\frac {1}{2n\lambda }}\;{\text{for all }}i.}
  

This is called the dual problem. Since the dual maximization problem is a quadratic function of the 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 subject to linear constraints, it is efficiently solvable by quadratic programming algorithms.
Here, the variables 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 are defined such that


  
    
      
        
          w
        
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        
          y
          
            i
          
        
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {w} =\sum _{i=1}^{n}c_{i}y_{i}\mathbf {x} _{i}}
  
.
Moreover, 
  
    
      
        
          c
          
            i
          
        
        =
        0
      
    
    {\displaystyle c_{i}=0}
  
 exactly when 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 lies on the correct side of the margin, and 
  
    
      
        0
        <
        
          c
          
            i
          
        
        <
        (
        2
        n
        Î»
        
          )
          
            â
            1
          
        
      
    
    {\displaystyle 0<c_{i}<(2n\lambda )^{-1}}
  
  when 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 lies on the margin's boundary. It follows that 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 can be written as a linear combination of the support vectors.
The offset, 
  
    
      
        b
      
    
    {\displaystyle b}
  
, can be recovered by finding an 
  
    
      
        
          
            x
          
          
            i
          
        
      
    
    {\displaystyle \mathbf {x} _{i}}
  
 on the margin's boundary and solving


  
    
      
        
          y
          
            i
          
        
        (
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        b
        )
        =
        1
        
        âº
        
        b
        =
        
          
            w
          
          
            T
          
        
        
          
            x
          
          
            i
          
        
        â
        
          y
          
            i
          
        
        .
      
    
    {\displaystyle y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)=1\iff b=\mathbf {w} ^{T}\mathbf {x} _{i}-y_{i}.}
  

(Note that 
  
    
      
        
          y
          
            i
          
          
            â
            1
          
        
        =
        
          y
          
            i
          
        
      
    
    {\displaystyle y_{i}^{-1}=y_{i}}
  
 since 
  
    
      
        
          y
          
            i
          
        
        =
        Â±
        1
      
    
    {\displaystyle y_{i}=\pm 1}
  
.)

Kernel trick[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Kernel method
  A training example of SVM with kernel given by Ï((a, b)) = (a, b, a2 + b2)
Suppose now that we would like to learn a nonlinear classification rule which corresponds to a linear classification rule for the transformed data points 
  
    
      
        Ï
        (
        
          
            x
          
          
            i
          
        
        )
        .
      
    
    {\displaystyle \varphi (\mathbf {x} _{i}).}
  
 Moreover, we are given a kernel function 
  
    
      
        k
      
    
    {\displaystyle k}
  
 which satisfies 
  
    
      
        k
        (
        
          
            x
          
          
            i
          
        
        ,
        
          
            x
          
          
            j
          
        
        )
        =
        Ï
        (
        
          
            x
          
          
            i
          
        
        )
        â
        Ï
        (
        
          
            x
          
          
            j
          
        
        )
      
    
    {\displaystyle k(\mathbf {x} _{i},\mathbf {x} _{j})=\varphi (\mathbf {x} _{i})\cdot \varphi (\mathbf {x} _{j})}
  
.
We know the classification vector 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 in the transformed space satisfies


  
    
      
        
          w
        
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        
          y
          
            i
          
        
        Ï
        (
        
          
            x
          
          
            i
          
        
        )
        ,
      
    
    {\displaystyle \mathbf {w} =\sum _{i=1}^{n}c_{i}y_{i}\varphi (\mathbf {x} _{i}),}
  

where, the 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 are obtained by solving the optimization problem


  
    
      
        
          
            
              
                
                  maximize
                
                
                
                f
                (
                
                  c
                  
                    1
                  
                
                â¦
                
                  c
                  
                    n
                  
                
                )
              
              
                
                =
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  c
                  
                    i
                  
                
                â
                
                  
                    1
                    2
                  
                
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  â
                  
                    j
                    =
                    1
                  
                  
                    n
                  
                
                
                  y
                  
                    i
                  
                
                
                  c
                  
                    i
                  
                
                (
                Ï
                (
                
                  
                    x
                  
                  
                    i
                  
                
                )
                â
                Ï
                (
                
                  
                    x
                  
                  
                    j
                  
                
                )
                )
                
                  y
                  
                    j
                  
                
                
                  c
                  
                    j
                  
                
              
            
            
              
              
                
                =
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  c
                  
                    i
                  
                
                â
                
                  
                    1
                    2
                  
                
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  â
                  
                    j
                    =
                    1
                  
                  
                    n
                  
                
                
                  y
                  
                    i
                  
                
                
                  c
                  
                    i
                  
                
                k
                (
                
                  
                    x
                  
                  
                    i
                  
                
                ,
                
                  
                    x
                  
                  
                    j
                  
                
                )
                
                  y
                  
                    j
                  
                
                
                  c
                  
                    j
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}{\text{maximize}}\,\,f(c_{1}\ldots c_{n})&=\sum _{i=1}^{n}c_{i}-{\frac {1}{2}}\sum _{i=1}^{n}\sum _{j=1}^{n}y_{i}c_{i}(\varphi (\mathbf {x} _{i})\cdot \varphi (\mathbf {x} _{j}))y_{j}c_{j}\\&=\sum _{i=1}^{n}c_{i}-{\frac {1}{2}}\sum _{i=1}^{n}\sum _{j=1}^{n}y_{i}c_{i}k(\mathbf {x} _{i},\mathbf {x} _{j})y_{j}c_{j}\\\end{aligned}}}
  


  
    
      
        
          subject toÂ 
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        
          y
          
            i
          
        
        =
        0
        ,
        
        
          andÂ 
        
        0
        â¤
        
          c
          
            i
          
        
        â¤
        
          
            1
            
              2
              n
              Î»
            
          
        
        
        
          for allÂ 
        
        i
        .
      
    
    {\displaystyle {\text{subject to }}\sum _{i=1}^{n}c_{i}y_{i}=0,\,{\text{and }}0\leq c_{i}\leq {\frac {1}{2n\lambda }}\;{\text{for all }}i.}
  

The coefficients 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 can be solved for using quadratic programming, as before. Again, we can find some index 
  
    
      
        i
      
    
    {\displaystyle i}
  
 such that 
  
    
      
        0
        <
        
          c
          
            i
          
        
        <
        (
        2
        n
        Î»
        
          )
          
            â
            1
          
        
      
    
    {\displaystyle 0<c_{i}<(2n\lambda )^{-1}}
  
, so that 
  
    
      
        Ï
        (
        
          
            x
          
          
            i
          
        
        )
      
    
    {\displaystyle \varphi (\mathbf {x} _{i})}
  
 lies on the boundary of the margin in the transformed space, and then solve


  
    
      
        
          
            
              
                b
                =
                
                  
                    w
                  
                  
                    T
                  
                
                Ï
                (
                
                  
                    x
                  
                  
                    i
                  
                
                )
                â
                
                  y
                  
                    i
                  
                
              
              
                
                =
                
                  [
                  
                    
                      â
                      
                        j
                        =
                        1
                      
                      
                        n
                      
                    
                    
                      c
                      
                        j
                      
                    
                    
                      y
                      
                        j
                      
                    
                    Ï
                    (
                    
                      
                        x
                      
                      
                        j
                      
                    
                    )
                    â
                    Ï
                    (
                    
                      
                        x
                      
                      
                        i
                      
                    
                    )
                  
                  ]
                
                â
                
                  y
                  
                    i
                  
                
              
            
            
              
              
                
                =
                
                  [
                  
                    
                      â
                      
                        j
                        =
                        1
                      
                      
                        n
                      
                    
                    
                      c
                      
                        j
                      
                    
                    
                      y
                      
                        j
                      
                    
                    k
                    (
                    
                      
                        x
                      
                      
                        j
                      
                    
                    ,
                    
                      
                        x
                      
                      
                        i
                      
                    
                    )
                  
                  ]
                
                â
                
                  y
                  
                    i
                  
                
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}b=\mathbf {w} ^{T}\varphi (\mathbf {x} _{i})-y_{i}&=\left[\sum _{j=1}^{n}c_{j}y_{j}\varphi (\mathbf {x} _{j})\cdot \varphi (\mathbf {x} _{i})\right]-y_{i}\\&=\left[\sum _{j=1}^{n}c_{j}y_{j}k(\mathbf {x} _{j},\mathbf {x} _{i})\right]-y_{i}.\end{aligned}}}
  

Finally,


  
    
      
        
          z
        
        â¦
        sgn
        â¡
        (
        
          
            w
          
          
            T
          
        
        Ï
        (
        
          z
        
        )
        â
        b
        )
        =
        sgn
        â¡
        
          (
          
            
              [
              
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  c
                  
                    i
                  
                
                
                  y
                  
                    i
                  
                
                k
                (
                
                  
                    x
                  
                  
                    i
                  
                
                ,
                
                  z
                
                )
              
              ]
            
            â
            b
          
          )
        
        .
      
    
    {\displaystyle \mathbf {z} \mapsto \operatorname {sgn}(\mathbf {w} ^{T}\varphi (\mathbf {z} )-b)=\operatorname {sgn} \left(\left[\sum _{i=1}^{n}c_{i}y_{i}k(\mathbf {x} _{i},\mathbf {z} )\right]-b\right).}
  

Modern methods[edit]
Recent algorithms for finding the SVM classifier include sub-gradient descent and coordinate descent. Both techniques have proven to offer significant advantages over the traditional approach when dealing with large, sparse datasetsâsub-gradient methods are especially efficient when there are many training examples, and coordinate descent when the dimension of the feature space is high.

Sub-gradient descent[edit]
Sub-gradient descent algorithms for the SVM work directly with the expression


  
    
      
        f
        (
        
          w
        
        ,
        b
        )
        =
        
          [
          
            
              
                1
                n
              
            
            
              â
              
                i
                =
                1
              
              
                n
              
            
            max
            
              (
              
                0
                ,
                1
                â
                
                  y
                  
                    i
                  
                
                (
                
                  
                    w
                  
                  
                    T
                  
                
                
                  
                    x
                  
                  
                    i
                  
                
                â
                b
                )
              
              )
            
          
          ]
        
        +
        Î»
        â
        
          w
        
        
          â
          
            2
          
        
        .
      
    
    {\displaystyle f(\mathbf {w} ,b)=\left[{\frac {1}{n}}\sum _{i=1}^{n}\max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} _{i}-b)\right)\right]+\lambda \|\mathbf {w} \|^{2}.}
  

Note that 
  
    
      
        f
      
    
    {\displaystyle f}
  
 is a convex function of 
  
    
      
        
          w
        
      
    
    {\displaystyle \mathbf {w} }
  
 and 
  
    
      
        b
      
    
    {\displaystyle b}
  
. As such, traditional gradient descent (or SGD) methods can be adapted, where instead of taking a step in the direction of the function's gradient, a step is taken in the direction of a vector selected from the function's sub-gradient. This approach has the advantage that, for certain implementations, the number of iterations does not scale with 
  
    
      
        n
      
    
    {\displaystyle n}
  
, the number of data points.[21]

Coordinate descent[edit]
Coordinate descent algorithms for the SVM work from the dual problem


  
    
      
        
          maximize
        
        
        
        f
        (
        
          c
          
            1
          
        
        â¦
        
          c
          
            n
          
        
        )
        =
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        â
        
          
            1
            2
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          â
          
            j
            =
            1
          
          
            n
          
        
        
          y
          
            i
          
        
        
          c
          
            i
          
        
        (
        
          x
          
            i
          
        
        â
        
          x
          
            j
          
        
        )
        
          y
          
            j
          
        
        
          c
          
            j
          
        
        ,
      
    
    {\displaystyle {\text{maximize}}\,\,f(c_{1}\ldots c_{n})=\sum _{i=1}^{n}c_{i}-{\frac {1}{2}}\sum _{i=1}^{n}\sum _{j=1}^{n}y_{i}c_{i}(x_{i}\cdot x_{j})y_{j}c_{j},}
  


  
    
      
        
          subject toÂ 
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          c
          
            i
          
        
        
          y
          
            i
          
        
        =
        0
        ,
        
        
          andÂ 
        
        0
        â¤
        
          c
          
            i
          
        
        â¤
        
          
            1
            
              2
              n
              Î»
            
          
        
        
        
          for allÂ 
        
        i
        .
      
    
    {\displaystyle {\text{subject to }}\sum _{i=1}^{n}c_{i}y_{i}=0,\,{\text{and }}0\leq c_{i}\leq {\frac {1}{2n\lambda }}\;{\text{for all }}i.}
  

For each 
  
    
      
        i
        â
        {
        1
        ,
        
        â¦
        ,
        
        n
        }
      
    
    {\displaystyle i\in \{1,\,\ldots ,\,n\}}
  
, iteratively, the coefficient 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 is adjusted in the direction of 
  
    
      
        â
        f
        
          /
        
        â
        
          c
          
            i
          
        
      
    
    {\displaystyle \partial f/\partial c_{i}}
  
. Then, the resulting vector of coefficients 
  
    
      
        (
        
          c
          
            1
          
          â²
        
        ,
        
        â¦
        ,
        
        
          c
          
            n
          
          â²
        
        )
      
    
    {\displaystyle (c_{1}',\,\ldots ,\,c_{n}')}
  
 is projected onto the nearest vector of coefficients that satisfies the given constraints. (Typically Euclidean distances are used.) The process is then repeated until a near-optimal vector of coefficients is obtained. The resulting algorithm is extremely fast in practice, although few performance guarantees have been proven.[22]

Empirical risk minimization[edit]
The soft-margin support vector machine described above is an example of an empirical risk minimization (ERM) algorithm for the hinge loss. Seen this way, support vector machines belong to a natural class of algorithms for statistical inference, and many of its unique features are due to the behavior of the hinge loss. This perspective can provide further insight into how and why SVMs work, and allow us to better analyze their statistical properties.

Risk minimization[edit]
In supervised learning, one is given a set of training examples 
  
    
      
        
          X
          
            1
          
        
        â¦
        
          X
          
            n
          
        
      
    
    {\displaystyle X_{1}\ldots X_{n}}
  
 with labels 
  
    
      
        
          y
          
            1
          
        
        â¦
        
          y
          
            n
          
        
      
    
    {\displaystyle y_{1}\ldots y_{n}}
  
, and wishes to predict 
  
    
      
        
          y
          
            n
            +
            1
          
        
      
    
    {\displaystyle y_{n+1}}
  
 given 
  
    
      
        
          X
          
            n
            +
            1
          
        
      
    
    {\displaystyle X_{n+1}}
  
. To do so one forms a hypothesis, 
  
    
      
        f
      
    
    {\displaystyle f}
  
, such that 
  
    
      
        f
        (
        
          X
          
            n
            +
            1
          
        
        )
      
    
    {\displaystyle f(X_{n+1})}
  
 is a "good" approximation of 
  
    
      
        
          y
          
            n
            +
            1
          
        
      
    
    {\displaystyle y_{n+1}}
  
. A "good" approximation is usually defined with the help of a loss function, 
  
    
      
        â
        (
        y
        ,
        z
        )
      
    
    {\displaystyle \ell (y,z)}
  
, which characterizes how bad 
  
    
      
        z
      
    
    {\displaystyle z}
  
 is as a prediction of 
  
    
      
        y
      
    
    {\displaystyle y}
  
. We would then like to choose a hypothesis that minimizes the expected risk:


  
    
      
        Îµ
        (
        f
        )
        =
        
          E
        
        
          [
          
            â
            (
            
              y
              
                n
                +
                1
              
            
            ,
            f
            (
            
              X
              
                n
                +
                1
              
            
            )
            )
          
          ]
        
        .
      
    
    {\displaystyle \varepsilon (f)=\mathbb {E} \left[\ell (y_{n+1},f(X_{n+1}))\right].}
  

In most cases, we don't know the joint distribution of 
  
    
      
        
          X
          
            n
            +
            1
          
        
        ,
        
        
          y
          
            n
            +
            1
          
        
      
    
    {\displaystyle X_{n+1},\,y_{n+1}}
  
 outright. In these cases, a common strategy is to choose the hypothesis that minimizes the empirical risk:


  
    
      
        
          
            
              Îµ
              ^
            
          
        
        (
        f
        )
        =
        
          
            1
            n
          
        
        
          â
          
            k
            =
            1
          
          
            n
          
        
        â
        (
        
          y
          
            k
          
        
        ,
        f
        (
        
          X
          
            k
          
        
        )
        )
        .
      
    
    {\displaystyle {\hat {\varepsilon }}(f)={\frac {1}{n}}\sum _{k=1}^{n}\ell (y_{k},f(X_{k})).}
  

Under certain assumptions about the sequence of random variables 
  
    
      
        
          X
          
            k
          
        
        ,
        
        
          y
          
            k
          
        
      
    
    {\displaystyle X_{k},\,y_{k}}
  
 (for example, that they are generated by a finite Markov process), if the set of hypotheses being considered is small enough, the minimizer of the empirical risk will closely approximate the minimizer of the expected risk as 
  
    
      
        n
      
    
    {\displaystyle n}
  
 grows large. This approach is called empirical risk minimization, or ERM.

Regularization and stability[edit]
In order for the minimization problem to have a well-defined solution, we have to place constraints on the set 
  
    
      
        
          
            H
          
        
      
    
    {\displaystyle {\mathcal {H}}}
  
 of hypotheses being considered. If 
  
    
      
        
          
            H
          
        
      
    
    {\displaystyle {\mathcal {H}}}
  
 is a normed space (as is the case for SVM), a particularly effective technique is to consider only those hypotheses 
  
    
      
        f
      
    
    {\displaystyle f}
  
 for which 
  
    
      
        â
        f
        
          â
          
            
              H
            
          
        
        <
        k
      
    
    {\displaystyle \lVert f\rVert _{\mathcal {H}}<k}
  
 . This is equivalent to imposing a regularization penalty 
  
    
      
        
          
            R
          
        
        (
        f
        )
        =
        
          Î»
          
            k
          
        
        â
        f
        
          â
          
            
              H
            
          
        
      
    
    {\displaystyle {\mathcal {R}}(f)=\lambda _{k}\lVert f\rVert _{\mathcal {H}}}
  
, and solving the new optimization problem


  
    
      
        
          
            
              f
              ^
            
          
        
        =
        
          a
          r
          g
        
        
          min
          
            f
            â
            
              
                H
              
            
          
        
        
          
            
              Îµ
              ^
            
          
        
        (
        f
        )
        +
        
          
            R
          
        
        (
        f
        )
        .
      
    
    {\displaystyle {\hat {f}}=\mathrm {arg} \min _{f\in {\mathcal {H}}}{\hat {\varepsilon }}(f)+{\mathcal {R}}(f).}
  

This approach is called Tikhonov regularization.
More generally, 
  
    
      
        
          
            R
          
        
        (
        f
        )
      
    
    {\displaystyle {\mathcal {R}}(f)}
  
 can be some measure of the complexity of the hypothesis 
  
    
      
        f
      
    
    {\displaystyle f}
  
, so that simpler hypotheses are preferred.

SVM and the hinge loss[edit]
Recall that the (soft-margin) SVM classifier 
  
    
      
        
          
            
              
                w
              
              ^
            
          
        
        ,
        b
        :
        
          x
        
        â¦
        sgn
        â¡
        (
        
          
            
              
                
                  w
                
                ^
              
            
          
          
            T
          
        
        
          x
        
        â
        b
        )
      
    
    {\displaystyle {\hat {\mathbf {w} }},b:\mathbf {x} \mapsto \operatorname {sgn}({\hat {\mathbf {w} }}^{T}\mathbf {x} -b)}
  
 is chosen to minimize the following expression:


  
    
      
        
          [
          
            
              
                1
                n
              
            
            
              â
              
                i
                =
                1
              
              
                n
              
            
            max
            
              (
              
                0
                ,
                1
                â
                
                  y
                  
                    i
                  
                
                (
                
                  
                    w
                  
                  
                    T
                  
                
                
                  x
                
                â
                b
                )
              
              )
            
          
          ]
        
        +
        Î»
        â
        
          w
        
        
          â
          
            2
          
        
        .
      
    
    {\displaystyle \left[{\frac {1}{n}}\sum _{i=1}^{n}\max \left(0,1-y_{i}(\mathbf {w} ^{T}\mathbf {x} -b)\right)\right]+\lambda \|\mathbf {w} \|^{2}.}
  

In light of the above discussion, we see that the SVM technique is equivalent to empirical risk minimization with Tikhonov regularization, where in this case the loss function is the hinge loss


  
    
      
        â
        (
        y
        ,
        z
        )
        =
        max
        
          (
          
            0
            ,
            1
            â
            y
            z
          
          )
        
        .
      
    
    {\displaystyle \ell (y,z)=\max \left(0,1-yz\right).}
  

From this perspective, SVM is closely related to other fundamental classification algorithms such as regularized least-squares and logistic regression. The difference between the three lies in the choice of loss function: regularized least-squares amounts to empirical risk minimization with the square-loss,  
  
    
      
        
          â
          
            s
            q
          
        
        (
        y
        ,
        z
        )
        =
        (
        y
        â
        z
        
          )
          
            2
          
        
      
    
    {\displaystyle \ell _{sq}(y,z)=(y-z)^{2}}
  
; logistic regression employs the log-loss,


  
    
      
        
          â
          
            log
          
        
        (
        y
        ,
        z
        )
        =
        ln
        â¡
        (
        1
        +
        
          e
          
            â
            y
            z
          
        
        )
        .
      
    
    {\displaystyle \ell _{\log }(y,z)=\ln(1+e^{-yz}).}
  

Target functions[edit]
The difference between the hinge loss and these other loss functions is best stated in terms of target functions - the function that minimizes expected risk for a given pair of random variables 
  
    
      
        X
        ,
        
        y
      
    
    {\displaystyle X,\,y}
  
.
In particular, let 
  
    
      
        
          y
          
            x
          
        
      
    
    {\displaystyle y_{x}}
  
 denote 
  
    
      
        y
      
    
    {\displaystyle y}
  
 conditional on the event that 
  
    
      
        X
        =
        x
      
    
    {\displaystyle X=x}
  
.  In the classification setting, we have:


  
    
      
        
          y
          
            x
          
        
        =
        
          
            {
            
              
                
                  1
                
                
                  
                    with probabilityÂ 
                  
                  
                    p
                    
                      x
                    
                  
                
              
              
                
                  â
                  1
                
                
                  
                    with probabilityÂ 
                  
                  1
                  â
                  
                    p
                    
                      x
                    
                  
                
              
            
            
          
        
      
    
    {\displaystyle y_{x}={\begin{cases}1&{\text{with probability }}p_{x}\\-1&{\text{with probability }}1-p_{x}\end{cases}}}
  

The optimal classifier is therefore:


  
    
      
        
          f
          
            â
          
        
        (
        x
        )
        =
        
          
            {
            
              
                
                  1
                
                
                  
                    ifÂ 
                  
                  
                    p
                    
                      x
                    
                  
                  â¥
                  1
                  
                    /
                  
                  2
                
              
              
                
                  â
                  1
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
    {\displaystyle f^{*}(x)={\begin{cases}1&{\text{if }}p_{x}\geq 1/2\\-1&{\text{otherwise}}\end{cases}}}
  

For the square-loss, the target function is the conditional expectation function, 
  
    
      
        
          f
          
            s
            q
          
        
        (
        x
        )
        =
        
          E
        
        
          [
          
            y
            
              x
            
          
          ]
        
      
    
    {\displaystyle f_{sq}(x)=\mathbb {E} \left[y_{x}\right]}
  
; For the logistic loss, it's the logit function, 
  
    
      
        
          f
          
            log
          
        
        (
        x
        )
        =
        ln
        â¡
        
          (
          
            
              p
              
                x
              
            
            
              /
            
            (
            
              1
              â
              
                p
                
                  x
                
              
            
            )
          
          )
        
      
    
    {\displaystyle f_{\log }(x)=\ln \left(p_{x}/({1-p_{x}})\right)}
  
. While both of these target functions yield the correct classifier, as 
  
    
      
        sgn
        â¡
        (
        
          f
          
            s
            q
          
        
        )
        =
        sgn
        â¡
        (
        
          f
          
            log
          
        
        )
        =
        
          f
          
            â
          
        
      
    
    {\displaystyle \operatorname {sgn}(f_{sq})=\operatorname {sgn}(f_{\log })=f^{*}}
  
, they give us more information than we need. In fact, they give us enough information to completely describe the distribution of 
  
    
      
        
          y
          
            x
          
        
      
    
    {\displaystyle y_{x}}
  
.
On the other hand, one can check that the target function for the hinge loss is exactly 
  
    
      
        
          f
          
            â
          
        
      
    
    {\displaystyle f^{*}}
  
. Thus, in a sufficiently rich hypothesis spaceâor equivalently, for an appropriately chosen kernelâthe SVM classifier will converge to the simplest function (in terms of 
  
    
      
        
          
            R
          
        
      
    
    {\displaystyle {\mathcal {R}}}
  
) that correctly classifies the data. This extends the geometric interpretation of SVMâfor linear classification, the empirical risk is minimized by any function whose margins lie between the support vectors, and the simplest of these is the max-margin classifier.[23]

Properties[edit]
SVMs belong to a family of generalized linear classifiers and can be interpreted as an extension of the perceptron. They can also be considered a special case of Tikhonov regularization. A special property is that they simultaneously minimize the empirical classification error and maximize the geometric margin; hence they are also known as maximum margin classifiers.
A comparison of the SVM to other classifiers has been made by Meyer, Leisch and Hornik.[24]

Parameter selection[edit]
The effectiveness of SVM depends on the selection of kernel, the kernel's parameters, and soft margin parameter 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
.
A common choice is a Gaussian kernel, which has a single parameter 
  
    
      
        Î³
      
    
    {\displaystyle \gamma }
  
. The best combination of 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 and 
  
    
      
        Î³
      
    
    {\displaystyle \gamma }
  
 is often selected by a grid search with exponentially growing sequences of 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 and 
  
    
      
        Î³
      
    
    {\displaystyle \gamma }
  
, for example, 
  
    
      
        Î»
        â
        {
        
          2
          
            â
            5
          
        
        ,
        
          2
          
            â
            3
          
        
        ,
        â¦
        ,
        
          2
          
            13
          
        
        ,
        
          2
          
            15
          
        
        }
      
    
    {\displaystyle \lambda \in \{2^{-5},2^{-3},\dots ,2^{13},2^{15}\}}
  
; 
  
    
      
        Î³
        â
        {
        
          2
          
            â
            15
          
        
        ,
        
          2
          
            â
            13
          
        
        ,
        â¦
        ,
        
          2
          
            1
          
        
        ,
        
          2
          
            3
          
        
        }
      
    
    {\displaystyle \gamma \in \{2^{-15},2^{-13},\dots ,2^{1},2^{3}\}}
  
. Typically, each combination of parameter choices is checked using cross validation, and the parameters with best cross-validation accuracy are picked. Alternatively, recent work in Bayesian optimization can be used to select 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
 and 
  
    
      
        Î³
      
    
    {\displaystyle \gamma }
  
 , often requiring the evaluation of far fewer parameter combinations than grid search. The final model, which is used for testing and for classifying new data, is then trained on the whole training set using the selected parameters.[25]

Issues[edit]
Potential drawbacks of the SVM include the following aspects:

Requires full labeling of input data
Uncalibrated class membership probabilitiesâSVM stems from Vapnik's theory which avoids estimating probabilities on finite data
The SVM is only directly applicable for two-class tasks. Therefore, algorithms that reduce the multi-class task to several binary problems have to be applied; see the multi-class SVM section.
Parameters of a solved model are difficult to interpret.
Extensions[edit]
Support-vector clustering (SVC)[edit]
SVC is a similar method that also builds on kernel functions but is appropriate for unsupervised learning.[citation needed]

Multiclass SVM[edit]
Multiclass SVM aims to assign labels to instances by using support-vector machines, where the labels are drawn from a finite set of several elements.
The dominant approach for doing so is to reduce the single multiclass problem into multiple binary classification problems.[26] Common methods for such reduction include:[26][27]

Building binary classifiers that distinguish between one of the labels and the rest (one-versus-all) or between every pair of classes (one-versus-one). Classification of new instances for the one-versus-all case is done by a winner-takes-all strategy, in which the classifier with the highest-output function assigns the class (it is important that the output functions be calibrated to produce comparable scores). For the one-versus-one approach, classification is done by a max-wins voting strategy, in which every classifier assigns the instance to one of the two classes, then the vote for the assigned class is increased by one vote, and finally the class with the most votes determines the instance classification.
Directed acyclic graph SVM (DAGSVM)[28]
Error-correcting output codes[29]
Crammer and Singer proposed a multiclass SVM method which casts the multiclass classification problem into a single optimization problem, rather than decomposing it into multiple binary classification problems.[30] See also Lee, Lin and Wahba[31][32] and Van den Burg and Groenen.[33]

Transductive support-vector machines[edit]
Transductive support-vector machines extend SVMs in that they could also treat partially labeled data in semi-supervised learning by following the principles of transduction. Here, in addition to the training set 
  
    
      
        
          
            D
          
        
      
    
    {\displaystyle {\mathcal {D}}}
  
, the learner is also given a set


  
    
      
        
          
            
              D
            
          
          
            â
          
        
        =
        {
        
          
            
              
                x
                â
              
            
          
          
            i
          
          
            â
          
        
        â£
        
          
            
              
                x
                â
              
            
          
          
            i
          
          
            â
          
        
        â
        
          
            R
          
          
            p
          
        
        
          }
          
            i
            =
            1
          
          
            k
          
        
      
    
    {\displaystyle {\mathcal {D}}^{\star }=\{{\vec {x}}_{i}^{\star }\mid {\vec {x}}_{i}^{\star }\in \mathbb {R} ^{p}\}_{i=1}^{k}}
  

of test examples to be classified. Formally, a transductive support-vector machine is defined by the following primal optimization problem:[34]
Minimize (in 
  
    
      
        
          
            
              
                w
                â
              
            
          
          ,
          b
          ,
          
            
              
                
                  y
                  
                    â
                  
                
                â
              
            
          
        
      
    
    {\displaystyle {{\vec {w}},b,{\vec {y^{\star }}}}}
  
)


  
    
      
        
          
            1
            2
          
        
        â
        
          
            
              w
              â
            
          
        
        
          â
          
            2
          
        
      
    
    {\displaystyle {\frac {1}{2}}\|{\vec {w}}\|^{2}}
  

subject to (for any 
  
    
      
        i
        =
        1
        ,
        â¦
        ,
        n
      
    
    {\displaystyle i=1,\dots ,n}
  
 and any 
  
    
      
        j
        =
        1
        ,
        â¦
        ,
        k
      
    
    {\displaystyle j=1,\dots ,k}
  
)


  
    
      
        
          y
          
            i
          
        
        (
        
          
            
              w
              â
            
          
        
        â
        
          
            
              
                x
                
                  i
                
              
              â
            
          
        
        â
        b
        )
        â¥
        1
        ,
      
    
    {\displaystyle y_{i}({\vec {w}}\cdot {\vec {x_{i}}}-b)\geq 1,}
  


  
    
      
        
          y
          
            j
          
          
            â
          
        
        (
        
          
            
              w
              â
            
          
        
        â
        
          
            
              
                x
                
                  j
                
                
                  â
                
              
              â
            
          
        
        â
        b
        )
        â¥
        1
        ,
      
    
    {\displaystyle y_{j}^{\star }({\vec {w}}\cdot {\vec {x_{j}^{\star }}}-b)\geq 1,}
  

and


  
    
      
        
          y
          
            j
          
          
            â
          
        
        â
        {
        â
        1
        ,
        1
        }
        .
      
    
    {\displaystyle y_{j}^{\star }\in \{-1,1\}.}
  

Transductive support-vector machines were introduced by Vladimir N. Vapnik in 1998.

Structured SVM[edit]
SVMs have been generalized to structured SVMs, where the label space is structured and of possibly infinite size.

Regression[edit]
  Support-vector regression (prediction) with different thresholds Îµ. As Îµ increases, the prediction becomes less sensitive to errors.
A version of SVM for regression was proposed in 1996 by Vladimir N. Vapnik, Harris Drucker, Christopher J. C. Burges, Linda Kaufman and Alexander J. Smola.[35] This method is called support-vector regression (SVR). The model produced by support-vector classification (as described above) depends only on a subset of the training data, because the cost function for building the model does not care about training points that lie beyond the margin. Analogously, the model produced by SVR depends only on a subset of the training data, because the cost function for building the model ignores any training data close to the model prediction. Another SVM version known as least-squares support-vector machine (LS-SVM) has been proposed by Suykens and Vandewalle.[36]
Training the original SVR means solving[37]

minimize 
  
    
      
        
          
            1
            2
          
        
        â
        w
        
          â
          
            2
          
        
      
    
    {\displaystyle {\frac {1}{2}}\|w\|^{2}}
  

subject to 
  
    
      
        
          |
        
        
          y
          
            i
          
        
        â
        â¨
        w
        ,
        
          x
          
            i
          
        
        â©
        â
        b
        
          |
        
        â¤
        Îµ
      
    
    {\displaystyle |y_{i}-\langle w,x_{i}\rangle -b|\leq \varepsilon }
  

where 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 is a training sample with target value 
  
    
      
        
          y
          
            i
          
        
      
    
    {\displaystyle y_{i}}
  
. The inner product plus intercept 
  
    
      
        â¨
        w
        ,
        
          x
          
            i
          
        
        â©
        +
        b
      
    
    {\displaystyle \langle w,x_{i}\rangle +b}
  
 is the prediction for that sample, and 
  
    
      
        Îµ
      
    
    {\displaystyle \varepsilon }
  
 is a free parameter that serves as a threshold: all predictions have to be within an 
  
    
      
        Îµ
      
    
    {\displaystyle \varepsilon }
  
 range of the true predictions. Slack variables are usually added into the above to allow for errors and to allow approximation in the case the above problem is infeasible.

Bayesian SVM[edit]
In 2011 it was shown by Polson and Scott that the SVM admits a Bayesian interpretation through the technique of data augmentation.[38] In this approach the SVM is viewed as a graphical model (where the parameters are connected via probability distributions). This extended view allows the application of Bayesian techniques to SVMs, such as flexible feature modeling, automatic hyperparameter tuning, and predictive uncertainty quantification. Recently, a scalable version of the Bayesian SVM was developed by Florian Wenzel, enabling the application of Bayesian SVMs to big data.[39] Florian Wenzel developed two different versions, a variational inference (VI) scheme for the Bayesian kernel support vector machine (SVM) and a stochastic version (SVI) for the linear Bayesian SVM.[40]

Implementation[edit]
The parameters of the maximum-margin hyperplane are derived by solving the optimization. There exist several specialized algorithms for quickly solving the quadratic programming (QP) problem that arises from SVMs, mostly relying on heuristics for breaking the problem down into smaller, more manageable chunks.
Another approach is to use an interior-point method that uses Newton-like iterations to find a solution of the KarushâKuhnâTucker conditions of the primal and dual problems.[41]
Instead of solving a sequence of broken-down problems, this approach directly solves the problem altogether. To avoid solving a linear system involving the large kernel matrix, a low-rank approximation to the matrix is often used in the kernel trick.
Another common method is Platt's sequential minimal optimization (SMO) algorithm, which breaks the problem down into 2-dimensional sub-problems that are solved analytically, eliminating the need for a numerical optimization algorithm and matrix storage. This algorithm is conceptually simple, easy to implement, generally faster, and has better scaling properties for difficult SVM problems.[42]
The special case of linear support-vector machines can be solved more efficiently by the same kind of algorithms used to optimize its close cousin, logistic regression; this class of algorithms includes sub-gradient descent (e.g., PEGASOS[43]) and coordinate descent (e.g., LIBLINEAR[44]). LIBLINEAR has some attractive training-time properties. Each convergence iteration takes time linear in the time taken to read the train data, and the iterations also have a Q-linear convergence property, making the algorithm extremely fast.
The general kernel SVMs can also be solved more efficiently using sub-gradient descent (e.g. P-packSVM[45]), especially when parallelization is allowed.
Kernel SVMs are available in many machine-learning toolkits, including LIBSVM, MATLAB, SAS, SVMlight, kernlab, scikit-learn, Shogun, Weka, Shark, JKernelMachines, OpenCV and others.
Preprocessing of data (standardization) is highly recommended to enhance accuracy of classification.[46] There are a few methods of standardization, such as min-max, normalization by decimal scaling, Z-score.[47] Subtraction of mean and division by variance of each feature is usually used for SVM.[48]

See also[edit]
In situ adaptive tabulation
Kernel machines
Fisher kernel
Platt scaling
Polynomial kernel
Predictive analytics
Regularization perspectives on support-vector machines
Relevance vector machine, a probabilistic sparse-kernel model identical in functional form to SVM
Sequential minimal optimization
Space mapping
Winnow (algorithm)
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Cortes, Corinna; Vapnik, Vladimir N. (1995). "Support-vector networks" (PDF). Machine Learning. 20 (3): 273â297. CiteSeerXÂ 10.1.1.15.9362. doi:10.1007/BF00994018. S2CIDÂ 206787478.

^ Cortes, Corinna; Vladimir Vapnik (1995). "Support-Vector Networks". Machine Learning. 20 (3): 273â297. doi:10.1007/BF00994018.

^ Ben-Hur, Asa; Horn, David; Siegelmann, Hava; Vapnik, Vladimir N. ""Support vector clustering" (2001);". Journal of Machine Learning Research. 2: 125â137.

^ "1.4. Support Vector Machines â scikit-learn 0.20.2 documentation". Archived from the original on 2017-11-08. Retrieved 2017-11-08.

^ Hastie, Trevor; Tibshirani, Robert; Friedman, Jerome (2008). The Elements of Statistical LearningÂ : Data Mining, Inference, and Prediction (PDF) (SecondÂ ed.). New York: Springer. p.Â 134.

^ Jump up to: a b c Boser, Bernhard E.; Guyon, Isabelle M.; Vapnik, Vladimir N. (1992). "A training algorithm for optimal margin classifiers". Proceedings of the fifth annual workshop on Computational learning theory â COLT '92. p.Â 144. CiteSeerXÂ 10.1.1.21.3818. doi:10.1145/130385.130401. ISBNÂ 978-0897914970. S2CIDÂ 207165665.

^ Press, William H.; Teukolsky, Saul A.; Vetterling, William T.; Flannery, Brian P. (2007). "Section 16.5. Support Vector Machines". Numerical Recipes: The Art of Scientific Computing (3rdÂ ed.). New York: Cambridge University Press. ISBNÂ 978-0-521-88068-8. Archived from the original on 2011-08-11.

^ Joachims, Thorsten (1998). "Text categorization with Support Vector Machines: Learning with many relevant features". Machine Learning: ECML-98. Lecture Notes in Computer Science. Springer. 1398: 137â142. doi:10.1007/BFb0026683. ISBNÂ 978-3-540-64417-0.

^ Pradhan, Sameer S., et al. "Shallow semantic parsing using support vector machines." Proceedings of the Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics: HLT-NAACL 2004. 2004.

^ Vapnik, Vladimir N.: Invited Speaker. IPMU Information Processing and Management 2014).

^ Barghout, Lauren. "Spatial-Taxon Information Granules as Used in Iterative Fuzzy-Decision-Making for Image Segmentation". Granular Computing and Decision-Making. Springer International Publishing, 2015. 285â318.

^ A. Maity (2016). "Supervised Classification of RADARSAT-2 Polarimetric Data for Different Land Features". arXiv:1608.00501 [cs.CV].

^ DeCoste, Dennis (2002). "Training Invariant Support Vector Machines" (PDF). Machine Learning. 46: 161â190. doi:10.1023/A:1012454411458. S2CIDÂ 85843.

^ Maitra, D. S.; Bhattacharya, U.; Parui, S. K. (August 2015). "CNN based common approach to handwritten character recognition of multiple scripts". 2015 13th International Conference on Document Analysis and Recognition (ICDAR): 1021â1025. doi:10.1109/ICDAR.2015.7333916. ISBNÂ 978-1-4799-1805-8. S2CIDÂ 25739012.

^ Gaonkar, Bilwaj; Davatzikos, Christos; "Analytic estimation of statistical significance maps for support vector machine based multi-variate image analysis and classification".

^ Cuingnet, RÃ©mi; Rosso, Charlotte; Chupin, Marie; LehÃ©ricy, StÃ©phane; Dormont, Didier; Benali, Habib; Samson, Yves; and Colliot, Olivier; "Spatial regularization of SVM for the detection of diffusion alterations associated with stroke outcome", Medical Image Analysis, 2011, 15 (5): 729â737.

^ Statnikov, Alexander; Hardin, Douglas; & Aliferis, Constantin; (2006); "Using SVM weight-based methods to identify causally relevant and non-causally relevant variables", Sign, 1, 4.

^ "Why is the SVM margin equal to 
  
    
      
        
          
            2
            
              â
              
                w
              
              â
            
          
        
      
    
    {\displaystyle {\frac {2}{\|\mathbf {w} \|}}}
  
". Mathematics Stack Exchange. 30 May 2015.

^ Aizerman, Mark A.; Braverman, Emmanuel M. & Rozonoer, Lev I. (1964). "Theoretical foundations of the potential function method in pattern recognition learning". Automation and Remote Control. 25: 821â837.

^ Jin, Chi; Wang, Liwei (2012). Dimensionality dependent PAC-Bayes margin bound. Advances in Neural Information Processing Systems. CiteSeerXÂ 10.1.1.420.3487. Archived from the original on 2015-04-02.

^ Shalev-Shwartz, Shai; Singer, Yoram; Srebro, Nathan; Cotter, Andrew (2010-10-16). "Pegasos: primal estimated sub-gradient solver for SVM". Mathematical Programming. 127 (1): 3â30. CiteSeerXÂ 10.1.1.161.9629. doi:10.1007/s10107-010-0420-4. ISSNÂ 0025-5610. S2CIDÂ 53306004.

^ Hsieh, Cho-Jui; Chang, Kai-Wei; Lin, Chih-Jen; Keerthi, S. Sathiya; Sundararajan, S. (2008-01-01). A Dual Coordinate Descent Method for Large-scale Linear SVM. Proceedings of the 25th International Conference on Machine Learning. ICML '08. New York, NY, USA: ACM. pp.Â 408â415. CiteSeerXÂ 10.1.1.149.5594. doi:10.1145/1390156.1390208. ISBNÂ 978-1-60558-205-4. S2CIDÂ 7880266.

^ Rosasco, Lorenzo; De Vito, Ernesto; Caponnetto, Andrea; Piana, Michele; Verri, Alessandro (2004-05-01). "Are Loss Functions All the Same?". Neural Computation. 16 (5): 1063â1076. CiteSeerXÂ 10.1.1.109.6786. doi:10.1162/089976604773135104. ISSNÂ 0899-7667. PMIDÂ 15070510. S2CIDÂ 11845688.

^ Meyer, David; Leisch, Friedrich; Hornik, Kurt (September 2003). "The support vector machine under test". Neurocomputing. 55 (1â2): 169â186. doi:10.1016/S0925-2312(03)00431-4.

^ Hsu, Chih-Wei; Chang, Chih-Chung & Lin, Chih-Jen (2003). A Practical Guide to Support Vector Classification (PDF) (Technical report). Department of Computer Science and Information Engineering, National Taiwan University. Archived (PDF) from the original on 2013-06-25.

^ Jump up to: a b Duan, Kai-Bo; Keerthi, S. Sathiya (2005). "Which Is the Best Multiclass SVM Method? An Empirical Study" (PDF). Multiple Classifier Systems. LNCS. Vol.Â 3541. pp.Â 278â285. CiteSeerXÂ 10.1.1.110.6789. doi:10.1007/11494683_28. ISBNÂ 978-3-540-26306-7.

^ Hsu, Chih-Wei & Lin, Chih-Jen (2002). "A Comparison of Methods for Multiclass Support Vector Machines" (PDF). IEEE Transactions on Neural Networks. 13 (2): 415â25. doi:10.1109/72.991427. PMIDÂ 18244442.

^ Platt, John; Cristianini, Nello; Shawe-Taylor, John (2000). "Large margin DAGs for multiclass classification" (PDF).  In Solla, Sara A.; Leen, Todd K.; MÃ¼ller, Klaus-Robert (eds.). Advances in Neural Information Processing Systems. MIT Press. pp.Â 547â553. Archived (PDF) from the original on 2012-06-16.

^ Dietterich, Thomas G.; Bakiri, Ghulum (1995). "Solving Multiclass Learning Problems via Error-Correcting Output Codes" (PDF). Journal of Artificial Intelligence Research. 2: 263â286. arXiv:cs/9501101. Bibcode:1995cs........1101D. doi:10.1613/jair.105. S2CIDÂ 47109072. Archived (PDF) from the original on 2013-05-09.

^ Crammer, Koby & Singer, Yoram (2001). "On the Algorithmic Implementation of Multiclass Kernel-based Vector Machines" (PDF). Journal of Machine Learning Research. 2: 265â292. Archived (PDF) from the original on 2015-08-29.

^ Lee, Yoonkyung; Lin, Yi & Wahba, Grace (2001). "Multicategory Support Vector Machines" (PDF). Computing Science and Statistics. 33. Archived (PDF) from the original on 2013-06-17.

^ Lee, Yoonkyung; Lin, Yi; Wahba, Grace (2004). "Multicategory Support Vector Machines". Journal of the American Statistical Association. 99 (465): 67â81. CiteSeerXÂ 10.1.1.22.1879. doi:10.1198/016214504000000098. S2CIDÂ 7066611.

^ Van den Burg, Gerrit J. J. & Groenen, Patrick J. F. (2016). "GenSVM: A Generalized Multiclass Support Vector Machine" (PDF). Journal of Machine Learning Research. 17 (224): 1â42.

^ Joachims, Thorsten; "Transductive Inference for Text Classification using Support Vector Machines", Proceedings of the 1999 International Conference on Machine Learning (ICML 1999), pp. 200â209.

^ Drucker, Harris; Burges, Christ. C.; Kaufman, Linda; Smola, Alexander J.; and Vapnik, Vladimir N. (1997); "Support Vector Regression Machines", in Advances in Neural Information Processing Systems 9, NIPS 1996, 155â161, MIT Press.

^ Suykens, Johan A. K.; Vandewalle, Joos P. L.; "Least squares support vector machine classifiers", Neural Processing Letters, vol. 9, no. 3, Jun. 1999, pp. 293â300.

^ Smola, Alex J.; SchÃ¶lkopf, Bernhard (2004). "A tutorial on support vector regression" (PDF). Statistics and Computing. 14 (3): 199â222. CiteSeerXÂ 10.1.1.41.1452. doi:10.1023/B:STCO.0000035301.49549.88. S2CIDÂ 15475. Archived (PDF) from the original on 2012-01-31.

^ Polson, Nicholas G.; Scott, Steven L. (2011). "Data Augmentation for Support Vector Machines". Bayesian Analysis. 6 (1): 1â23. doi:10.1214/11-BA601.

^ Wenzel, Florian; Galy-Fajou, Theo; Deutsch, MatthÃ¤us; Kloft, Marius (2017). "Bayesian Nonlinear Support Vector Machines for Big Data". Machine Learning and Knowledge Discovery in Databases (ECML PKDD). Lecture Notes in Computer Science. 10534: 307â322. arXiv:1707.05532. Bibcode:2017arXiv170705532W. doi:10.1007/978-3-319-71249-9_19. ISBNÂ 978-3-319-71248-2. S2CIDÂ 4018290.

^ Florian Wenzel; MatthÃ¤us Deutsch; ThÃ©o Galy-Fajou; Marius Kloft; âScalable Approximate Inference for the Bayesian Nonlinear Support Vector Machineâ

^ Ferris, Michael C.; Munson, Todd S. (2002). "Interior-Point Methods for Massive Support Vector Machines" (PDF). SIAM Journal on Optimization. 13 (3): 783â804. CiteSeerXÂ 10.1.1.216.6893. doi:10.1137/S1052623400374379. Archived (PDF) from the original on 2008-12-04.

^ Platt, John C. (1998). Sequential Minimal Optimization: A Fast Algorithm for Training Support Vector Machines (PDF). NIPS. Archived (PDF) from the original on 2015-07-02.

^ Shalev-Shwartz, Shai; Singer, Yoram; Srebro, Nathan (2007). Pegasos: Primal Estimated sub-GrAdient SOlver for SVM (PDF). ICML. Archived (PDF) from the original on 2013-12-15.

^ Fan, Rong-En; Chang, Kai-Wei; Hsieh, Cho-Jui; Wang, Xiang-Rui; Lin, Chih-Jen (2008). "LIBLINEAR: A library for large linear classification" (PDF). Journal of Machine Learning Research. 9: 1871â1874.

^ Allen Zhu, Zeyuan; Chen, Weizhu; Wang, Gang; Zhu, Chenguang; Chen, Zheng (2009). P-packSVM: Parallel Primal grAdient desCent Kernel SVM (PDF). ICDM. Archived (PDF) from the original on 2014-04-07.

^  Fan, Rong-En; Chang, Kai-Wei; Hsieh, Cho-Jui; Wang, Xiang-Rui; Lin, Chih-Jen (2008). "LIBLINEAR: A library for large linear classification". Journal of Machine Learning Research. 9 (Aug): 1871â1874.

^ Mohamad, Ismail; Usman, Dauda (2013-09-01). "Standardization and Its Effects on K-Means Clustering Algorithm". Research Journal of Applied Sciences, Engineering and Technology. 6 (17): 3299â3303. doi:10.19026/rjaset.6.3638.

^ Fennell, Peter; Zuo, Zhiya; Lerman, Kristina (2019-12-01). "Predicting and explaining behavioral data with structured feature space decomposition". EPJ Data Science. 8. doi:10.1140/epjds/s13688-019-0201-0.


Further reading[edit]
Bennett, Kristin P.; Campbell, Colin (2000). "Support Vector Machines: Hype or Hallelujah?" (PDF). SIGKDD Explorations. 2 (2): 1â13. doi:10.1145/380995.380999. S2CIDÂ 207753020.
Cristianini, Nello; Shawe-Taylor, John (2000). An Introduction to Support Vector Machines and other kernel-based learning methods. Cambridge University Press. ISBNÂ 0-521-78019-5.
Fradkin, Dmitriy; Muchnik, Ilya (2006). "Support Vector Machines for Classification" (PDF).  In Abello, J.; Carmode, G. (eds.). Discrete Methods in Epidemiology. DIMACS Series in Discrete Mathematics and Theoretical Computer Science. Vol.Â 70. pp.Â 13â20.
Ivanciuc, Ovidiu (2007). "Applications of Support Vector Machines in Chemistry" (PDF). Reviews in Computational Chemistry. 23: 291â400. doi:10.1002/9780470116449.ch6. ISBNÂ 9780470116449.
James, Gareth; Witten, Daniela; Hastie, Trevor; Tibshirani, Robert (2013). "Support Vector Machines" (PDF). An Introduction to Statistical LearningÂ : with Applications in R. New York: Springer. pp.Â 337â372. ISBNÂ 978-1-4614-7137-0.
SchÃ¶lkopf, Bernhard; Smola, Alexander J. (2002). Learning with Kernels. Cambridge, MA: MIT Press. ISBNÂ 0-262-19475-9.
Steinwart, Ingo; Christmann, Andreas (2008). Support Vector Machines. New York: Springer. ISBNÂ 978-0-387-77241-7.
Theodoridis, Sergios; Koutroumbas, Konstantinos (2009). Pattern Recognition (4thÂ ed.). Academic Press. ISBNÂ 978-1-59749-272-0.
External links[edit]
libsvm, LIBSVM is a popular library of SVM learners
liblinear is a library for large linear classification including some SVMs
SVM light is a collection of software tools for learning and classification using SVM
SVMJS live demo is a GUI demo for JavaScript implementation of SVMs
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}showAuthority control General
Integrated Authority File (Germany)
National libraries
France (data)
United States





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Support-vector_machine&oldid=1064262971"
		Categories: Support vector machinesClassification algorithmsStatistical classificationHidden categories: Articles with short descriptionShort description matches WikidataAll articles with unsourced statementsArticles with unsourced statements from September 2021Articles with unsourced statements from March 2018Articles with unsourced statements from June 2013Articles with unsourced statements from March 2017Articles with GND identifiersArticles with BNF identifiersArticles with LCCN identifiers
	
