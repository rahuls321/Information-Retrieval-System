
Title:
Nondeterministic finite automaton
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		  NFA for (0|1)*Â 1Â (0|1)3.A DFA for that language has at least 16 states.
In automata theory, a finite-state machine is called a deterministic finite automaton (DFA), if

each of its transitions is uniquely determined by its source state and input symbol, and
reading an input symbol is required for each state transition.
A nondeterministic finite automaton (NFA), or nondeterministic finite-state machine, does not need to obey these restrictions. In particular, every DFA is also an NFA. Sometimes the term NFA is used in a narrower sense, referring to an NFA that is not a DFA, but not in this article.
Using the subset construction algorithm, each NFA can be translated to an equivalent DFA; i.e., a DFA recognizing the same formal language.[1]
Like DFAs, NFAs only recognize regular languages.
NFAs were introduced in 1959 by Michael O. Rabin and Dana Scott,[2]  who also showed their equivalence to DFAs. NFAs are used in the implementation of regular expressions: Thompson's construction is an algorithm for compiling a regular expression to an NFA that can efficiently perform pattern matching on strings. Conversely, Kleene's algorithm can be used to convert an NFA into a regular expression (whose size is generally exponential in the input automaton).
NFAs have been generalized in multiple ways, e.g., nondeterministic finite automata with Îµ-moves, finite-state transducers, pushdown automata, alternating automata, Ï-automata, and probabilistic automata.
Besides the DFAs, other known special cases of NFAs
are unambiguous finite automata (UFA)
and self-verifying finite automata (SVFA).

Contents

1 Informal introduction
2 Formal definition

2.1 Automaton
2.2 Recognized language
2.3 Initial state


3 Example
4 Equivalence to DFA
5 NFA with Îµ-moves

5.1 Formal definition
5.2 Îµ-closure of a state or set of states
5.3 Accepting states
5.4 Example
5.5 Equivalence to NFA


6 Closure properties
7 Properties
8 Implementation
9 Application of NFA
10 See also
11 Notes
12 References



Informal introduction[edit]
There are several informal explanations around, which are equivalent.

An NFA, similar to a DFA, consumes a string of input symbols. For each input symbol, it transitions to a new state until all input symbols have been consumed. In each step, the automaton arbitrarily chooses one of the applicable transitions. If there exists some "lucky run", i.e. some sequence of choices leading to an accepting state after completely consuming the input, it is accepted. Otherwise, i.e. if no choice sequence at all can consume all the input[3] and lead to an accepting state, the input is rejected.[4]:â19â[5]:â319â
Again, an NFA consumes a string of input symbols, one by one. In each step, whenever two or more transitions are applicable, it "clones" itself into appropriately many copies, each one following a different transition. If no transition is applicable, the current copy is in a dead end, and it "dies". If, after consuming the complete input, any of the copies is in an accept state, the input is accepted, else, it is rejected.[4]:â19â20â[6]:â48â[7]:â56â
Formal definition[edit]
For a more elementary introduction of the formal definition see automata theory.

Automaton[edit]
An NFA is represented formally by a 5-tuple,

  
    
      
        (
        Q
        ,
        Î£
        ,
        Î
        ,
        
          q
          
            0
          
        
        ,
        F
        )
      
    
    {\displaystyle (Q,\Sigma ,\Delta ,q_{0},F)}
  
, consisting of

a finite set of states 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
.
a finite set of input symbols 
  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
.
a transition function 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
Â : 
  
    
      
        Q
        Ã
        Î£
        â
        
          
            P
          
        
        (
        Q
        )
      
    
    {\displaystyle Q\times \Sigma \rightarrow {\mathcal {P}}(Q)}
  
.
an initial (or start) state 
  
    
      
        
          q
          
            0
          
        
        â
        Q
      
    
    {\displaystyle q_{0}\in Q}
  
.
a set of states 
  
    
      
        F
      
    
    {\displaystyle F}
  
 distinguished as accepting (or final) states 
  
    
      
        F
        â
        Q
      
    
    {\displaystyle F\subseteq Q}
  
.
Here, 
  
    
      
        
          
            P
          
        
        (
        Q
        )
      
    
    {\displaystyle {\mathcal {P}}(Q)}
  
 denotes the power set of 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
.

Recognized language[edit]
Given an NFA 
  
    
      
        M
        =
        (
        Q
        ,
        Î£
        ,
        Î
        ,
        
          q
          
            0
          
        
        ,
        F
        )
      
    
    {\displaystyle M=(Q,\Sigma ,\Delta ,q_{0},F)}
  
, its recognized language is denoted by 
  
    
      
        L
        (
        M
        )
      
    
    {\displaystyle L(M)}
  
, and is defined as set of all strings over the alphabet 
  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
 that are accepted by 
  
    
      
        M
      
    
    {\displaystyle M}
  
.
Loosely corresponding to the above informal explanations, there are several equivalent formal definitions of a string 
  
    
      
        w
        =
        
          a
          
            1
          
        
        
          a
          
            2
          
        
        .
        .
        .
        
          a
          
            n
          
        
      
    
    {\displaystyle w=a_{1}a_{2}...a_{n}}
  
 being accepted by 
  
    
      
        M
      
    
    {\displaystyle M}
  
:


  
    
      
        w
      
    
    {\displaystyle w}
  
 is accepted if a sequence of states, 
  
    
      
        
          r
          
            0
          
        
        ,
        
          r
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          r
          
            n
          
        
      
    
    {\displaystyle r_{0},r_{1},...,r_{n}}
  
, exists in 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
 such that:

  
    
      
        
          r
          
            0
          
        
        =
        
          q
          
            0
          
        
      
    
    {\displaystyle r_{0}=q_{0}}
  


  
    
      
        
          r
          
            i
            +
            1
          
        
        â
        Î
        (
        
          r
          
            i
          
        
        ,
        
          a
          
            i
            +
            1
          
        
        )
      
    
    {\displaystyle r_{i+1}\in \Delta (r_{i},a_{i+1})}
  
, for 
  
    
      
        i
        =
        0
        ,
        â¦
        ,
        n
        â
        1
      
    
    {\displaystyle i=0,\ldots ,n-1}
  


  
    
      
        
          r
          
            n
          
        
        â
        F
      
    
    {\displaystyle r_{n}\in F}
  
.
In words, the first condition says that the machine starts in the start state 
  
    
      
        
          q
          
            0
          
        
      
    
    {\displaystyle q_{0}}
  
. The second condition says that given each character of string 
  
    
      
        w
      
    
    {\displaystyle w}
  
, the machine will transition from state to state according to the transition function 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
. The last condition says that the machine accepts 
  
    
      
        w
      
    
    {\displaystyle w}
  
 if the last input of 
  
    
      
        w
      
    
    {\displaystyle w}
  
 causes the machine to halt in one of the accepting states. In order for 
  
    
      
        w
      
    
    {\displaystyle w}
  
 to be accepted by 
  
    
      
        M
      
    
    {\displaystyle M}
  
, it is not required that every state sequence ends in an accepting state, it is sufficient if one does. Otherwise, i.e. if it is impossible at all to get from 
  
    
      
        
          q
          
            0
          
        
      
    
    {\displaystyle q_{0}}
  
 to a state from 
  
    
      
        F
      
    
    {\displaystyle F}
  
 by following 
  
    
      
        w
      
    
    {\displaystyle w}
  
, it is said that the automaton rejects the string. The set of strings 
  
    
      
        M
      
    
    {\displaystyle M}
  
 accepts is the language recognized by 
  
    
      
        M
      
    
    {\displaystyle M}
  
 and this language is denoted by 
  
    
      
        L
        (
        M
        )
      
    
    {\displaystyle L(M)}
  
.[5]:â320â[6]:â54â
Alternatively, 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is accepted if 
  
    
      
        
          Î
          
            â
          
        
        (
        
          q
          
            0
          
        
        ,
        w
        )
        â©
        F
        â 
        â
      
    
    {\displaystyle \Delta ^{*}(q_{0},w)\cap F\not =\emptyset }
  
, where 
  
    
      
        
          Î
          
            â
          
        
        :
        Q
        Ã
        
          Î£
          
            â
          
        
        â
        
          
            P
          
        
        (
        Q
        )
      
    
    {\displaystyle \Delta ^{*}:Q\times \Sigma ^{*}\rightarrow {\mathcal {P}}(Q)}
  
 is defined recursively by:

  
    
      
        
          Î
          
            â
          
        
        (
        r
        ,
        Ïµ
        )
        =
        {
        r
        }
      
    
    {\displaystyle \Delta ^{*}(r,\epsilon )=\{r\}}
  
 where 
  
    
      
        Ïµ
      
    
    {\displaystyle \epsilon }
  
 is the empty string, and

  
    
      
        
          Î
          
            â
          
        
        (
        r
        ,
        x
        a
        )
        =
        
          â
          
            
              r
              â²
            
            â
            
              Î
              
                â
              
            
            (
            r
            ,
            x
            )
          
        
        Î
        (
        
          r
          â²
        
        ,
        a
        )
      
    
    {\displaystyle \Delta ^{*}(r,xa)=\bigcup _{r'\in \Delta ^{*}(r,x)}\Delta (r',a)}
  
 for all 
  
    
      
        x
        â
        
          Î£
          
            â
          
        
        ,
        a
        â
        Î£
      
    
    {\displaystyle x\in \Sigma ^{*},a\in \Sigma }
  
.
In words, 
  
    
      
        
          Î
          
            â
          
        
        (
        r
        ,
        x
        )
      
    
    {\displaystyle \Delta ^{*}(r,x)}
  
 is the set of all states reachable from state 
  
    
      
        r
      
    
    {\displaystyle r}
  
 by consuming the string 
  
    
      
        x
      
    
    {\displaystyle x}
  
. The string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 is accepted if some accepting state in 
  
    
      
        F
      
    
    {\displaystyle F}
  
 can be reached from the start state 
  
    
      
        
          q
          
            0
          
        
      
    
    {\displaystyle q_{0}}
  
 by consuming 
  
    
      
        w
      
    
    {\displaystyle w}
  
.[4]:â21â[7]:â59â
Initial state[edit]
The above automaton definition uses a single initial state, which is not necessary. Sometimes, NFAs are defined with a set of initial states. There is an easy construction that translates a NFA with multiple initial states to a NFA with single initial state, which provides a convenient notation.

Example[edit]



  The state diagram for M. It is not deterministic since in state p reading a 1 can lead to p or to q.

  All possible runs of M on input string "10".


  All possible runs of M on input string "1011".Arc label: input symbol, node label: state, green: start state, red: accepting state(s).

The following automaton 
  
    
      
        M
      
    
    {\displaystyle M}
  
, with a binary alphabet, determines if the input ends with a 1.
Let 
  
    
      
        M
        =
        (
        {
        p
        ,
        q
        }
        ,
        {
        0
        ,
        1
        }
        ,
        Î
        ,
        p
        ,
        {
        q
        }
        )
      
    
    {\displaystyle M=(\{p,q\},\{0,1\},\Delta ,p,\{q\})}
  
 where
the transition function 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
 can be defined by this state transition table (cf. upper left picture):



InputState

0

1



  
    
      
        p
      
    
    {\displaystyle p}
  



  
    
      
        {
        p
        }
      
    
    {\displaystyle \{p\}}
  



  
    
      
        {
        p
        ,
        q
        }
      
    
    {\displaystyle \{p,q\}}
  




  
    
      
        q
      
    
    {\displaystyle q}
  



  
    
      
        â
      
    
    {\displaystyle \emptyset }
  



  
    
      
        â
      
    
    {\displaystyle \emptyset }
  


Since the set 
  
    
      
        Î
        (
        p
        ,
        1
        )
      
    
    {\displaystyle \Delta (p,1)}
  
 contains more than one state, 
  
    
      
        M
      
    
    {\displaystyle M}
  
 is nondeterministic.
The language of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 can be described by the regular language given by the regular expression (0|1)*1.
All possible state sequences for the input string "1011" are shown in the lower picture.
The string is accepted by 
  
    
      
        M
      
    
    {\displaystyle M}
  
 since one state sequence satisfies the above definition; it doesn't matter that other sequences fail to do so.
The picture can be interpreted in a couple of ways:

In terms of the above "lucky-run" explanation, each path in the picture denotes a sequence of choices of 
  
    
      
        M
      
    
    {\displaystyle M}
  
.
In terms of the "cloning" explanation, each vertical column shows all clones of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 at a given point in time, multiple arrows emanating from a node indicate cloning, a node without emanating arrows indicating the "death" of a clone.
The feasibility to read the same picture in two ways also indicates the equivalence of both above explanations.

Considering the first of the above formal definitions, "1011" is accepted since when reading it 
  
    
      
        M
      
    
    {\displaystyle M}
  
 may traverse the state sequence 
  
    
      
        â¨
        
          r
          
            0
          
        
        ,
        
          r
          
            1
          
        
        ,
        
          r
          
            2
          
        
        ,
        
          r
          
            3
          
        
        ,
        
          r
          
            4
          
        
        â©
        =
        â¨
        p
        ,
        p
        ,
        p
        ,
        p
        ,
        q
        â©
      
    
    {\displaystyle \langle r_{0},r_{1},r_{2},r_{3},r_{4}\rangle =\langle p,p,p,p,q\rangle }
  
, which satisfies conditions 1 to 3.
Concerning the second formal definition, bottom-up computation shows that 
  
    
      
        
          Î
          
            â
          
        
        (
        p
        ,
        Ïµ
        )
        =
        {
        p
        }
      
    
    {\displaystyle \Delta ^{*}(p,\epsilon )=\{p\}}
  
, hence 
  
    
      
        
          Î
          
            â
          
        
        (
        p
        ,
        1
        )
        =
        Î
        (
        p
        ,
        1
        )
        =
        {
        p
        ,
        q
        }
      
    
    {\displaystyle \Delta ^{*}(p,1)=\Delta (p,1)=\{p,q\}}
  
, hence 
  
    
      
        
          Î
          
            â
          
        
        (
        p
        ,
        10
        )
        =
        Î
        (
        p
        ,
        0
        )
        âª
        Î
        (
        q
        ,
        0
        )
        =
        {
        p
        }
        âª
        {
        }
      
    
    {\displaystyle \Delta ^{*}(p,10)=\Delta (p,0)\cup \Delta (q,0)=\{p\}\cup \{\}}
  
, hence 
  
    
      
        
          Î
          
            â
          
        
        (
        p
        ,
        101
        )
        =
        Î
        (
        p
        ,
        1
        )
        =
        {
        p
        ,
        q
        }
      
    
    {\displaystyle \Delta ^{*}(p,101)=\Delta (p,1)=\{p,q\}}
  
, and hence 
  
    
      
        
          Î
          
            â
          
        
        (
        p
        ,
        1011
        )
        =
        Î
        (
        p
        ,
        1
        )
        âª
        Î
        (
        q
        ,
        1
        )
        =
        {
        p
        ,
        q
        }
        âª
        {
        }
      
    
    {\displaystyle \Delta ^{*}(p,1011)=\Delta (p,1)\cup \Delta (q,1)=\{p,q\}\cup \{\}}
  
; since that set is not disjoint from 
  
    
      
        {
        q
        }
      
    
    {\displaystyle \{q\}}
  
, the string "1011" is accepted.
In contrast, the string "10" is rejected by 
  
    
      
        M
      
    
    {\displaystyle M}
  
 (all possible state sequences for that input are shown in the upper right picture), since there is no way to reach the only accepting state, 
  
    
      
        q
      
    
    {\displaystyle q}
  
, by reading the final 0 symbol. While 
  
    
      
        q
      
    
    {\displaystyle q}
  
 can be reached after consuming the initial "1", this does not mean that the input "10" is accepted; rather, it means that an input string "1" would be accepted.

Equivalence to DFA[edit]
A deterministic finite automaton (DFA) can be seen as a special kind of NFA, in which for each state and symbol, the transition function has exactly one state. Thus, it is clear that every formal language that can be recognized by a DFA can be recognized by a NFA.
Conversely, for each NFA, there is a DFA such that it recognizes the same formal language. The DFA can be constructed using the powerset construction.
This result shows that NFAs, despite their additional flexibility, are unable to recognize  languages that cannot be recognized by some DFA. It is also important in practice for converting easier-to-construct NFAs into more efficiently executable DFAs. However, if the NFA has n states, the resulting DFA may have up to 
  
    
      
        
          2
          
            n
          
        
      
    
    {\displaystyle 2^{n}}
  
 states, which sometimes makes the construction impractical for large NFAs.

NFA with Îµ-moves[edit]
Nondeterministic finite automaton with Îµ-moves (NFA-Îµ) is a further generalization to NFA. This automaton replaces the transition function with the one that allows the empty string Îµ as a possible input. The transitions without consuming an input symbol are called Îµ-transitions. In the state diagrams, they are usually labeled with the Greek letter Îµ. Îµ-transitions provide a convenient way of modeling the systems whose current states are not precisely known: i.e., if we are modeling a system and it is not clear whether the current state (after processing some input string) should be q or q', then we can add an Îµ-transition between these two states, thus putting the automaton in both states simultaneously.

Formal definition[edit]
An NFA-Îµ is represented formally by a 5-tuple, 
  
    
      
        (
        Q
        ,
        Î£
        ,
        Î
        ,
        
          q
          
            0
          
        
        ,
        F
        )
      
    
    {\displaystyle (Q,\Sigma ,\Delta ,q_{0},F)}
  
, consisting of

a finite set of states 
  
    
      
        Q
      
    
    {\displaystyle Q}
  

a finite set of input symbols called the alphabet 
  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  

a transition function 
  
    
      
        Î
        :
        Q
        Ã
        (
        Î£
        âª
        {
        Ïµ
        }
        )
        â
        
          
            P
          
        
        (
        Q
        )
      
    
    {\displaystyle \Delta :Q\times (\Sigma \cup \{\epsilon \})\rightarrow {\mathcal {P}}(Q)}
  

an initial (or start) state 
  
    
      
        
          q
          
            0
          
        
        â
        Q
      
    
    {\displaystyle q_{0}\in Q}
  

a set of states 
  
    
      
        F
      
    
    {\displaystyle F}
  
 distinguished as accepting (or final) states 
  
    
      
        F
        â
        Q
      
    
    {\displaystyle F\subseteq Q}
  
.
Here, 
  
    
      
        
          
            P
          
        
        (
        Q
        )
      
    
    {\displaystyle {\mathcal {P}}(Q)}
  
 denotes the power set of 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
 and Îµ denotes empty string.

Îµ-closure of a state or set of states[edit]
For a state 
  
    
      
        q
        â
        Q
      
    
    {\displaystyle q\in Q}
  
, let 
  
    
      
        E
        (
        q
        )
      
    
    {\displaystyle E(q)}
  
 denote the set of states that are reachable from 
  
    
      
        q
      
    
    {\displaystyle q}
  
 by following Îµ-transitions in the transition function 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
, i.e.,

  
    
      
        p
        â
        E
        (
        q
        )
      
    
    {\displaystyle p\in E(q)}
  
 if there is a sequence of states 
  
    
      
        
          q
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          q
          
            k
          
        
      
    
    {\displaystyle q_{1},...,q_{k}}
  
 such that


  
    
      
        
          q
          
            1
          
        
        =
        q
      
    
    {\displaystyle q_{1}=q}
  
,

  
    
      
        
          q
          
            i
            +
            1
          
        
        â
        Î
        (
        
          q
          
            i
          
        
        ,
        Îµ
        )
      
    
    {\displaystyle q_{i+1}\in \Delta (q_{i},\varepsilon )}
  
 for each 
  
    
      
        1
        â¤
        i
        <
        k
      
    
    {\displaystyle 1\leq i<k}
  
, and

  
    
      
        
          q
          
            k
          
        
        =
        p
      
    
    {\displaystyle q_{k}=p}
  
.

  
    
      
        E
        (
        q
        )
      
    
    {\displaystyle E(q)}
  
 is known as the Îµ-closure of 
  
    
      
        q
      
    
    {\displaystyle q}
  
.
Îµ-closure is also defined for a set of states. The Îµ-closure of a set of states, 
  
    
      
        P
      
    
    {\displaystyle P}
  
, of an NFA is defined as the set of states reachable from any state in 
  
    
      
        P
      
    
    {\displaystyle P}
  
 following Îµ-transitions. Formally, for 
  
    
      
        P
        â
        Q
      
    
    {\displaystyle P\subseteq Q}
  
, define 
  
    
      
        E
        (
        P
        )
        =
        
          â
          
            q
            â
            P
          
        
        E
        (
        q
        )
      
    
    {\displaystyle E(P)=\bigcup \limits _{q\in P}E(q)}
  
.

Accepting states[edit]
Let 
  
    
      
        w
        =
        
          a
          
            1
          
        
        
          a
          
            2
          
        
        .
        .
        .
        
          a
          
            n
          
        
      
    
    {\displaystyle w=a_{1}a_{2}...a_{n}}
  
 be a string over the alphabet 
  
    
      
        Î£
      
    
    {\displaystyle \Sigma }
  
. The automaton 
  
    
      
        M
      
    
    {\displaystyle M}
  
 accepts the string 
  
    
      
        w
      
    
    {\displaystyle w}
  
 if a sequence of states,

  
    
      
        
          r
          
            0
          
        
        ,
        
          r
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          r
          
            n
          
        
      
    
    {\displaystyle r_{0},r_{1},...,r_{n}}
  
, exists in 
  
    
      
        Q
      
    
    {\displaystyle Q}
  
 with the following conditions:


  
    
      
        
          r
          
            0
          
        
        â
        E
        (
        
          q
          
            0
          
        
        )
      
    
    {\displaystyle r_{0}\in E(q_{0})}
  


  
    
      
        
          r
          
            i
            +
            1
          
        
        â
        E
        (
        
          r
          â²
        
        )
      
    
    {\displaystyle r_{i+1}\in E(r')}
  
 where 
  
    
      
        
          r
          â²
        
        â
        Î
        (
        
          r
          
            i
          
        
        ,
        
          a
          
            i
            +
            1
          
        
        )
      
    
    {\displaystyle r'\in \Delta (r_{i},a_{i+1})}
  
 for each 
  
    
      
        i
        =
        0
        ,
        .
        .
        .
        ,
        n
        â
        1
      
    
    {\displaystyle i=0,...,n-1}
  
, and

  
    
      
        
          r
          
            n
          
        
        â
        F
      
    
    {\displaystyle r_{n}\in F}
  
.
In words, the first condition says that the machine starts 
at the state that is reachable from the start state 
  
    
      
        
          q
          
            0
          
        
      
    
    {\displaystyle q_{0}}
  
 via Îµ-transitions. The second condition says that after reading 
  
    
      
        
          a
          
            i
          
        
      
    
    {\displaystyle a_{i}}
  
,
the machine takes a transition of 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
 from 
  
    
      
        
          r
          
            i
          
        
      
    
    {\displaystyle r_{i}}
  
 to 
  
    
      
        
          r
          â²
        
      
    
    {\displaystyle r'}
  
,
and then takes any number of Îµ-transitions according to 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
 to move from 
  
    
      
        
          r
          â²
        
      
    
    {\displaystyle r'}
  
 to 
  
    
      
        
          r
          
            i
            +
            1
          
        
      
    
    {\displaystyle r_{i+1}}
  
. 
The last condition says that the machine accepts 
  
    
      
        w
      
    
    {\displaystyle w}
  
 if the last input of 
  
    
      
        w
      
    
    {\displaystyle w}
  
 causes the machine to halt in one of the accepting states. Otherwise, it is said that the automaton rejects the string. The set of strings 
  
    
      
        M
      
    
    {\displaystyle M}
  
 accepts is the language recognized by 
  
    
      
        M
      
    
    {\displaystyle M}
  
 and this language is denoted by 
  
    
      
        L
        (
        M
        )
      
    
    {\displaystyle L(M)}
  
.

Example[edit]
  The state diagram for M
Let 
  
    
      
        M
      
    
    {\displaystyle M}
  
 be a NFA-Îµ, with a binary alphabet, that determines if the input contains an even number of 0s or an even number of 1s. Note that 0 occurrences is an even number of occurrences as well.
In formal notation, let 
  
    
      
        M
        =
        (
        {
        
          S
          
            0
          
        
        ,
        
          S
          
            1
          
        
        ,
        
          S
          
            2
          
        
        ,
        
          S
          
            3
          
        
        ,
        
          S
          
            4
          
        
        }
        ,
        {
        0
        ,
        1
        }
        ,
        Î
        ,
        
          S
          
            0
          
        
        ,
        {
        
          S
          
            1
          
        
        ,
        
          S
          
            3
          
        
        }
        )
      
    
    {\displaystyle M=(\{S_{0},S_{1},S_{2},S_{3},S_{4}\},\{0,1\},\Delta ,S_{0},\{S_{1},S_{3}\})}
  
 where
the transition relation 
  
    
      
        Î
      
    
    {\displaystyle \Delta }
  
 can be defined by this state transition table:



InputState

0

1

Îµ


S0

{}

{}

{S1, S3}


S1

{S2}

{S1}

{}


S2

{S1}

{S2}

{}


S3

{S3}

{S4}

{}


S4

{S4}

{S3}

{}


  
    
      
        M
      
    
    {\displaystyle M}
  
 can be viewed as the union of two DFAs: one with states 
  
    
      
        {
        
          S
          
            1
          
        
        ,
        
          S
          
            2
          
        
        }
      
    
    {\displaystyle \{S_{1},S_{2}\}}
  
 and the other with states 
  
    
      
        {
        
          S
          
            3
          
        
        ,
        
          S
          
            4
          
        
        }
      
    
    {\displaystyle \{S_{3},S_{4}\}}
  
. 
The language of 
  
    
      
        M
      
    
    {\displaystyle M}
  
 can be described by the regular language given by this regular expression 
  
    
      
        (
        
          1
          
            â
          
        
        (
        
          01
          
            â
          
        
        
          01
          
            â
          
        
        
          )
          
            â
          
        
        )
        âª
        (
        
          0
          
            â
          
        
        (
        
          10
          
            â
          
        
        
          10
          
            â
          
        
        
          )
          
            â
          
        
        )
      
    
    {\displaystyle (1^{*}(01^{*}01^{*})^{*})\cup (0^{*}(10^{*}10^{*})^{*})}
  
.
We define 
  
    
      
        M
      
    
    {\displaystyle M}
  
 using Îµ-moves but 
  
    
      
        M
      
    
    {\displaystyle M}
  
 can be defined without using Îµ-moves.

Equivalence to NFA[edit]
To show NFA-Îµ is equivalent to NFA, first note that NFA is a special case of NFA-Îµ, so it remains to show for every NFA-Îµ, there exists an equivalent NFA.
Let 
  
    
      
        A
        =
        (
        Q
        ,
        Î£
        ,
        Î
        ,
        
          q
          
            0
          
        
        ,
        F
        )
      
    
    {\displaystyle A=(Q,\Sigma ,\Delta ,q_{0},F)}
  
 be a NFA-Îµ. 
The NFA 
  
    
      
        
          A
          â²
        
        =
        (
        Q
        ,
        Î£
        ,
        
          Î
          â²
        
        ,
        E
        (
        
          q
          
            0
          
        
        )
        ,
        F
        )
      
    
    {\displaystyle A'=(Q,\Sigma ,\Delta ',E(q_{0}),F)}
  
 is equivalent to 
  
    
      
        A
      
    
    {\displaystyle A}
  
, where for each 
  
    
      
        a
        â
        Î£
      
    
    {\displaystyle a\in \Sigma }
  
 and 
  
    
      
        q
        â
        Q
      
    
    {\displaystyle q\in Q}
  
, 
  
    
      
        
          Î
          â²
        
        (
        q
        ,
        a
        )
        =
        E
        (
        Î
        (
        q
        ,
        a
        )
        )
      
    
    {\displaystyle \Delta '(q,a)=E(\Delta (q,a))}
  
.
Thus NFA-Îµ is equivalent to NFA. Since NFA is equivalent to DFA, NFA-Îµ is also equivalent to DFA.

Closure properties[edit]
  Composed NFA accepting the union of the languages of some given NFAs N(s) and N(t). For an input string w in the language union, the composed automaton follows an Îµ-transition from q to the start state (left colored circle) of an appropriate subautomaton â N(s) or N(t) â which, by following w, may reach an accepting state (right colored circle); from there, state f can be reached by another Îµ-transition. Due to the Îµ-transitions, the composed NFA is properly nondeterministic even if both N(s) and N(t) were DFAs; vice versa, constructing a DFA for the union language (even of two DFAs) is much more complicated.
NFAs are said to be closed under a (binary/unary) operator
if NFAs recognize the languages
that are obtained by applying the operation on the NFA recognizable languages.
The NFAs are closed under the following operations.

Union (cf. picture)
Intersection
Concatenation
Negation
Kleene closure
Since NFAs are equivalent to nondeterministic finite automaton with Îµ-moves (NFA-Îµ), the above closures are proved using closure properties of NFA-Îµ. The above closure properties imply that NFAs can recognize regular languages.
NFAs can be constructed from any regular expression using Thompson's construction algorithm.

Properties[edit]
The machine starts in the specified initial state and reads in a string of symbols from its alphabet. The automaton uses the state transition function Î to determine the next state using the current state, and the symbol just read or the empty string. However, "the next state of an NFA depends not only on the current input event, but also on an arbitrary number of subsequent input events. Until these subsequent events occur it is not possible to determine which state the machine is in".[8] If, when the automaton has finished reading, it is in an accepting state, the NFA is said to accept the string, otherwise it is said to reject the string.
The set of all strings accepted by an NFA is the language the NFA accepts. This language is a regular language.
For every NFA a deterministic finite automaton (DFA) can be found that accepts the same language. Therefore, it is possible to convert an existing NFA into a DFA for the purpose of implementing a (perhaps) simpler machine. This can be performed using the powerset construction, which may lead to an exponential rise in the number of necessary states. For a formal proof of the powerset construction, please see the Powerset construction article.

Implementation[edit]
There are many ways to implement a NFA:

Convert to the equivalent DFA. In some cases this may cause exponential blowup in the number of states.[9]
Keep a set data structure of all states which the NFA might currently be in. On the consumption of an input symbol, unite the results of the transition function applied to all current states to get the set of next states; if Îµ-moves are allowed, include all states reachable by such a move (Îµ-closure). Each step requires at most s2 computations, where s is the number of states of the NFA. On the consumption of the last input symbol, if one of the current states is a final state, the machine accepts the string. A string of length n can be processed in time O(ns2),[7]:â153â and space O(s).
Create multiple copies. For each n way decision, the NFA creates up to 
  
    
      
        n
        â
        1
      
    
    {\displaystyle n-1}
  
 copies of the machine. Each will enter a separate state. If, upon consuming the last input symbol, at least one copy of the NFA is in the accepting state, the NFA will accept.  (This, too, requires linear storage with respect to the number of NFA states, as there can be one machine for every NFA state.)
Explicitly propagate tokens through the transition structure of the NFA and match whenever a token reaches the final state. This is sometimes useful when the NFA should encode additional context about the events that triggered the transition. (For an implementation that uses this technique to keep track of object references have a look at Tracematches.[10])
It is PSPACE-complete to test, given an NFA, whether it is universal, i.e., if there is a string that it does not accept.[11] The same is true of the inclusion problem, i.e., given two NFAs, is the language of one a subset of the language of the other.
Application of NFA[edit]
NFAs and DFAs are equivalent in that if a language is recognized by an NFA, it is also recognized by a DFA and vice versa.  The establishment of such equivalence is important and useful.  It is useful because constructing an NFA to recognize a given language is sometimes much easier than constructing a DFA for that language.  It is important because NFAs can be used to reduce the complexity of the mathematical work required to establish many important properties in the theory of computation.  For example, it is much easier to prove closure properties of regular languages using NFAs than DFAs.

See also[edit]
Deterministic finite automaton
Two-way nondeterministic finite automaton
Pushdown automaton
Nondeterministic Turing machine
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Martin, John (2010). Introduction to Languages and the Theory of Computation. McGraw Hill. p.Â 108. ISBNÂ 978-0071289429.

^ Rabin, M. O.; Scott, D. (April 1959). "Finite Automata and Their Decision Problems". IBM Journal of Research and Development. 3 (2): 114â125. doi:10.1147/rd.32.0114.

^ A choice sequence may lead into a "dead end" where no transition is applicable for the current input symbol; in this case it is considered unsuccessful.

^ Jump up to: a b c John E. Hopcroft and Jeffrey D. Ullman (1979). Introduction to Automata Theory, Languages, and Computation. Reading/MA: Addison-Wesley. ISBNÂ 0-201-02988-X.

^ Jump up to: a b Alfred V. Aho and John E. Hopcroft and Jeffrey D. Ullman (1974). The Design and Analysis of Computer Algorithms. Reading/MA: Addison-Wesley. ISBNÂ 0-201-00029-6.

^ Jump up to: a b Michael Sipser (1997). Introduction to the Theory of Computation. Boston/MA: PWS Publishing Co. ISBNÂ 0-534-94728-X.

^ Jump up to: a b c John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman (2003). Introduction to Automata Theory, Languages, and Computation (PDF). Upper Saddle River/NJ: Addison Wesley. ISBNÂ 0-201-44124-1.

^ FOLDOC Free Online Dictionary of Computing, Finite-State Machine

^ http://cseweb.ucsd.edu/~ccalabro/essays/fsa.pdf

^ Allan, C., Avgustinov, P., Christensen, A. S., Hendren, L., Kuzins, S., LhotÃ¡k, O., de Moor, O., Sereni, D., Sittampalam, G., and Tibble, J. 2005. Adding trace matching with free variables to AspectJ Archived 2009-09-18 at the Wayback Machine. In Proceedings of the 20th Annual ACM SIGPLAN Conference on Object Oriented Programming, Systems, Languages, and Applications (San Diego, CA, USA, October 16â20, 2005). OOPSLA '05. ACM, New York, NY, 345-364.

^ Historically shown in: Meyer, A. R.; Stockmeyer, L. J. (1972-10-25). "The equivalence problem for regular expressions with squaring requires exponential space". Proceedings of the 13th Annual Symposium on Switching and Automata Theory (SWAT). USA: IEEE Computer Society: 125â129. doi:10.1109/SWAT.1972.29. For a modern presentation, see [1]


References[edit]
M. O. Rabin and D. Scott, "Finite Automata and their Decision Problems", IBM Journal of Research and Development, 3:2 (1959) pp.Â 115â125.
Michael Sipser, Introduction to the Theory of Computation. PWS, Boston. 1997. ISBNÂ 0-534-94728-X. (see section 1.2: Nondeterminism, pp. 47â63.)
John E. Hopcroft and Jeffrey D. Ullman, Introduction to Automata Theory, Languages, and Computation, Addison-Wesley Publishing, Reading Massachusetts, 1979. ISBNÂ 0-201-02988-X. (See chapter 2.)
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}show.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteAutomata theory: formal languages and formal grammarsChomsky hierarchyGrammarsLanguagesAbstract machines
Type-0
â
Type-1
â
â
â
â
â
Type-2
â
â
Type-3
â
â

Unrestricted
(no common name)
Context-sensitive
Positive range concatenation
Indexed
â
Linear context-free rewriting systems
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
â
Non-recursive

Recursively enumerable
Decidable
Context-sensitive
Positive range concatenation*
Indexed*
â
Linear context-free rewriting language
Tree-adjoining
Context-free
Deterministic context-free
Visibly pushdown
Regular
Star-free
Finite

Turing machine
Decider
Linear-bounded
PTIME Turing Machine
Nested stack
Thread automaton
restricted Tree stack automaton
Embedded pushdown
Nondeterministic pushdown
Deterministic pushdown
Visibly pushdown
Finite
Counter-free (with aperiodic finite monoid)
Acyclic finite
Each category of languages, except those marked by a *, is a proper subset of the category directly above it. Any language in each category is generated by a grammar and by an automaton in the category in the same line.
showvteStringsString metric
Approximate string matching
Bitap algorithm
DamerauâLevenshtein distance
Edit distance
Gestalt Pattern Matching
Hamming distance
JaroâWinkler distance
Lee distance
Levenshtein automaton
Levenshtein distance
WagnerâFischer algorithm 
String-searching algorithm
ApostolicoâGiancarlo algorithm
BoyerâMoore string-search algorithm
BoyerâMooreâHorspool algorithm
KnuthâMorrisâPratt algorithm
RabinâKarp algorithm
Multiple string searching
AhoâCorasick
Commentz-Walter algorithm
Regular expression
Comparison of regular-expression engines
Regular grammar
Thompson's construction
Nondeterministic finite automaton
Sequence alignment
Hirschberg's algorithm
NeedlemanâWunsch algorithm
SmithâWaterman algorithm
Data structure
DAFSA
Suffix array
Suffix automaton
Suffix tree
Generalized suffix tree
Rope
Ternary search tree
Trie
Other
Parsing
Pattern matching
Compressed pattern matching
Longest common subsequence
Longest common substring
Sequential pattern mining
Sorting





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Nondeterministic_finite_automaton&oldid=1069111418"
		Categories: Finite automataHidden categories: Webarchive template wayback links
	
