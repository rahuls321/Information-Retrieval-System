
Title:
Relational model
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Database model
The relational model (RM) for database management is an approach to managing data using a structure and language consistent with first-order predicate logic, first described in 1969 by English computer scientist Edgar F. Codd,[1][2] where all data is represented in terms of tuples, grouped into relations. A database organized in terms of the relational model is a relational database.
The purpose of the relational model is to provide a declarative method for specifying data and queries: users directly state what information the database contains and what information they want from it, and let the database management system software take care of describing data structures for storing the data and retrieval procedures for answering queries.
Most relational databases use the SQL data definition and query language; these systems implement what can be regarded as an engineering approximation to the relational model. A table in an SQL database schema corresponds to a predicate variable; the contents of a table to a relation; key constraints, other constraints, and SQL queries correspond to predicates. However, SQL databases deviate from the relational model in many details, and Codd fiercely argued against deviations that compromise the original principles.[3]

Contents

1 Overview

1.1 Alternatives
1.2 Implementation


2 History

2.1 Controversies


3 Topics

3.1 Interpretation
3.2 Application to databases
3.3 SQL and the relational model
3.4 Relational operations
3.5 Database normalization


4 Examples

4.1 Database
4.2 Customer relation


5 Set-theoretic formulation

5.1 Key constraints and functional dependencies
5.2 Algorithm to derive candidate keys from functional dependencies


6 See also
7 References
8 Further reading
9 External links



Overview[edit]
The relational model's central idea is to describe a database as a collection of predicates over a finite set of predicate variables, describing constraints on the possible values and combinations of values. The content of the database at any given time is a finite (logical) model of the database, i.e. a set of relations, one per predicate variable, such that all predicates are satisfied. A request for information from the database (a database query) is also a predicate.

  Relational model concepts.
Alternatives[edit]
Other models include the hierarchical model and network model. Some systems using these older architectures are still in use today in data centers with high data volume needs, or where existing systems are so complex and abstract that it would be cost-prohibitive to migrate to systems employing the relational model. Also of note are newer object-oriented databases.

Implementation[edit]
There have been several attempts to produce a true implementation of the relational database model as originally defined by Codd and explained by Date, Darwen and others, but none have popular successes so far. As of OctoberÂ 2015[update], Rel is one of the more recent attempts to do this.
The relational model was the first database model to be described in formal mathematical terms. Hierarchical and network databases existed before relational databases, but their specifications were relatively informal. After the relational model was defined, there were many attempts to compare and contrast the different models, and this led to the emergence of more rigorous descriptions of the earlier models; though the procedural nature of the data manipulation interfaces for hierarchical and network databases limited the scope for formalization.[citation needed]
Structural database analytics employing relational modality protocols frequently employ data sequence differentials to maintain hierarchical architecture designations with incorporation of new input. These systems are functionally similar in concept to alternative relay algorithms, which form the foundation of cloud database infrastructure.[citation needed]

History[edit]
The relational model was invented by Edgar F. Codd as a general model of data, and subsequently promoted by Chris Date and Hugh Darwen among others. In The Third Manifesto (first published in 1995) Date and Darwen attempt to show how the relational model can allegedly accommodate certain "desired" object-oriented features.

Controversies[edit]
Some years after publication of his 1970 model, Codd proposed a three-valued logic (True, False, Missing/NULL) version of it to deal with missing information, and in his The Relational Model for Database Management Version 2 (1990) he went a step further with a four-valued logic (True, False, Missing but Applicable, Missing but Inapplicable) version.[4] These have never been implemented, presumably because of attending complexity. SQL's NULL construct was intended to be part of a three-valued logic system, but fell short of that due to logical errors in the standard and in its implementations.[5]

Topics[edit]
The fundamental assumption of the relational model is that all data is represented as mathematical n-ary relations, an n-ary relation being a subset of the Cartesian product of n domains. In the mathematical model, reasoning about such data is done in two-valued predicate logic, meaning there are two possible evaluations for each proposition: either true or false (and in particular no third value such as unknown, or not applicable, either of which are often associated with the concept of NULL).  Data are operated upon by means of a relational calculus or relational algebra, these being equivalent in expressive power.
The relational model of data permits the database designer to create a consistent, logical representation of information. Consistency is achieved by including declared constraints in the database design, which is usually referred to as the logical schema. The theory includes a process of database normalization whereby a design with certain desirable properties can be selected from a set of logically equivalent alternatives. The access plans and other implementation and operation details are handled by the DBMS engine, and are not reflected in the logical model. This contrasts with common practice for SQL DBMSs in which performance tuning often requires changes to the logical model.
The basic relational building block is the domain or data type, usually abbreviated nowadays to type. A tuple is an ordered set of attribute values. An attribute is an ordered pair of attribute name and type name.  An attribute value is a specific valid value for the type of the attribute. This can be either a scalar value or a more complex type.
A relation consists of a heading and a body. A heading is a set of attributes. A body (of an n-ary relation) is a set of n-tuples. The heading of the relation is also the heading of each of its tuples.
A relation is defined as a set of n-tuples. In both mathematics and the relational database model, a set is an unordered collection of unique, non-duplicated items, although some DBMSs impose an order to their data. In mathematics, a tuple has an order, and allows for duplication. E.Â F. Codd originally defined tuples using this mathematical definition.[2] Later, it was one of E.Â F. Codd's great insights that using attribute names instead of an ordering would be more convenient (in general) in a computer language based on relations[citation needed]. This insight is still being used today. Though the concept has changed, the name "tuple" has not. An immediate and important consequence of this distinguishing feature is that in the relational model the Cartesian product becomes commutative.
A table is an accepted visual representation of a relation; a tuple is similar to the concept of a row.
A relvar is a named variable of some specific relation type, to which at all times some relation of that type is assigned, though the relation may contain zero tuples.
The basic principle of the relational model is the Information Principle: all information is represented by data values in relations. In accordance with this Principle, a relational database is a set of relvars and the result of every query is presented as a relation.
The consistency of a relational database is enforced, not by rules built into the applications that use it, but rather by constraints, declared as part of the logical schema and enforced by the DBMS for all applications. In general, constraints are expressed using relational comparison operators, of which just one, "is subset of" (â), is theoretically sufficient[citation needed]. In practice, several useful shorthands are expected to be available, of which the most important are candidate key (really, superkey) and foreign key constraints.

Interpretation[edit]
To fully appreciate the relational model of data it is essential to understand the intended interpretation of a relation.
The body of a relation is sometimes called its extension. This is because it is to be interpreted as a representation of the extension of some predicate, this being the set of true propositions that can be formed by replacing each free variable in that predicate by a name (a term that designates something).
There is a one-to-one correspondence between the free variables of the predicate and the attribute names of the relation heading. Each tuple of the relation body provides attribute values to instantiate the predicate by substituting each of its free variables. The result is a proposition that is deemed, on account of the appearance of the tuple in the relation body, to be true. Contrariwise, every tuple whose heading conforms to that of the relation, but which does not appear in the body is deemed to be false. This assumption is known as the closed world assumption: it is often violated in practical databases, where the absence of a tuple might mean that the truth of the corresponding proposition is unknown. For example, the absence of the tuple ('John', 'Spanish') from a table of language skills cannot necessarily be taken as evidence that John does not speak Spanish.
For a formal exposition of these ideas, see the section Set-theoretic Formulation, below.

Application to databases[edit]
A data type as used in a typical relational database might be the set of integers, the set of character strings, the set of dates, or the two boolean values true and false, and so on. The corresponding type names for these types might be the strings "int", "char", "date", "boolean", etc. It is important to understand, though, that relational theory does not dictate what types are to be supported; indeed, nowadays provisions are expected to be available for user-defined types in addition to the built-in ones provided by the system.
Attribute is the term used in the theory for what is commonly referred to as a column. Similarly, table is commonly used in place of the theoretical term relation (though in SQL the term is by no means synonymous with relation). A table data structure is specified as a list of column definitions, each of which specifies a unique column name and the type of the values that are permitted for that column.  An attribute value is the entry in a specific column and row, such as "John Doe" or "35".
A tuple is basically the same thing as a row, except in an SQL DBMS, where the column values in a row are ordered. (Tuples are not ordered; instead, each attribute value is identified solely by the attribute name and never by its ordinal position within the tuple.)  An attribute name might be "name" or "age".
A relation is a table structure definition (a set of column definitions) along with the data appearing in that structure. The structure definition is the heading and the data appearing in it is the body, a set of rows. A database relvar (relation variable) is commonly known as a base table. The heading of its assigned value at any time is as specified in the table declaration and its body is that most recently assigned to it by invoking some update operator (typically, INSERT, UPDATE, or DELETE). The heading and body of the table resulting from evaluation of some query are determined by the definitions of the operators used in the expression of that query. (Note that in SQL the heading is not always a set of column definitions as described above, because it is possible for a column to have no name and also for two or more columns to have the same name. Also, the body is not always a set of rows because in SQL it is possible for the same row to appear more than once in the same body.)

SQL and the relational model[edit]
This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed.  (February 2013) (Learn how and when to remove this template message)
SQL, initially pushed as the standard language for relational databases, deviates from the relational model in several places. The current ISO SQL standard doesn't mention the relational model or use relational terms or concepts. However, it is possible to create a database conforming to the relational model using SQL if one does not use certain SQL features.
The following deviations from the relational model have been noted[by whom?] in SQL. Note that few database servers implement the entire SQL standard and in particular do not allow some of these deviations. Whereas NULL is ubiquitous, for example, allowing duplicate column names within a table or anonymous columns is uncommon.

Duplicate rows
The same row can appear more than once in an SQL table. The same tuple cannot appear more than once in a relation.
Anonymous columns
A column in an SQL table can be unnamed and thus unable to be referenced in expressions. The relational model requires every attribute to be named and referenceable.
Duplicate column names
Two or more columns of the same SQL table can have the same name and therefore cannot be referenced, on account of the obvious ambiguity. The relational model requires every attribute to be referenceable.
Column order significance
The order of columns in an SQL table is defined and significant, one consequence being that SQL's implementations of Cartesian product and union are both noncommutative. The relational model requires there to be no significance to any ordering of the attributes of a relation.
Views without CHECK OPTION
Updates to a view defined without CHECK OPTION can be accepted but the resulting update to the database does not necessarily have the expressed effect on its target. For example, an invocation of INSERT can be accepted but the inserted rows might not all appear in the view, or an invocation of UPDATE can result in rows disappearing from the view. The relational model requires updates to a view to have the same effect as if the view were a base relvar.
Columnless tables unrecognized
SQL requires every table to have at least one column, but there are two relations of degree zero (of cardinality one and zero) and they are needed to represent extensions of predicates that contain no free variables.
NULL
This special mark can appear instead of a value wherever a value can appear in SQL, in particular in place of a column value in some row. The deviation from the relational model arises from the fact that the implementation of this ad hoc concept in SQL involves the use of three-valued logic, under which the comparison of NULL with itself does not yield true but instead yields the third truth value, unknown; similarly the comparison NULL with something other than itself does not yield false but instead yields unknown. It is because of this behavior in comparisons that NULL is described as a mark rather than a value. The relational model depends on the law of excluded middle under which anything that is not true is false and anything that is not false is true; it also requires every tuple in a relation body to have a value for every attribute of that relation. This particular deviation is disputed by some if only because E.Â F. Codd himself eventually advocated the use of special marks and a 4-valued logic, but this was based on his observation that there are two distinct reasons why one might want to use a special mark in place of a value, which led opponents of the use of such logics to discover more distinct reasons and at least as many as 19 have been noted, which would require a 21-valued logic.[citation needed] SQL itself uses NULL for several purposes other than to represent "value unknown". For example, the sum of the empty set is NULL, meaning zero, the average of the empty set is NULL, meaning undefined, and NULL appearing in the result of a LEFT JOIN can mean "no value because there is no matching row in the right-hand operand". There are ways to design tables to avoid the need for NULL, typically what may be considered or resemble high degrees of database normalization, but many find such impractical. It can be a hotly debated topic.
Relational operations[edit]
Users (or programs) request data from a relational database by sending it a query that is written in a special language, usually a dialect of SQL. Although SQL was originally intended for end-users, it is much more common for SQL queries to be embedded into software that provides an easier user interface. Many Web sites, such as Wikipedia, perform SQL queries when generating pages.
In response to a query, the database returns a result set, which is just a list of rows containing the answers. The simplest query is just to return all the rows from a table, but more often, the rows are filtered in some way to return just the answer wanted.
Often, data from multiple tables are combined into one, by doing a join. Conceptually, this is done by taking all possible combinations of rows (the Cartesian product), and then filtering out everything except the answer. In practice, relational database management systems rewrite ("optimize") queries to perform faster, using a variety of techniques.
There are a number of relational operations in addition to join. These include project (the process of eliminating some of the columns), restrict (the process of eliminating some of the rows), union (a way of combining two tables with similar structures), difference (that lists the rows in one table that are not found in the other), intersect (that lists the rows found in both tables), and product (mentioned above, which combines each row of one table with each row of the other). Depending on which other sources you consult, there are a number of other operatorsÂ â many of which can be defined in terms of those listed above. These include semi-join, outer operators such as outer join and outer union, and various forms of division. Then there are operators to rename columns, and summarizing or aggregating operators, and if you permit relation values as attributes (relation-valued attribute), then operators such as group and ungroup. The SELECT statement in SQL serves to handle all of these except for the group and ungroup operators.
The flexibility of relational databases allows programmers to write queries that were not anticipated by the database designers. As a result, relational databases can be used by multiple applications in ways the original designers did not foresee, which is especially important for databases that might be used for a long time (perhaps several decades). This has made the idea and implementation of relational databases very popular with businesses.

Database normalization[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Database normalization
Relations are classified based upon the types of anomalies to which they're vulnerable. A database that is in the first normal form is vulnerable to all types of anomalies, while a database that is in the domain/key normal form has no modification anomalies. Normal forms are hierarchical in nature. That is, the lowest level is the first normal form, and the database cannot meet the requirements for higher level normal forms without first having met all the requirements of the lesser normal forms.[6]

Examples[edit]
Database[edit]
An idealized, very simple example of a description of some relvars (relation variables) and their attributes:

Customer (Customer ID, Tax ID, Name, Address, City, State, Zip, Phone, Email, Sex)
Order (Order No, Customer ID, Invoice No, Date Placed, Date Promised, Terms, Status)
Order Line (Order No, Order Line No, Product Code, Qty)
Invoice (Invoice No, Customer ID, Order No, Date, Status)
Invoice Line (Invoice No, Invoice Line No, Product Code, Qty Shipped)
Product (Product Code, Product Description)
In this design we have six relvars: Customer, Order, Order Line, Invoice, Invoice Line and Product. The bold, underlined attributes are candidate keys. The non-bold, underlined attributes are foreign keys.
Usually one candidate key is chosen to be called the primary key and used in preference over the other candidate keys, which are then called alternate keys.
A candidate key is a unique identifier enforcing that no tuple will be duplicated; this would make the relation into something else, namely a bag, by violating the basic definition of a set. Both foreign keys and superkeys (that includes candidate keys) can be composite, that is, can be composed of several attributes. Below is a tabular depiction of a relation of our example Customer relvar; a relation can be thought of as a value that can be attributed to a relvar.

Customer relation[edit]



Customer ID
Tax ID
Name
Address
[More fieldsâ¦]


1234567890
555-5512222
Ramesh
323 Southern Avenue
â¦


2223344556
555-5523232
Adam
1200 Main Street
â¦


3334445563
555-5533323
Shweta
871 Rani Jhansi Road
â¦


4232342432
555-5325523
Sarfaraz
123 Maulana Azad Sarani
â¦

If we attempted to insert a new customer with the ID 1234567890, this would violate the design of the relvar since Customer ID is a primary key and we already have a customer 1234567890. The DBMS must reject a transaction such as this that would render the database inconsistent by a violation of an integrity constraint.
Foreign keys are integrity constraints enforcing that the value of the attribute set is drawn from a candidate key in another relation. For example, in the Order relation the attribute Customer ID is a foreign key. A join is the operation that draws on information from several relations at once.  By joining relvars from the example above we could query the database for all of the Customers, Orders, and Invoices. If we only wanted the tuples for a specific customer, we would specify this using a restriction condition.
If we wanted to retrieve all of the Orders for Customer 1234567890, we could query the database to return every row in the Order table with Customer ID 1234567890 and join the Order table to the Order Line table based on Order No.
There is a flaw in our database design above. The Invoice relvar contains an Order No attribute. So, each tuple in the Invoice relvar will have one Order No, which implies that there is precisely one Order for each Invoice. But in reality an invoice can be created against many orders, or indeed for no particular order. Additionally the Order relvar contains an Invoice No attribute, implying that each Order has a corresponding Invoice.  But again this is not always true in the real world. An order is sometimes paid through several invoices, and sometimes paid without an invoice. In other words, there can be many Invoices per Order and many Orders per Invoice. This is a many-to-many relationship between Order and Invoice (also called a non-specific relationship). To represent this relationship in the database a new relvar should be introduced whose role is to specify the correspondence between Orders and Invoices:

OrderInvoice (Order No, Invoice No)

Now, the Order relvar has a one-to-many relationship to the OrderInvoice table, as does the Invoice relvar. If we want to retrieve every Invoice for a particular Order, we can query for all orders where Order No in the Order relation equals the Order No in OrderInvoice, and where Invoice No in OrderInvoice equals the Invoice No in Invoice.

Set-theoretic formulation[edit]
Basic notions in the relational model are relation names and attribute names. We will represent these as strings such as "Person" and "name" and we will usually use the variables 
  
    
      
        r
        ,
        s
        ,
        t
        ,
        â¦
      
    
    {\displaystyle r,s,t,\ldots }
  
 and 
  
    
      
        a
        ,
        b
        ,
        c
      
    
    {\displaystyle a,b,c}
  
 to range over them. Another basic notion is the set of atomic values that contains values such as numbers and strings.
Our first definition concerns the notion of tuple, which formalizes the notion of row or record in a table:

Tuple
A tuple is a partial function from attribute names to atomic values.
Header
A header is a finite set of attribute names.
Projection
The projection of a tuple 
  
    
      
        t
      
    
    {\displaystyle t}
  
 on a finite set of attributes 
  
    
      
        A
      
    
    {\displaystyle A}
  
 is 
  
    
      
        t
        [
        A
        ]
        =
        {
        (
        a
        ,
        v
        )
        :
        (
        a
        ,
        v
        )
        â
        t
        ,
        a
        â
        A
        }
      
    
    {\displaystyle t[A]=\{(a,v):(a,v)\in t,a\in A\}}
  
.
The next definition defines relation that formalizes the contents of a table as it is defined in the relational model.

Relation
A relation is a tuple 
  
    
      
        (
        H
        ,
        B
        )
      
    
    {\displaystyle (H,B)}
  
 with 
  
    
      
        H
      
    
    {\displaystyle H}
  
, the header, and 
  
    
      
        B
      
    
    {\displaystyle B}
  
, the body, a set of tuples that all have the domain 
  
    
      
        H
      
    
    {\displaystyle H}
  
.
Such a relation closely corresponds to what is usually called the extension of a predicate in first-order logic except that here we identify the places in the predicate with attribute names. Usually in the relational model a database schema is said to consist of a set of relation names, the headers that are associated with these names and the constraints that should hold for every instance of the database schema.

Relation universe
A relation universe 
  
    
      
        U
      
    
    {\displaystyle U}
  
 over a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 is a non-empty set of relations with header 
  
    
      
        H
      
    
    {\displaystyle H}
  
.
Relation schema
A relation schema 
  
    
      
        (
        H
        ,
        C
        )
      
    
    {\displaystyle (H,C)}
  
 consists of a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 and a predicate 
  
    
      
        C
        (
        R
        )
      
    
    {\displaystyle C(R)}
  
 that is defined for all relations 
  
    
      
        R
      
    
    {\displaystyle R}
  
 with header 
  
    
      
        H
      
    
    {\displaystyle H}
  
. A relation satisfies a relation schema 
  
    
      
        (
        H
        ,
        C
        )
      
    
    {\displaystyle (H,C)}
  
 if it has header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 and satisfies 
  
    
      
        C
      
    
    {\displaystyle C}
  
.
Key constraints and functional dependencies[edit]
One of the simplest and most important types of relation constraints is the key constraint. It tells us that in every instance of a certain relational schema the tuples can be identified by their values for certain attributes.

Superkey
A superkey is a set of column headers for which the values of those columns concatenated are unique across all rows. Formally:

A superkey is written as a finite set of attribute names.
A superkey 
  
    
      
        K
      
    
    {\displaystyle K}
  
 holds in a relation 
  
    
      
        (
        H
        ,
        B
        )
      
    
    {\displaystyle (H,B)}
  
 if:

  
    
      
        K
        â
        H
      
    
    {\displaystyle K\subseteq H}
  
 and
there exist no two distinct tuples 
  
    
      
        
          t
          
            1
          
        
        ,
        
          t
          
            2
          
        
        â
        B
      
    
    {\displaystyle t_{1},t_{2}\in B}
  
 such that 
  
    
      
        
          t
          
            1
          
        
        [
        K
        ]
        =
        
          t
          
            2
          
        
        [
        K
        ]
      
    
    {\displaystyle t_{1}[K]=t_{2}[K]}
  
.
A superkey holds in a relation universe 
  
    
      
        U
      
    
    {\displaystyle U}
  
 if it holds in all relations in 
  
    
      
        U
      
    
    {\displaystyle U}
  
.
Theorem: A superkey 
  
    
      
        K
      
    
    {\displaystyle K}
  
 holds in a relation universe 
  
    
      
        U
      
    
    {\displaystyle U}
  
 over 
  
    
      
        H
      
    
    {\displaystyle H}
  
 if and only if 
  
    
      
        K
        â
        H
      
    
    {\displaystyle K\subseteq H}
  
 and 
  
    
      
        K
        â
        H
      
    
    {\displaystyle K\rightarrow H}
  
 holds in 
  
    
      
        U
      
    
    {\displaystyle U}
  
.
Candidate key
A candidate key is a superkey that cannot be further subdivided to form another superkey.

A superkey 
  
    
      
        K
      
    
    {\displaystyle K}
  
 holds as a candidate key for a relation universe 
  
    
      
        U
      
    
    {\displaystyle U}
  
 if it holds as a superkey for 
  
    
      
        U
      
    
    {\displaystyle U}
  
 and there is no proper subset of 
  
    
      
        K
      
    
    {\displaystyle K}
  
 that also holds as a superkey for 
  
    
      
        U
      
    
    {\displaystyle U}
  
.
Functional dependency
Functional dependency is the property that a value in a tuple may be derived from another value in that tuple.

A functional dependency (FD for short) is written as 
  
    
      
        X
        â
        Y
      
    
    {\displaystyle X\rightarrow Y}
  
 for 
  
    
      
        X
        ,
        Y
      
    
    {\displaystyle X,Y}
  
 finite sets of attribute names.
A functional dependency 
  
    
      
        X
        â
        Y
      
    
    {\displaystyle X\rightarrow Y}
  
 holds in a relation 
  
    
      
        (
        H
        ,
        B
        )
      
    
    {\displaystyle (H,B)}
  
 if:

  
    
      
        X
        ,
        Y
        â
        H
      
    
    {\displaystyle X,Y\subseteq H}
  
 and

  
    
      
        â
      
    
    {\displaystyle \forall }
  
 tuples 
  
    
      
        
          t
          
            1
          
        
        ,
        
          t
          
            2
          
        
        â
        B
      
    
    {\displaystyle t_{1},t_{2}\in B}
  
, 
  
    
      
        
          t
          
            1
          
        
        [
        X
        ]
        =
        
          t
          
            2
          
        
        [
        X
        ]
        Â 
        â
        Â 
        
          t
          
            1
          
        
        [
        Y
        ]
        =
        
          t
          
            2
          
        
        [
        Y
        ]
      
    
    {\displaystyle t_{1}[X]=t_{2}[X]~\Rightarrow ~t_{1}[Y]=t_{2}[Y]}
  

A functional dependency 
  
    
      
        X
        â
        Y
      
    
    {\displaystyle X\rightarrow Y}
  
 holds in a relation universe 
  
    
      
        U
      
    
    {\displaystyle U}
  
 if it holds in all relations in 
  
    
      
        U
      
    
    {\displaystyle U}
  
.
Trivial functional dependency
A functional dependency is trivial under a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 if it holds in all relation universes over 
  
    
      
        H
      
    
    {\displaystyle H}
  
.
Theorem: An FD 
  
    
      
        X
        â
        Y
      
    
    {\displaystyle X\rightarrow Y}
  
 is trivial under a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 if and only if 
  
    
      
        Y
        â
        X
        â
        H
      
    
    {\displaystyle Y\subseteq X\subseteq H}
  
.
Closure
Armstrong's axioms: The closure of a set of FDs 
  
    
      
        S
      
    
    {\displaystyle S}
  
 under a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
, written as 
  
    
      
        
          S
          
            +
          
        
      
    
    {\displaystyle S^{+}}
  
, is the smallest superset of 
  
    
      
        S
      
    
    {\displaystyle S}
  
 such that:

  
    
      
        Y
        â
        X
        â
        H
        Â 
        â
        Â 
        X
        â
        Y
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle Y\subseteq X\subseteq H~\Rightarrow ~X\rightarrow Y\in S^{+}}
  
 (reflexivity)

  
    
      
        X
        â
        Y
        â
        
          S
          
            +
          
        
        â§
        Y
        â
        Z
        â
        
          S
          
            +
          
        
        Â 
        â
        Â 
        X
        â
        Z
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle X\rightarrow Y\in S^{+}\land Y\rightarrow Z\in S^{+}~\Rightarrow ~X\rightarrow Z\in S^{+}}
  
 (transitivity) and

  
    
      
        X
        â
        Y
        â
        
          S
          
            +
          
        
        â§
        Z
        â
        H
        Â 
        â
        Â 
        (
        X
        âª
        Z
        )
        â
        (
        Y
        âª
        Z
        )
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle X\rightarrow Y\in S^{+}\land Z\subseteq H~\Rightarrow ~(X\cup Z)\rightarrow (Y\cup Z)\in S^{+}}
  
 (augmentation)
Theorem: Armstrong's axioms are sound and complete; given a header 
  
    
      
        H
      
    
    {\displaystyle H}
  
 and a set 
  
    
      
        S
      
    
    {\displaystyle S}
  
 of FDs that only contain subsets of 
  
    
      
        H
      
    
    {\displaystyle H}
  
, 
  
    
      
        X
        â
        Y
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle X\rightarrow Y\in S^{+}}
  
 if and only if 
  
    
      
        X
        â
        Y
      
    
    {\displaystyle X\rightarrow Y}
  
 holds in all relation universes over 
  
    
      
        H
      
    
    {\displaystyle H}
  
 in which all FDs in 
  
    
      
        S
      
    
    {\displaystyle S}
  
 hold.
Completion
The completion of a finite set of attributes 
  
    
      
        X
      
    
    {\displaystyle X}
  
 under a finite set of FDs 
  
    
      
        S
      
    
    {\displaystyle S}
  
, written as 
  
    
      
        
          X
          
            +
          
        
      
    
    {\displaystyle X^{+}}
  
, is the smallest superset of 
  
    
      
        X
      
    
    {\displaystyle X}
  
 such that:

  
    
      
        Y
        â
        Z
        â
        S
        â§
        Y
        â
        
          X
          
            +
          
        
        Â 
        â
        Â 
        Z
        â
        
          X
          
            +
          
        
      
    
    {\displaystyle Y\rightarrow Z\in S\land Y\subseteq X^{+}~\Rightarrow ~Z\subseteq X^{+}}
  

The completion of an attribute set can be used to compute if a certain dependency is in the closure of a set of FDs.
Theorem: Given a set 
  
    
      
        S
      
    
    {\displaystyle S}
  
 of FDs, 
  
    
      
        X
        â
        Y
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle X\rightarrow Y\in S^{+}}
  
 if and only if 
  
    
      
        Y
        â
        
          X
          
            +
          
        
      
    
    {\displaystyle Y\subseteq X^{+}}
  
.
Irreducible cover
An irreducible cover of a set 
  
    
      
        S
      
    
    {\displaystyle S}
  
 of FDs is a set 
  
    
      
        T
      
    
    {\displaystyle T}
  
 of FDs such that:

  
    
      
        
          S
          
            +
          
        
        =
        
          T
          
            +
          
        
      
    
    {\displaystyle S^{+}=T^{+}}
  

there exists no 
  
    
      
        U
        â
        T
      
    
    {\displaystyle U\subset T}
  
 such that 
  
    
      
        
          S
          
            +
          
        
        =
        
          U
          
            +
          
        
      
    
    {\displaystyle S^{+}=U^{+}}
  


  
    
      
        X
        â
        Y
        â
        T
        Â 
        â
        Y
      
    
    {\displaystyle X\rightarrow Y\in T~\Rightarrow Y}
  
 is a singleton set and

  
    
      
        X
        â
        Y
        â
        T
        â§
        Z
        â
        X
        Â 
        â
        Â 
        Z
        â
        Y
        â
        
          S
          
            +
          
        
      
    
    {\displaystyle X\rightarrow Y\in T\land Z\subset X~\Rightarrow ~Z\rightarrow Y\notin S^{+}}
  
.
Algorithm to derive candidate keys from functional dependencies[edit]
algorithm derive candidate keys from functional dependencies is
    input: a set S of FDs that contain only subsets of a header H
    output: the set C of superkeys that hold as candidate keys in
            all relation universes over H in which all FDs in S hold

    CÂ := â         // found candidate keys
    QÂ := { H }      // superkeys that contain candidate keys
    while Q <> â do
        let K be some element from Q
        QÂ := QÂ â { K }
        minimalÂ := true
        for each X->Y in S do
            K' := (KÂ â Y) âª X   // derive new superkey
            if K' â K then
                minimalÂ := false
                QÂ := Q âª { K' }
            end if
        end for
        if minimal and there is not a subset of K in C then
            remove all supersets of K from C
            CÂ := C âª { K }
        end if
    end while

See also[edit]
.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}
Domain relational calculus
List of relational database management systems
Query language
Database query language
Information retrieval query language
Relation
Relational database
Relational database management system
The Third Manifesto (TTM)
Tuple-versioning

References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Codd, E.F (1969), Derivability, Redundancy, and Consistency of Relations Stored in Large Data Banks, Research Report, IBM.

^ Jump up to: a b Codd, E.F (1970). "A Relational Model of Data for Large Shared Data Banks". Communications of the ACM. Classics. 13 (6): 377â87. doi:10.1145/362384.362685. S2CIDÂ 207549016. Archived from the original on 2007-06-12.

^ Codd, E. F (1990), The Relational Model for Database Management, Addison-Wesley, pp.Â 371â388, ISBNÂ 978-0-201-14192-4.

^ Date, Christopher J. (2006). "18. Why Three- and Four-Valued Logic Don't Work". Date on Database: Writings 2000â2006. Apress. pp.Â 329â41. ISBNÂ 978-1-59059-746-0.

^ Date, Christopher J. (2004). An Introduction to Database Systems (8Â ed.). Addison Wesley. pp.Â 592â97. ISBNÂ 978-0-321-19784-9.

^ David M. Kroenke, Database Processing: Fundamentals, Design, and Implementation (1997), Prentice-Hall, Inc., pages 130â144


Further reading[edit]
Date, Christopher J.; Darwen, Hugh (2000). Foundation for future database systems: the third manifesto; a detailed study of the impact of type theory on the relational model of data, including a comprehensive model of type inheritance (2Â ed.). Reading, MA: Addison-Wesley. ISBNÂ 978-0-201-70928-5.
âââ (2007). An Introduction to Database Systems (8Â ed.). Boston: Pearson Education. ISBNÂ 978-0-321-19784-9.
External links[edit]



Wikimedia Commons has media related to Relational models.

Childs (1968), Feasibility of a set-theoretic data structure: a general structure based on a reconstituted definition of relation (research), Handle, hdl:2027.42/4164 cited in Codd's 1970 paper.
Darwen, Hugh, The Third Manifesto (TTM).
Relational Databases at Curlie
"Relational Model", C2.
Binary relations and tuples compared with respect to the semantic web (World Wide Web log), Sun.
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}show.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteDatabase modelsCommon models
Flat
Hierarchical
Dimensional
Network
Relational
Entityârelationship
Enhanced
Graph
Object-oriented
Entityâattributeâvalue
Other models
Correlational
Multidimensional
Array
Semantic
Star schema
XML database
Implementations
Flat file
Column-oriented
Document-oriented
Objectârelational
Deductive
Temporal
XML data store
Keyâvalue store
Triplestore

showvteDatabase management systemsTypes
Object-oriented
comparison
Relational
list
comparison
Keyâvalue
Column-oriented
list
Document-oriented
Wide-column store
Graph
NoSQL
NewSQL
In-memory
list
Multi-model
comparison
Cloud
Concepts
Database
ACID
Armstrong's axioms
Codd's 12 rules
CAP theorem
CRUD
Null
Candidate key
Foreign key
Superkey
Surrogate key
Unique key
Objects
Relation
table
column
row
View
Transaction
Transaction log
Trigger
Index
Stored procedure
Cursor
Partition
Components
Concurrency control
Data dictionary
JDBC
XQJ
ODBC
Query language
Query optimizer
Query rewriting system
Query plan
Functions
Administration
Query optimization
Replication
Sharding
Related topics
Database models
Database normalization
Database storage
Distributed database
Federated database system
Referential integrity
Relational algebra
Relational calculus
Relational database
Relational model
Objectârelational database
Transaction processing

 Category
 Outline
 WikiProject





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Relational_model&oldid=1045600197"
		Categories: Database management systemsRelational model1969 in computingProgramming paradigmsHidden categories: Articles with short descriptionShort description matches WikidataArticles containing potentially dated statements from October 2015All articles containing potentially dated statementsAll articles with unsourced statementsArticles with unsourced statements from August 2016Articles with unsourced statements from April 2021Articles with unsourced statements from February 2007Articles with unsourced statements from August 2010Articles needing additional references from February 2013All articles needing additional referencesArticles with specifically marked weasel-worded phrases from September 2011Articles with unsourced statements from July 2009Commons category link is on WikidataArticles with Curlie linksArticles with example pseudocode
	
