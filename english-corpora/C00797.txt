
Title:
Online machine learning
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Not to be confused with online and offline.
Method of machine learning
.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Part of a series onMachine learningand data mining
hideProblems
Classification
Clustering
Regression
Anomaly detection
Data Cleaning
AutoML
Association rules
Reinforcement learning
Structured prediction
Feature engineering
Feature learning
Online learning
Semi-supervised learning
Unsupervised learning
Learning to rank
Grammar induction

showSupervised learning.mw-parser-output .nobold{font-weight:normal}(classificationÂ â¢ regression) 
Decision trees
Ensembles
Bagging
Boosting
Random forest
k-NN
Linear regression
Naive Bayes
Artificial neural networks
Logistic regression
Perceptron
Relevance vector machine (RVM)
Support vector machine (SVM)

showClustering
BIRCH
CURE
Hierarchical
k-means
Expectationâmaximization (EM)
DBSCAN
OPTICS
Mean shift

showDimensionality reduction
Factor analysis
CCA
ICA
LDA
NMF
PCA
PGD
t-SNE

showStructured prediction
Graphical models
Bayes net
Conditional random field
Hidden Markov

showAnomaly detection
k-NN
Local outlier factor

showArtificial neural network
Autoencoder
Cognitive computing
Deep learning
DeepDream
Multilayer perceptron
RNN
LSTM
GRU
ESN
Restricted Boltzmann machine
GAN
SOM
Convolutional neural network
U-Net
Transformer
Vision
Spiking neural network
Memtransistor
Electrochemical RAM (ECRAM)

showReinforcement learning
Q-learning
SARSA
Temporal difference (TD)

showTheory
Kernel machines
Biasâvariance tradeoff
Computational learning theory
Empirical risk minimization
Occam learning
PAC learning
Statistical learning
VC theory

showMachine-learning venues
NeurIPS
ICML
ML
JMLR
ArXiv:cs.LG

showRelated articles
Glossary of artificial intelligence
List of datasets for machine-learning research
Outline of machine learning
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
In computer science, online machine learning is a method of machine learning in which data becomes available in a sequential order and is used to update the best predictor for future data at each step, as opposed to batch learning techniques which generate the best predictor by learning on the entire training data set at once. Online learning is a common technique used in areas of machine learning where it is computationally infeasible to train over the entire dataset, requiring the need of out-of-core algorithms. It is also used in situations where it is necessary for the algorithm to dynamically adapt to new patterns in the data, or when the data itself is generated as a function of time, e.g., stock price prediction.
Online learning algorithms may be prone to catastrophic interference, a problem that can be addressed by incremental learning approaches.

Contents

1 Introduction
2 Statistical view of online learning

2.1 Example: linear least squares
2.2 Batch learning
2.3 Online learning: recursive least squares
2.4 Stochastic gradient descent
2.5 Incremental stochastic gradient descent
2.6 Kernel methods
2.7 Online convex optimization

2.7.1 Follow the leader (FTL)
2.7.2 Follow the regularised leader (FTRL)


2.8 Online subgradient descent (OSD)
2.9 Other algorithms


3 Continual learning
4 Interpretations of online learning
5 Implementations
6 See also
7 References
8 External links



Introduction[edit]
In the setting of supervised learning, a function of 
  
    
      
        f
        :
        X
        â
        Y
      
    
    {\displaystyle f:X\to Y}
  
 is to be learned, where 
  
    
      
        X
      
    
    {\displaystyle X}
  
 is thought of as a space of inputs and 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
 as a space of outputs, that predicts well on instances that are drawn from a joint probability distribution 
  
    
      
        p
        (
        x
        ,
        y
        )
      
    
    {\displaystyle p(x,y)}
  
 on 
  
    
      
        X
        Ã
        Y
      
    
    {\displaystyle X\times Y}
  
. In reality, the learner never knows the true distribution 
  
    
      
        p
        (
        x
        ,
        y
        )
      
    
    {\displaystyle p(x,y)}
  
 over instances. Instead, the learner usually has access to a training set of examples 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          y
          
            1
          
        
        )
        ,
        â¦
        ,
        (
        
          x
          
            n
          
        
        ,
        
          y
          
            n
          
        
        )
      
    
    {\displaystyle (x_{1},y_{1}),\ldots ,(x_{n},y_{n})}
  
. In this setting, the loss function is given as 
  
    
      
        V
        :
        Y
        Ã
        Y
        â
        
          R
        
      
    
    {\displaystyle V:Y\times Y\to \mathbb {R} }
  
, such that 
  
    
      
        V
        (
        f
        (
        x
        )
        ,
        y
        )
      
    
    {\displaystyle V(f(x),y)}
  
 measures the difference between the predicted value 
  
    
      
        f
        (
        x
        )
      
    
    {\displaystyle f(x)}
  
 and the true value 
  
    
      
        y
      
    
    {\displaystyle y}
  
. The ideal goal is to select a function 
  
    
      
        f
        â
        
          
            H
          
        
      
    
    {\displaystyle f\in {\mathcal {H}}}
  
, where 
  
    
      
        
          
            H
          
        
      
    
    {\displaystyle {\mathcal {H}}}
  
 is a space of functions called a hypothesis space, so that some notion of total loss is minimised. Depending on the type of model (statistical or adversarial), one can devise different notions of loss, which lead to different learning algorithms.

Statistical view of online learning[edit]
In statistical learning models, the training sample 
  
    
      
        (
        
          x
          
            i
          
        
        ,
        
          y
          
            i
          
        
        )
      
    
    {\displaystyle (x_{i},y_{i})}
  
 are assumed to have been drawn from the true distribution 
  
    
      
        p
        (
        x
        ,
        y
        )
      
    
    {\displaystyle p(x,y)}
  
 and the objective is to minimize the expected "risk"


  
    
      
        I
        [
        f
        ]
        =
        
          E
        
        [
        V
        (
        f
        (
        x
        )
        ,
        y
        )
        ]
        =
        â«
        V
        (
        f
        (
        x
        )
        ,
        y
        )
        
        d
        p
        (
        x
        ,
        y
        )
        Â 
        .
      
    
    {\displaystyle I[f]=\mathbb {E} [V(f(x),y)]=\int V(f(x),y)\,dp(x,y)\ .}
  

A common paradigm in this situation is to estimate a function 
  
    
      
        
          
            
              f
              ^
            
          
        
      
    
    {\displaystyle {\hat {f}}}
  
 through empirical risk minimization or regularized empirical risk minimization (usually Tikhonov regularization). The choice of loss function here gives rise to several well-known learning algorithms such as regularized least squares and support vector machines.
A purely online model in this category would learn based on just the new input 
  
    
      
        (
        
          x
          
            t
            +
            1
          
        
        ,
        
          y
          
            t
            +
            1
          
        
        )
      
    
    {\displaystyle (x_{t+1},y_{t+1})}
  
, the current best predictor 
  
    
      
        
          f
          
            t
          
        
      
    
    {\displaystyle f_{t}}
  
 and some extra stored information (which is usually expected to have storage requirements independent of training data size). For many formulations, for example nonlinear kernel methods, true online learning is not possible, though a form of hybrid online learning with recursive algorithms can be used where 
  
    
      
        
          f
          
            t
            +
            1
          
        
      
    
    {\displaystyle f_{t+1}}
  
 is permitted to depend on 
  
    
      
        
          f
          
            t
          
        
      
    
    {\displaystyle f_{t}}
  
 and all previous data points 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          y
          
            1
          
        
        )
        ,
        â¦
        ,
        (
        
          x
          
            t
          
        
        ,
        
          y
          
            t
          
        
        )
      
    
    {\displaystyle (x_{1},y_{1}),\ldots ,(x_{t},y_{t})}
  
. In this case, the space requirements are no longer guaranteed to be constant since it requires storing all previous data points, but the solution may take less time to compute with the addition of a new data point, as compared to batch learning techniques.
A common strategy to overcome the above issues is to learn using mini-batches, which process a small batch of 
  
    
      
        b
        â¥
        1
      
    
    {\displaystyle b\geq 1}
  
 data points at a time, this can be considered as pseudo-online learning for 
  
    
      
        b
      
    
    {\displaystyle b}
  
 much smaller than the total number of training points. Mini-batch techniques are used with repeated passing over the training data to obtain optimized out-of-core[clarification needed] versions of machine learning algorithms, for example, stochastic gradient descent. When combined with backpropagation, this is currently the de facto training method for training artificial neural networks.

Example: linear least squares[edit]
Main article: Linear least squares (mathematics)
The simple example of linear least squares is used to explain a variety of ideas in online learning. The ideas are general enough to be applied to other settings, for example, with other convex loss functions.

Batch learning[edit]
Consider the setting of supervised learning with 
  
    
      
        f
      
    
    {\displaystyle f}
  
 being a linear function to be learned:


  
    
      
        f
        (
        
          x
          
            j
          
        
        )
        =
        â¨
        w
        ,
        
          x
          
            j
          
        
        â©
        =
        w
        â
        
          x
          
            j
          
        
      
    
    {\displaystyle f(x_{j})=\langle w,x_{j}\rangle =w\cdot x_{j}}
  

where 
  
    
      
        
          x
          
            j
          
        
        â
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle x_{j}\in \mathbb {R} ^{d}}
  
 is a vector of inputs (data points) and 
  
    
      
        w
        â
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle w\in \mathbb {R} ^{d}}
  
 is a linear filter vector.
The goal is to compute the filter vector 
  
    
      
        w
      
    
    {\displaystyle w}
  
.
To this end, a square loss function 


  
    
      
        V
        (
        f
        (
        
          x
          
            j
          
        
        )
        ,
        
          y
          
            j
          
        
        )
        =
        (
        f
        (
        
          x
          
            j
          
        
        )
        â
        
          y
          
            j
          
        
        
          )
          
            2
          
        
        =
        (
        â¨
        w
        ,
        
          x
          
            j
          
        
        â©
        â
        
          y
          
            j
          
        
        
          )
          
            2
          
        
      
    
    {\displaystyle V(f(x_{j}),y_{j})=(f(x_{j})-y_{j})^{2}=(\langle w,x_{j}\rangle -y_{j})^{2}}
  

is used to compute the vector 
  
    
      
        w
      
    
    {\displaystyle w}
  
 that minimizes the empirical loss


  
    
      
        
          I
          
            n
          
        
        [
        w
        ]
        =
        
          â
          
            j
            =
            1
          
          
            n
          
        
        V
        (
        â¨
        w
        ,
        
          x
          
            j
          
        
        â©
        ,
        
          y
          
            j
          
        
        )
        =
        
          â
          
            j
            =
            1
          
          
            n
          
        
        (
        
          x
          
            j
          
          
            T
          
        
        w
        â
        
          y
          
            j
          
        
        
          )
          
            2
          
        
      
    
    {\displaystyle I_{n}[w]=\sum _{j=1}^{n}V(\langle w,x_{j}\rangle ,y_{j})=\sum _{j=1}^{n}(x_{j}^{T}w-y_{j})^{2}}
  

where


  
    
      
        
          y
          
            j
          
        
        â
        
          R
        
      
    
    {\displaystyle y_{j}\in \mathbb {R} }
  
.
Let  
  
    
      
        X
      
    
    {\displaystyle X}
  
 be the 
  
    
      
        i
        Ã
        d
      
    
    {\displaystyle i\times d}
  
 data matrix and 
  
    
      
        y
        â
        
          
            R
          
          
            i
          
        
      
    
    {\displaystyle y\in \mathbb {R} ^{i}}
  
 is the column vector of target values after the arrival of the first 
  
    
      
        i
      
    
    {\displaystyle i}
  
 data points.
Assuming that the covariance matrix 
  
    
      
        
          Î£
          
            i
          
        
        =
        
          X
          
            T
          
        
        X
      
    
    {\displaystyle \Sigma _{i}=X^{T}X}
  
 is invertible (otherwise it is preferential to proceed in a similar fashion with Tikhonov regularization), the best solution 
  
    
      
        
          f
          
            â
          
        
        (
        x
        )
        =
        â¨
        
          w
          
            â
          
        
        ,
        x
        â©
      
    
    {\displaystyle f^{*}(x)=\langle w^{*},x\rangle }
  
 to the linear least squares problem is given by


  
    
      
        
          w
          
            â
          
        
        =
        (
        
          X
          
            T
          
        
        X
        
          )
          
            â
            1
          
        
        
          X
          
            T
          
        
        y
        =
        
          Î£
          
            i
          
          
            â
            1
          
        
        
          â
          
            j
            =
            1
          
          
            i
          
        
        
          x
          
            j
          
        
        
          y
          
            j
          
        
      
    
    {\displaystyle w^{*}=(X^{T}X)^{-1}X^{T}y=\Sigma _{i}^{-1}\sum _{j=1}^{i}x_{j}y_{j}}
  
.
Now, calculating the covariance matrix 
  
    
      
        
          Î£
          
            i
          
        
        =
        
          â
          
            j
            =
            1
          
          
            i
          
        
        
          x
          
            j
          
        
        
          x
          
            j
          
          
            T
          
        
      
    
    {\displaystyle \Sigma _{i}=\sum _{j=1}^{i}x_{j}x_{j}^{T}}
  
 takes time 
  
    
      
        O
        (
        i
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(id^{2})}
  
, inverting the 
  
    
      
        d
        Ã
        d
      
    
    {\displaystyle d\times d}
  
 matrix takes time 
  
    
      
        O
        (
        
          d
          
            3
          
        
        )
      
    
    {\displaystyle O(d^{3})}
  
, while the rest of the multiplication takes time 
  
    
      
        O
        (
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(d^{2})}
  
, giving a total time of 
  
    
      
        O
        (
        i
        
          d
          
            2
          
        
        +
        
          d
          
            3
          
        
        )
      
    
    {\displaystyle O(id^{2}+d^{3})}
  
. When there are 
  
    
      
        n
      
    
    {\displaystyle n}
  
 total points in the dataset, to recompute the solution after the arrival of every datapoint 
  
    
      
        i
        =
        1
        ,
        â¦
        ,
        n
      
    
    {\displaystyle i=1,\ldots ,n}
  
, the naive approach will have a total complexity 
  
    
      
        O
        (
        
          n
          
            2
          
        
        
          d
          
            2
          
        
        +
        n
        
          d
          
            3
          
        
        )
      
    
    {\displaystyle O(n^{2}d^{2}+nd^{3})}
  
. Note that when storing the matrix 
  
    
      
        
          Î£
          
            i
          
        
      
    
    {\displaystyle \Sigma _{i}}
  
, then updating it at each step needs only adding 
  
    
      
        
          x
          
            i
            +
            1
          
        
        
          x
          
            i
            +
            1
          
          
            T
          
        
      
    
    {\displaystyle x_{i+1}x_{i+1}^{T}}
  
, which takes 
  
    
      
        O
        (
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(d^{2})}
  
 time, reducing the total time to 
  
    
      
        O
        (
        n
        
          d
          
            2
          
        
        +
        n
        
          d
          
            3
          
        
        )
        =
        O
        (
        n
        
          d
          
            3
          
        
        )
      
    
    {\displaystyle O(nd^{2}+nd^{3})=O(nd^{3})}
  
, but with an additional storage space of 
  
    
      
        O
        (
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(d^{2})}
  
 to store 
  
    
      
        
          Î£
          
            i
          
        
      
    
    {\displaystyle \Sigma _{i}}
  
.[1]

Online learning: recursive least squares[edit]
The recursive least squares (RLS) algorithm considers an online approach to the least squares problem. It can be shown that by initialising 
  
    
      
        
          
            w
            
              0
            
          
          =
          0
          â
          
            
              R
            
            
              d
            
          
        
      
    
    {\displaystyle \textstyle w_{0}=0\in \mathbb {R} ^{d}}
  
 and 
  
    
      
        
          
            Î
            
              0
            
          
          =
          I
          â
          
            
              R
            
            
              d
              Ã
              d
            
          
        
      
    
    {\displaystyle \textstyle \Gamma _{0}=I\in \mathbb {R} ^{d\times d}}
  
, the solution of the linear least squares problem given in the previous section can be computed by the following iteration:


  
    
      
        
          Î
          
            i
          
        
        =
        
          Î
          
            i
            â
            1
          
        
        â
        
          
            
              
                Î
                
                  i
                  â
                  1
                
              
              
                x
                
                  i
                
              
              
                x
                
                  i
                
                
                  T
                
              
              
                Î
                
                  i
                  â
                  1
                
              
            
            
              1
              +
              
                x
                
                  i
                
                
                  T
                
              
              
                Î
                
                  i
                  â
                  1
                
              
              
                x
                
                  i
                
              
            
          
        
      
    
    {\displaystyle \Gamma _{i}=\Gamma _{i-1}-{\frac {\Gamma _{i-1}x_{i}x_{i}^{T}\Gamma _{i-1}}{1+x_{i}^{T}\Gamma _{i-1}x_{i}}}}
  


  
    
      
        
          w
          
            i
          
        
        =
        
          w
          
            i
            â
            1
          
        
        â
        
          Î
          
            i
          
        
        
          x
          
            i
          
        
        (
        
          x
          
            i
          
          
            T
          
        
        
          w
          
            i
            â
            1
          
        
        â
        
          y
          
            i
          
        
        )
      
    
    {\displaystyle w_{i}=w_{i-1}-\Gamma _{i}x_{i}(x_{i}^{T}w_{i-1}-y_{i})}
  

The above iteration algorithm can be proved using induction on 
  
    
      
        i
      
    
    {\displaystyle i}
  
.[2] The proof also shows that 
  
    
      
        
          Î
          
            i
          
        
        =
        
          Î£
          
            i
          
          
            â
            1
          
        
      
    
    {\displaystyle \Gamma _{i}=\Sigma _{i}^{-1}}
  
. 
One can look at RLS also in the context of adaptive filters (see RLS).
The complexity for 
  
    
      
        n
      
    
    {\displaystyle n}
  
 steps of this algorithm is 
  
    
      
        O
        (
        n
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(nd^{2})}
  
, which is an order of magnitude faster than the corresponding batch learning complexity. The storage requirements at every step 
  
    
      
        i
      
    
    {\displaystyle i}
  
 here are to store the matrix 
  
    
      
        
          Î
          
            i
          
        
      
    
    {\displaystyle \Gamma _{i}}
  
, which is constant at 
  
    
      
        O
        (
        
          d
          
            2
          
        
        )
      
    
    {\displaystyle O(d^{2})}
  
. For the case when 
  
    
      
        
          Î£
          
            i
          
        
      
    
    {\displaystyle \Sigma _{i}}
  
 is not invertible, consider the regularised version of the problem 
loss function 
  
    
      
        
          â
          
            j
            =
            1
          
          
            n
          
        
        (
        
          x
          
            j
          
          
            T
          
        
        w
        â
        
          y
          
            j
          
        
        
          )
          
            2
          
        
        +
        Î»
        
          |
        
        
          |
        
        w
        
          |
        
        
          
            |
          
          
            2
          
          
            2
          
        
      
    
    {\displaystyle \sum _{j=1}^{n}(x_{j}^{T}w-y_{j})^{2}+\lambda ||w||_{2}^{2}}
  
. Then, it's easy to show that the same algorithm works with 
  
    
      
        
          Î
          
            0
          
        
        =
        (
        I
        +
        Î»
        I
        
          )
          
            â
            1
          
        
      
    
    {\displaystyle \Gamma _{0}=(I+\lambda I)^{-1}}
  
, and the iterations proceed to give 
  
    
      
        
          Î
          
            i
          
        
        =
        (
        
          Î£
          
            i
          
        
        +
        Î»
        I
        
          )
          
            â
            1
          
        
      
    
    {\displaystyle \Gamma _{i}=(\Sigma _{i}+\lambda I)^{-1}}
  
.[1]

Stochastic gradient descent[edit]
Main article: Stochastic gradient descent
When this  


  
    
      
        
          
            w
            
              i
            
          
          =
          
            w
            
              i
              â
              1
            
          
          â
          
            Î
            
              i
            
          
          
            x
            
              i
            
          
          (
          
            x
            
              i
            
            
              T
            
          
          
            w
            
              i
              â
              1
            
          
          â
          
            y
            
              i
            
          
          )
        
      
    
    {\displaystyle \textstyle w_{i}=w_{i-1}-\Gamma _{i}x_{i}(x_{i}^{T}w_{i-1}-y_{i})}
  

is replaced by


  
    
      
        
          
            w
            
              i
            
          
          =
          
            w
            
              i
              â
              1
            
          
          â
          
            Î³
            
              i
            
          
          
            x
            
              i
            
          
          (
          
            x
            
              i
            
            
              T
            
          
          
            w
            
              i
              â
              1
            
          
          â
          
            y
            
              i
            
          
          )
          =
          
            w
            
              i
              â
              1
            
          
          â
          
            Î³
            
              i
            
          
          â
          V
          (
          â¨
          
            w
            
              i
              â
              1
            
          
          ,
          
            x
            
              i
            
          
          â©
          ,
          
            y
            
              i
            
          
          )
        
      
    
    {\displaystyle \textstyle w_{i}=w_{i-1}-\gamma _{i}x_{i}(x_{i}^{T}w_{i-1}-y_{i})=w_{i-1}-\gamma _{i}\nabla V(\langle w_{i-1},x_{i}\rangle ,y_{i})}
  

or 
  
    
      
        
          Î
          
            i
          
        
        â
        
          
            R
          
          
            d
            Ã
            d
          
        
      
    
    {\displaystyle \Gamma _{i}\in \mathbb {R} ^{d\times d}}
  
 by 
  
    
      
        
          Î³
          
            i
          
        
        â
        
          R
        
      
    
    {\displaystyle \gamma _{i}\in \mathbb {R} }
  
, this becomes the stochastic gradient descent algorithm. In this case, the complexity for 
  
    
      
        n
      
    
    {\displaystyle n}
  
 steps of this algorithm reduces to 
  
    
      
        O
        (
        n
        d
        )
      
    
    {\displaystyle O(nd)}
  
. The storage requirements at every step 
  
    
      
        i
      
    
    {\displaystyle i}
  
 are constant at 
  
    
      
        O
        (
        d
        )
      
    
    {\displaystyle O(d)}
  
.
However, the stepsize 
  
    
      
        
          Î³
          
            i
          
        
      
    
    {\displaystyle \gamma _{i}}
  
 needs to be chosen carefully to solve the expected risk minimization problem, as detailed above. By choosing a decaying step size 
  
    
      
        
          Î³
          
            i
          
        
        â
        
          
            1
            
              i
            
          
        
        ,
      
    
    {\displaystyle \gamma _{i}\approx {\frac {1}{\sqrt {i}}},}
  
 one can prove the convergence of the average iterate 
  
    
      
        
          
            
              w
              Â¯
            
          
          
            n
          
        
        =
        
          
            1
            n
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        
          w
          
            i
          
        
      
    
    {\displaystyle {\overline {w}}_{n}={\frac {1}{n}}\sum _{i=1}^{n}w_{i}}
  
. This setting is a special case of stochastic optimization, a well known problem in optimization.[1]

Incremental stochastic gradient descent[edit]
In practice, one can perform multiple stochastic gradient passes (also called cycles or epochs) over the data. The algorithm thus obtained is
called incremental gradient method and corresponds to an iteration


  
    
      
        
          
            w
            
              i
            
          
          =
          
            w
            
              i
              â
              1
            
          
          â
          
            Î³
            
              i
            
          
          â
          V
          (
          â¨
          
            w
            
              i
              â
              1
            
          
          ,
          
            x
            
              
                t
                
                  i
                
              
            
          
          â©
          ,
          
            y
            
              
                t
                
                  i
                
              
            
          
          )
        
      
    
    {\displaystyle \textstyle w_{i}=w_{i-1}-\gamma _{i}\nabla V(\langle w_{i-1},x_{t_{i}}\rangle ,y_{t_{i}})}
  

The main difference with the stochastic gradient method is that here a sequence 
  
    
      
        
          t
          
            i
          
        
      
    
    {\displaystyle t_{i}}
  
 is chosen to decide which training point is visited in the 
  
    
      
        i
      
    
    {\displaystyle i}
  
-th step. Such a sequence can be stochastic or deterministic. The number of iterations is then decoupled to the number of points (each point can be considered more than once). The incremental gradient method can be shown to provide a minimizer to the empirical risk.[3] Incremental techniques can be advantageous when considering objective functions made up of a sum of many terms e.g. an empirical error corresponding to a very large dataset.[1]

Kernel methods[edit]
See also: Kernel method
Kernels can be used to extend the above algorithms to non-parametric models (or models where the parameters form an infinite dimensional space). The corresponding procedure will no longer be truly online and instead involve storing all the data points, but is still faster than the brute force method.
This discussion is restricted to the case of the square loss, though it can be extended to any convex loss. It can be shown by an easy induction [1] that if 
  
    
      
        
          X
          
            i
          
        
      
    
    {\displaystyle X_{i}}
  
 is the data matrix and 
  
    
      
        
          w
          
            i
          
        
      
    
    {\displaystyle w_{i}}
  
 is the output after 
  
    
      
        i
      
    
    {\displaystyle i}
  
 steps of the SGD algorithm, then,


  
    
      
        
          w
          
            i
          
        
        =
        
          X
          
            i
          
          
            T
          
        
        
          c
          
            i
          
        
      
    
    {\displaystyle w_{i}=X_{i}^{T}c_{i}}
  

where 
  
    
      
        
          
            c
            
              i
            
          
          =
          (
          (
          
            c
            
              i
            
          
          
            )
            
              1
            
          
          ,
          (
          
            c
            
              i
            
          
          
            )
            
              2
            
          
          ,
          .
          .
          .
          ,
          (
          
            c
            
              i
            
          
          
            )
            
              i
            
          
          )
          â
          
            
              R
            
            
              i
            
          
        
      
    
    {\displaystyle \textstyle c_{i}=((c_{i})_{1},(c_{i})_{2},...,(c_{i})_{i})\in \mathbb {R} ^{i}}
  
 and the sequence 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
 satisfies the recursion:


  
    
      
        
          c
          
            0
          
        
        =
        0
      
    
    {\displaystyle c_{0}=0}
  


  
    
      
        (
        
          c
          
            i
          
        
        
          )
          
            j
          
        
        =
        (
        
          c
          
            i
            â
            1
          
        
        
          )
          
            j
          
        
        ,
        j
        =
        1
        ,
        2
        ,
        .
        .
        .
        ,
        i
        â
        1
      
    
    {\displaystyle (c_{i})_{j}=(c_{i-1})_{j},j=1,2,...,i-1}
  
 and

  
    
      
        (
        
          c
          
            i
          
        
        
          )
          
            i
          
        
        =
        
          Î³
          
            i
          
        
        
          
            (
          
        
        
          y
          
            i
          
        
        â
        
          â
          
            j
            =
            1
          
          
            i
            â
            1
          
        
        (
        
          c
          
            i
            â
            1
          
        
        
          )
          
            j
          
        
        â¨
        
          x
          
            j
          
        
        ,
        
          x
          
            i
          
        
        â©
        
          
            )
          
        
      
    
    {\displaystyle (c_{i})_{i}=\gamma _{i}{\Big (}y_{i}-\sum _{j=1}^{i-1}(c_{i-1})_{j}\langle x_{j},x_{i}\rangle {\Big )}}
  

Notice that here 
  
    
      
        â¨
        
          x
          
            j
          
        
        ,
        
          x
          
            i
          
        
        â©
      
    
    {\displaystyle \langle x_{j},x_{i}\rangle }
  
 is just the standard Kernel on 
  
    
      
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle \mathbb {R} ^{d}}
  
, and the predictor is of the form 


  
    
      
        
          f
          
            i
          
        
        (
        x
        )
        =
        â¨
        
          w
          
            i
            â
            1
          
        
        ,
        x
        â©
        =
        
          â
          
            j
            =
            1
          
          
            i
            â
            1
          
        
        (
        
          c
          
            i
            â
            1
          
        
        
          )
          
            j
          
        
        â¨
        
          x
          
            j
          
        
        ,
        x
        â©
      
    
    {\displaystyle f_{i}(x)=\langle w_{i-1},x\rangle =\sum _{j=1}^{i-1}(c_{i-1})_{j}\langle x_{j},x\rangle }
  
.
Now, if  a general kernel 
  
    
      
        K
      
    
    {\displaystyle K}
  
 is introduced instead and let the predictor be 


  
    
      
        
          f
          
            i
          
        
        (
        x
        )
        =
        
          â
          
            j
            =
            1
          
          
            i
            â
            1
          
        
        (
        
          c
          
            i
            â
            1
          
        
        
          )
          
            j
          
        
        K
        (
        
          x
          
            j
          
        
        ,
        x
        )
      
    
    {\displaystyle f_{i}(x)=\sum _{j=1}^{i-1}(c_{i-1})_{j}K(x_{j},x)}
  

then the same proof will also show that predictor minimising the least squares loss is obtained by changing the above recursion to


  
    
      
        (
        
          c
          
            i
          
        
        
          )
          
            i
          
        
        =
        
          Î³
          
            i
          
        
        
          
            (
          
        
        
          y
          
            i
          
        
        â
        
          â
          
            j
            =
            1
          
          
            i
            â
            1
          
        
        (
        
          c
          
            i
            â
            1
          
        
        
          )
          
            j
          
        
        K
        (
        
          x
          
            j
          
        
        ,
        
          x
          
            i
          
        
        )
        
          
            )
          
        
      
    
    {\displaystyle (c_{i})_{i}=\gamma _{i}{\Big (}y_{i}-\sum _{j=1}^{i-1}(c_{i-1})_{j}K(x_{j},x_{i}){\Big )}}
  

The above expression requires storing all the data for updating 
  
    
      
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{i}}
  
. The total time complexity for the recursion when evaluating for the 
  
    
      
        n
      
    
    {\displaystyle n}
  
-th datapoint is 
  
    
      
        O
        (
        
          n
          
            2
          
        
        d
        k
        )
      
    
    {\displaystyle O(n^{2}dk)}
  
, where 
  
    
      
        k
      
    
    {\displaystyle k}
  
 is the cost of evaluating the kernel on a single pair of points.[1]
Thus, the use of the kernel has allowed the movement from a finite dimensional parameter space 
  
    
      
        
          
            w
            
              i
            
          
          â
          
            
              R
            
            
              d
            
          
        
      
    
    {\displaystyle \textstyle w_{i}\in \mathbb {R} ^{d}}
  
 to a possibly infinite dimensional feature represented by a kernel 
  
    
      
        K
      
    
    {\displaystyle K}
  
 by instead performing the recursion on the space of parameters 
  
    
      
        
          
            c
            
              i
            
          
          â
          
            
              R
            
            
              i
            
          
        
      
    
    {\displaystyle \textstyle c_{i}\in \mathbb {R} ^{i}}
  
, whose dimension is the same as the size of the training dataset. In general, this is a consequence of the representer theorem.[1]

Online convex optimization[edit]
Online convex optimization (OCO) [4] is a general framework for decision making which leverages convex optimization to allow for efficient algorithms. The framework is that of repeated game playing as follows:
For 
  
    
      
        t
        =
        1
        ,
        2
        ,
        .
        .
        .
        ,
        T
      
    
    {\displaystyle t=1,2,...,T}
  


Learner receives input 
  
    
      
        
          x
          
            t
          
        
      
    
    {\displaystyle x_{t}}
  

Learner outputs 
  
    
      
        
          w
          
            t
          
        
      
    
    {\displaystyle w_{t}}
  
 from a fixed convex set 
  
    
      
        S
      
    
    {\displaystyle S}
  

Nature sends back a convex loss function 
  
    
      
        
          v
          
            t
          
        
        :
        S
        â
        
          R
        
      
    
    {\displaystyle v_{t}:S\rightarrow \mathbb {R} }
  
.
Learner suffers loss 
  
    
      
        
          v
          
            t
          
        
        (
        
          w
          
            t
          
        
        )
      
    
    {\displaystyle v_{t}(w_{t})}
  
 and updates its model
The goal is to minimize regret, or the difference between cumulative loss and the loss of the best fixed point  
  
    
      
        u
        â
        S
      
    
    {\displaystyle u\in S}
  
 in hindsight.
As an example, consider the case of online least squares linear regression. Here, the weight vectors come from the convex set 
  
    
      
        S
        =
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle S=\mathbb {R} ^{d}}
  
, and nature sends back the convex loss function 
  
    
      
        
          v
          
            t
          
        
        (
        w
        )
        =
        (
        â¨
        w
        ,
        
          x
          
            t
          
        
        â©
        â
        
          y
          
            t
          
        
        
          )
          
            2
          
        
      
    
    {\displaystyle v_{t}(w)=(\langle w,x_{t}\rangle -y_{t})^{2}}
  
. Note here that 
  
    
      
        
          y
          
            t
          
        
      
    
    {\displaystyle y_{t}}
  
 is implicitly sent with 
  
    
      
        
          v
          
            t
          
        
      
    
    {\displaystyle v_{t}}
  
.
Some online prediction problems however cannot fit in the framework of OCO. For example, in online classification, the prediction domain and the loss functions are not convex. In such scenarios, two simple techniques for convexification are used: randomisation and surrogate loss functions[citation needed].
Some simple online convex optimisation algorithms are:

Follow the leader (FTL)[edit]
The simplest learning rule to try is to select (at the current step) the hypothesis that has the least loss over all past rounds. This algorithm is called Follow the leader, and is simply given round 
  
    
      
        t
      
    
    {\displaystyle t}
  
 by:


  
    
      
        
          w
          
            t
          
        
        =
        
          
            a
            r
            g
            
            m
            i
            n
          
          
            w
            â
            S
          
        
        â¡
        
          â
          
            i
            =
            1
          
          
            t
            â
            1
          
        
        
          v
          
            i
          
        
        (
        w
        )
      
    
    {\displaystyle w_{t}=\operatorname {arg\,min} _{w\in S}\sum _{i=1}^{t-1}v_{i}(w)}
  

This method can thus be looked as a greedy algorithm. For the case of online quadratic optimization (where the loss function is 
  
    
      
        
          v
          
            t
          
        
        (
        w
        )
        =
        
          |
        
        
          |
        
        w
        â
        
          x
          
            t
          
        
        
          |
        
        
          
            |
          
          
            2
          
          
            2
          
        
      
    
    {\displaystyle v_{t}(w)=||w-x_{t}||_{2}^{2}}
  
), one can show a regret bound that grows as 
  
    
      
        log
        â¡
        (
        T
        )
      
    
    {\displaystyle \log(T)}
  
. However, similar bounds cannot be obtained for the FTL algorithm for other important families of models like online linear optimization. To do so, one modifies FTL by adding regularisation.

Follow the regularised leader (FTRL)[edit]
This is a natural modification of FTL that is used to stabilise the FTL solutions and obtain better regret bounds. A regularisation function 
  
    
      
        R
        :
        S
        â
        
          R
        
      
    
    {\displaystyle R:S\rightarrow \mathbb {R} }
  
  is chosen and learning performed in round t as follows:


  
    
      
        
          w
          
            t
          
        
        =
        
          
            a
            r
            g
            
            m
            i
            n
          
          
            w
            â
            S
          
        
        â¡
        
          â
          
            i
            =
            1
          
          
            t
            â
            1
          
        
        
          v
          
            i
          
        
        (
        w
        )
        +
        R
        (
        w
        )
      
    
    {\displaystyle w_{t}=\operatorname {arg\,min} _{w\in S}\sum _{i=1}^{t-1}v_{i}(w)+R(w)}
  

As a special example, consider the case of online linear optimisation i.e. where nature sends back loss functions of the form 
  
    
      
        
          v
          
            t
          
        
        (
        w
        )
        =
        â¨
        w
        ,
        
          z
          
            t
          
        
        â©
      
    
    {\displaystyle v_{t}(w)=\langle w,z_{t}\rangle }
  
. Also, let 
  
    
      
        S
        =
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle S=\mathbb {R} ^{d}}
  
. Suppose the regularisation function 
  
    
      
        R
        (
        w
        )
        =
        
          
            1
            
              2
              Î·
            
          
        
        
          |
        
        
          |
        
        w
        
          |
        
        
          
            |
          
          
            2
          
          
            2
          
        
      
    
    {\displaystyle R(w)={\frac {1}{2\eta }}||w||_{2}^{2}}
  
 is chosen for some positive number 
  
    
      
        Î·
      
    
    {\displaystyle \eta }
  
. Then, one can show that the regret minimising iteration becomes 


  
    
      
        
          w
          
            t
            +
            1
          
        
        =
        â
        Î·
        
          â
          
            i
            =
            1
          
          
            t
          
        
        
          z
          
            i
          
        
        =
        
          w
          
            t
          
        
        â
        Î·
        
          z
          
            t
          
        
      
    
    {\displaystyle w_{t+1}=-\eta \sum _{i=1}^{t}z_{i}=w_{t}-\eta z_{t}}
  

Note that this can be rewritten as 
  
    
      
        
          w
          
            t
            +
            1
          
        
        =
        
          w
          
            t
          
        
        â
        Î·
        â
        
          v
          
            t
          
        
        (
        
          w
          
            t
          
        
        )
      
    
    {\displaystyle w_{t+1}=w_{t}-\eta \nabla v_{t}(w_{t})}
  
, which looks exactly like online gradient descent.
If S is instead some convex subspace of 
  
    
      
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle \mathbb {R} ^{d}}
  
, S would need to be projected onto, leading to the modified update rule


  
    
      
        
          w
          
            t
            +
            1
          
        
        =
        
          Î 
          
            S
          
        
        (
        â
        Î·
        
          â
          
            i
            =
            1
          
          
            t
          
        
        
          z
          
            i
          
        
        )
        =
        
          Î 
          
            S
          
        
        (
        Î·
        
          Î¸
          
            t
            +
            1
          
        
        )
      
    
    {\displaystyle w_{t+1}=\Pi _{S}(-\eta \sum _{i=1}^{t}z_{i})=\Pi _{S}(\eta \theta _{t+1})}
  

This algorithm is known as lazy projection, as the vector 
  
    
      
        
          Î¸
          
            t
            +
            1
          
        
      
    
    {\displaystyle \theta _{t+1}}
  
 accumulates the gradients. It is also known as Nesterov's dual averaging algorithm. In this scenario of linear loss functions and quadratic regularisation, the regret is bounded by 
  
    
      
        O
        (
        
          
            T
          
        
        )
      
    
    {\displaystyle O({\sqrt {T}})}
  
, and thus the average regret goes to 0 as desired.

Online subgradient descent (OSD)[edit]
See also: Subgradient method
The above proved a regret bound for linear loss functions 
  
    
      
        
          v
          
            t
          
        
        (
        w
        )
        =
        â¨
        w
        ,
        
          z
          
            t
          
        
        â©
      
    
    {\displaystyle v_{t}(w)=\langle w,z_{t}\rangle }
  
. To generalise the algorithm to any convex loss function, the subgradient 
  
    
      
        â
        
          v
          
            t
          
        
        (
        
          w
          
            t
          
        
        )
      
    
    {\displaystyle \partial v_{t}(w_{t})}
  
 of 
  
    
      
        
          v
          
            t
          
        
      
    
    {\displaystyle v_{t}}
  
 is used as a linear approximation to 
  
    
      
        
          v
          
            t
          
        
      
    
    {\displaystyle v_{t}}
  
 near 
  
    
      
        
          w
          
            t
          
        
      
    
    {\displaystyle w_{t}}
  
, leading to the online subgradient descent algorithm:
Initialise parameter 
  
    
      
        Î·
        ,
        
          w
          
            1
          
        
        =
        0
      
    
    {\displaystyle \eta ,w_{1}=0}
  

For 
  
    
      
        t
        =
        1
        ,
        2
        ,
        .
        .
        .
        ,
        T
      
    
    {\displaystyle t=1,2,...,T}
  


Predict using 
  
    
      
        
          w
          
            t
          
        
      
    
    {\displaystyle w_{t}}
  
, receive 
  
    
      
        
          f
          
            t
          
        
      
    
    {\displaystyle f_{t}}
  
 from nature.
Choose 
  
    
      
        
          z
          
            t
          
        
        â
        â
        
          v
          
            t
          
        
        (
        
          w
          
            t
          
        
        )
      
    
    {\displaystyle z_{t}\in \partial v_{t}(w_{t})}
  

If 
  
    
      
        S
        =
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle S=\mathbb {R} ^{d}}
  
, update as 
  
    
      
        
          w
          
            t
            +
            1
          
        
        =
        
          w
          
            t
          
        
        â
        Î·
        
          z
          
            t
          
        
      
    
    {\displaystyle w_{t+1}=w_{t}-\eta z_{t}}
  

If 
  
    
      
        S
        â
        
          
            R
          
          
            d
          
        
      
    
    {\displaystyle S\subset \mathbb {R} ^{d}}
  
, project cumulative gradients onto 
  
    
      
        S
      
    
    {\displaystyle S}
  
 i.e. 
  
    
      
        
          w
          
            t
            +
            1
          
        
        =
        
          Î 
          
            S
          
        
        (
        Î·
        
          Î¸
          
            t
            +
            1
          
        
        )
        ,
        
          Î¸
          
            t
            +
            1
          
        
        =
        
          Î¸
          
            t
          
        
        +
        
          z
          
            t
          
        
      
    
    {\displaystyle w_{t+1}=\Pi _{S}(\eta \theta _{t+1}),\theta _{t+1}=\theta _{t}+z_{t}}
  

One can use the OSD algorithm to derive 
  
    
      
        O
        (
        
          
            T
          
        
        )
      
    
    {\displaystyle O({\sqrt {T}})}
  
 regret bounds for the online version of SVM's for classification, which use the hinge loss
  
    
      
        
          v
          
            t
          
        
        (
        w
        )
        =
        max
        {
        0
        ,
        1
        â
        
          y
          
            t
          
        
        (
        w
        â
        
          x
          
            t
          
        
        )
        }
      
    
    {\displaystyle v_{t}(w)=\max\{0,1-y_{t}(w\cdot x_{t})\}}
  


Other algorithms[edit]
Quadratically regularised FTRL algorithms lead to lazily projected gradient algorithms as described above. To use the above for arbitrary convex functions and regularisers, one uses online mirror descent.  The optimal regularization in hindsight can be derived for linear loss functions, this leads to the AdaGrad algorithm.
For the Euclidean regularisation, one can show a regret bound of 
  
    
      
        O
        (
        
          
            T
          
        
        )
      
    
    {\displaystyle O({\sqrt {T}})}
  
, which can be improved further to a 
  
    
      
        O
        (
        log
        â¡
        T
        )
      
    
    {\displaystyle O(\log T)}
  
 for strongly convex and exp-concave loss functions.

Continual learning[edit]
Continual learning means constantly improving the learned model by  processing continuous
streams of information.[5]
Continual learning capabilities are essential for software systems and autonomous agents interacting in an ever changing real world.
However, continual learning is a challenge for machine learning and neural network models since the continual acquisition of incrementally available information from non-stationary data distributions
generally leads to catastrophic forgetting. 

Interpretations of online learning[edit]
The paradigm of online learning has different interpretations depending on the choice of the learning model, each of which has distinct implications about the predictive quality of the sequence of functions 
  
    
      
        
          f
          
            1
          
        
        ,
        
          f
          
            2
          
        
        ,
        â¦
        ,
        
          f
          
            n
          
        
      
    
    {\displaystyle f_{1},f_{2},\ldots ,f_{n}}
  
. The prototypical stochastic gradient descent algorithm is used for this discussion. As noted above, its recursion is given by


  
    
      
        
          
            w
            
              t
            
          
          =
          
            w
            
              t
              â
              1
            
          
          â
          
            Î³
            
              t
            
          
          â
          V
          (
          â¨
          
            w
            
              t
              â
              1
            
          
          ,
          
            x
            
              t
            
          
          â©
          ,
          
            y
            
              t
            
          
          )
        
      
    
    {\displaystyle \textstyle w_{t}=w_{t-1}-\gamma _{t}\nabla V(\langle w_{t-1},x_{t}\rangle ,y_{t})}
  

The first interpretation consider the stochastic gradient descent method as applied to the problem of minimizing the expected risk 
  
    
      
        I
        [
        w
        ]
      
    
    {\displaystyle I[w]}
  
 defined above.[6] Indeed, in the case of an infinite stream of data, since the examples 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          y
          
            1
          
        
        )
        ,
        (
        
          x
          
            2
          
        
        ,
        
          y
          
            2
          
        
        )
        ,
        â¦
      
    
    {\displaystyle (x_{1},y_{1}),(x_{2},y_{2}),\ldots }
  
 are assumed to be drawn i.i.d. from the distribution 
  
    
      
        p
        (
        x
        ,
        y
        )
      
    
    {\displaystyle p(x,y)}
  
, the sequence of gradients of 
  
    
      
        V
        (
        â
        ,
        â
        )
      
    
    {\displaystyle V(\cdot ,\cdot )}
  
 in the above iteration are an i.i.d. sample of stochastic estimates of the gradient of the expected risk 
  
    
      
        I
        [
        w
        ]
      
    
    {\displaystyle I[w]}
  
 and therefore one can apply complexity results for the stochastic gradient descent method to bound the deviation 
  
    
      
        I
        [
        
          w
          
            t
          
        
        ]
        â
        I
        [
        
          w
          
            â
          
        
        ]
      
    
    {\displaystyle I[w_{t}]-I[w^{\ast }]}
  
, where 
  
    
      
        
          w
          
            â
          
        
      
    
    {\displaystyle w^{\ast }}
  
 is the minimizer of 
  
    
      
        I
        [
        w
        ]
      
    
    {\displaystyle I[w]}
  
.[7] This interpretation is also valid in the case of a finite training set; although with multiple passes through the data the gradients are no longer independent, still complexity results can be obtained in special cases.
The second interpretation applies to the case of a finite training set and considers the SGD algorithm as an instance of incremental gradient descent method.[3] In this case, one instead looks at the empirical risk:


  
    
      
        
          I
          
            n
          
        
        [
        w
        ]
        =
        
          
            1
            n
          
        
        
          â
          
            i
            =
            1
          
          
            n
          
        
        V
        (
        â¨
        w
        ,
        
          x
          
            i
          
        
        â©
        ,
        
          y
          
            i
          
        
        )
        Â 
        .
      
    
    {\displaystyle I_{n}[w]={\frac {1}{n}}\sum _{i=1}^{n}V(\langle w,x_{i}\rangle ,y_{i})\ .}
  

Since the gradients of 
  
    
      
        V
        (
        â
        ,
        â
        )
      
    
    {\displaystyle V(\cdot ,\cdot )}
  
 in the incremental gradient descent iterations are also stochastic estimates of the gradient of 
  
    
      
        
          I
          
            n
          
        
        [
        w
        ]
      
    
    {\displaystyle I_{n}[w]}
  
, this interpretation is also related to the stochastic gradient descent method, but applied to minimize the empirical risk as opposed to the expected risk. Since this interpretation concerns the empirical risk and not the expected risk, multiple passes through the data are readily allowed and actually lead to tighter bounds on the deviations 
  
    
      
        
          I
          
            n
          
        
        [
        
          w
          
            t
          
        
        ]
        â
        
          I
          
            n
          
        
        [
        
          w
          
            n
          
          
            â
          
        
        ]
      
    
    {\displaystyle I_{n}[w_{t}]-I_{n}[w_{n}^{\ast }]}
  
, where 
  
    
      
        
          w
          
            n
          
          
            â
          
        
      
    
    {\displaystyle w_{n}^{\ast }}
  
 is the minimizer of 
  
    
      
        
          I
          
            n
          
        
        [
        w
        ]
      
    
    {\displaystyle I_{n}[w]}
  
.

Implementations[edit]
Vowpal Wabbit: Open-source fast out-of-core online learning system which is notable for supporting a number of machine learning reductions, importance weighting and a selection of different loss functions and optimisation algorithms. It uses the hashing trick for bounding the size of the set of features independent of the amount of training data.
scikit-learn: Provides out-of-core implementations of algorithms for
Classification: Perceptron, SGD classifier, Naive bayes classifier.
Regression: SGD Regressor, Passive Aggressive regressor.
Clustering: Mini-batch k-means.
Feature extraction: Mini-batch dictionary learning, Incremental PCA.
See also[edit]
Learning paradigms

Incremental learning
Lazy learning
Offline learning, the opposite model
Reinforcement learning
Supervised learning
General algorithms

Online algorithm
Online optimization
Streaming algorithm
Stochastic gradient descent
Learning models

Adaptive Resonance Theory
Hierarchical temporal memory
k-nearest neighbor algorithm
Learning vector quantization
Perceptron
References[edit]

^ Jump up to: a b c d e f g L. Rosasco, T. Poggio, Machine Learning: a Regularization Approach, MIT-9.520 Lectures Notes, Manuscript, Dec. 2015. Chapter 7 - Online Learning

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Yin, Harold J. Kushner, G. George (2003). Stochastic approximation and recursive algorithms and applications (SecondÂ ed.). New York: Springer. pp.Â 8â12. ISBNÂ 978-0-387-21769-7.

^ Jump up to: a b Bertsekas, D. P. (2011). Incremental gradient, subgradient, and proximal methods for convex optimization: a survey. Optimization for Machine Learning, 85.

^ Hazan, Elad (2015). Introduction to Online Convex Optimization (PDF). Foundations and Trends in Optimization.

^ Parisi, German I.; Kemker, Ronald; Part, Jose L.; Kanan, Christopher; Wermter, Stefan (2019). "Continual lifelong learning with neural networks: A review". Neural Networks. 113: 54â71. arXiv:1802.07569. doi:10.1016/j.neunet.2019.01.012. ISSNÂ 0893-6080.

^ Bottou, LÃ©on (1998). "Online Algorithms and Stochastic Approximations". Online Learning and Neural Networks. Cambridge University Press. ISBNÂ 978-0-521-65263-6.

^ Stochastic Approximation Algorithms and Applications, Harold J. Kushner and G. George Yin, New York: Springer-Verlag, 1997.  ISBNÂ 0-387-94916-X; 2nd ed., titled Stochastic Approximation and Recursive Algorithms and Applications, 2003, ISBNÂ 0-387-00894-2.


External links[edit]
http://onlineprediction.net/, Wiki for On-Line Prediction.
6.883: Online Methods in Machine Learning: Theory and Applications. Alexander Rakhlin. MIT




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Online_machine_learning&oldid=1068076121"
		Categories: Machine learning algorithmsHidden categories: Articles with short descriptionShort description matches WikidataWikipedia articles needing clarification from September 2019All articles with unsourced statementsArticles with unsourced statements from September 2019
	
