
Title:
Autoencoder
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Neural network that learns efficient data encoding in an unsupervised manner
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Not to be confused with Autocoder or Autocode.


.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Part of a series onMachine learningand data mining
showProblems
Classification
Clustering
Regression
Anomaly detection
Data Cleaning
AutoML
Association rules
Reinforcement learning
Structured prediction
Feature engineering
Feature learning
Online learning
Semi-supervised learning
Unsupervised learning
Learning to rank
Grammar induction

showSupervised learning.mw-parser-output .nobold{font-weight:normal}(classificationÂ â¢ regression) 
Decision trees
Ensembles
Bagging
Boosting
Random forest
k-NN
Linear regression
Naive Bayes
Artificial neural networks
Logistic regression
Perceptron
Relevance vector machine (RVM)
Support vector machine (SVM)

showClustering
BIRCH
CURE
Hierarchical
k-means
Expectationâmaximization (EM)
DBSCAN
OPTICS
Mean shift

showDimensionality reduction
Factor analysis
CCA
ICA
LDA
NMF
PCA
PGD
t-SNE

showStructured prediction
Graphical models
Bayes net
Conditional random field
Hidden Markov

showAnomaly detection
k-NN
Local outlier factor

hideArtificial neural network
Autoencoder
Cognitive computing
Deep learning
DeepDream
Multilayer perceptron
RNN
LSTM
GRU
ESN
Restricted Boltzmann machine
GAN
SOM
Convolutional neural network
U-Net
Transformer
Vision
Spiking neural network
Memtransistor
Electrochemical RAM (ECRAM)

showReinforcement learning
Q-learning
SARSA
Temporal difference (TD)

showTheory
Kernel machines
Biasâvariance tradeoff
Computational learning theory
Empirical risk minimization
Occam learning
PAC learning
Statistical learning
VC theory

showMachine-learning venues
NeurIPS
ICML
ML
JMLR
ArXiv:cs.LG

showRelated articles
Glossary of artificial intelligence
List of datasets for machine-learning research
Outline of machine learning
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
An autoencoder is a type of artificial neural network used to learn efficient codings of unlabeled data (unsupervised learning).[1] The encoding is validated and refined by attempting to regenerate the input from the encoding. The autoencoder learns a representation (encoding) for a set of data, typically for dimensionality reduction, by training the network to ignore insignificant data (ânoiseâ). 
Variants exist, aiming to force the learned representations to assume useful properties.[2] Examples are regularized autoencoders (Sparse, Denoising and Contractive), which are effective in learning representations for subsequent classification tasks,[3] and Variational autoencoders, with applications as generative models.[4] Autoencoders are applied to many problems, from facial recognition,[5] feature detection,[6] anomaly detection to acquiring the meaning of words.[7][8] Autoencoders are also generative models: they can randomly generate new data that is similar to the input data (training data).[6]

.mw-parser-output .toclimit-2 .toclevel-1 ul,.mw-parser-output .toclimit-3 .toclevel-2 ul,.mw-parser-output .toclimit-4 .toclevel-3 ul,.mw-parser-output .toclimit-5 .toclevel-4 ul,.mw-parser-output .toclimit-6 .toclevel-5 ul,.mw-parser-output .toclimit-7 .toclevel-6 ul{display:none}Contents

1 Basic architecture
2 Variations

2.1 Regularized autoencoders

2.1.1 Sparse autoencoder (SAE)
2.1.2 Denoising autoencoder (DAE)
2.1.3 Contractive autoencoder (CAE)


2.2 Concrete autoencoder
2.3 Variational autoencoder (VAE)


3 Advantages of depth

3.1 Training


4 Applications

4.1 Dimensionality reduction

4.1.1 Principal component analysis


4.2 Information retrieval
4.3 Anomaly detection
4.4 Image processing
4.5 Drug discovery
4.6 Popularity prediction
4.7 Machine translation


5 See also
6 References



Basic architecture[edit]
An autoencoder has two main parts: an encoder that maps the input into the code, and a decoder that maps the code to a reconstruction of the input.
The simplest way to perform the copying task perfectly would be to duplicate the signal. Instead, autoencoders are typically forced to reconstruct the input approximately, preserving only the most relevant aspects of the data in the copy.

The idea of autoencoders has been popular for decades. The first applications date to the 1980s.[2][9][10] Their most traditional application was dimensionality reduction or feature learning, but the concept became widely used for learning generative models of data.[11][12] Some of the most powerful AIs in the 2010s involved autoencoders stacked inside deep neural networks.[13]  Schema of a basic AutoencoderThe simplest form of an autoencoder is a feedforward, non-recurrent neural network similar to single layer perceptrons that participate in multilayer perceptrons (MLP) â employing an input layer and an output layer connected by one or more hidden layers. The output layer has the same number of nodes (neurons) as the input layer. Its purpose is to reconstruct its inputs (minimizing the difference between the input and the output) instead of predicting a target value 
  
    
      
        Y
      
    
    {\displaystyle Y}
  
 given inputs 
  
    
      
        X
      
    
    {\displaystyle X}
  
. Therefore, autoencoders learn unsupervised.
An autoencoder consists of two parts, the encoder and the decoder, which can be defined as transitions 
  
    
      
        Ï
      
    
    {\displaystyle \phi }
  
 and 
  
    
      
        Ï
        ,
      
    
    {\displaystyle \psi ,}
  
 such that:


  
    
      
        Ï
        :
        
          
            X
          
        
        â
        
          
            F
          
        
      
    
    {\displaystyle \phi :{\mathcal {X}}\rightarrow {\mathcal {F}}}
  


  
    
      
        Ï
        :
        
          
            F
          
        
        â
        
          
            X
          
        
      
    
    {\displaystyle \psi :{\mathcal {F}}\rightarrow {\mathcal {X}}}
  


  
    
      
        Ï
        ,
        Ï
        =
        
          
            
              a
              r
              g
              
              m
              i
              n
            
            
              Ï
              ,
              Ï
            
          
        
        
        â
        
          
            X
          
        
        â
        (
        Ï
        â
        Ï
        )
        
          
            X
          
        
        
          â
          
            2
          
        
      
    
    {\displaystyle \phi ,\psi ={\underset {\phi ,\psi }{\operatorname {arg\,min} }}\,\|{\mathcal {X}}-(\psi \circ \phi ){\mathcal {X}}\|^{2}}
  

In the simplest case, given one hidden layer, the encoder stage of an autoencoder takes the input 
  
    
      
        
          x
        
        â
        
          
            R
          
          
            d
          
        
        =
        
          
            X
          
        
      
    
    {\displaystyle \mathbf {x} \in \mathbb {R} ^{d}={\mathcal {X}}}
  
 and maps it to 
  
    
      
        
          h
        
        â
        
          
            R
          
          
            p
          
        
        =
        
          
            F
          
        
      
    
    {\displaystyle \mathbf {h} \in \mathbb {R} ^{p}={\mathcal {F}}}
  
:


  
    
      
        
          h
        
        =
        Ï
        (
        
          W
          x
        
        +
        
          b
        
        )
      
    
    {\displaystyle \mathbf {h} =\sigma (\mathbf {Wx} +\mathbf {b} )}
  

This image 
  
    
      
        
          h
        
      
    
    {\displaystyle \mathbf {h} }
  
 is usually referred to as code, latent variables, or a latent representation. 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 is an element-wise activation function such as a sigmoid function or a rectified linear unit.  
  
    
      
        
          W
        
      
    
    {\displaystyle \mathbf {W} }
  
 is a weight matrix and 
  
    
      
        
          b
        
      
    
    {\displaystyle \mathbf {b} }
  
 is a bias vector. Weights and biases are usually initialized randomly, and then updated iteratively during training through backpropagation. After that, the decoder stage of the autoencoder maps 
  
    
      
        
          h
        
      
    
    {\displaystyle \mathbf {h} }
  
 to the reconstruction 
  
    
      
        
          
            x
            â²
          
        
      
    
    {\displaystyle \mathbf {x'} }
  
 of the same shape as 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
:


  
    
      
        
          
            x
            â²
          
        
        =
        
          Ï
          â²
        
        (
        
          
            W
            â²
          
          h
        
        +
        
          
            b
            â²
          
        
        )
      
    
    {\displaystyle \mathbf {x'} =\sigma '(\mathbf {W'h} +\mathbf {b'} )}
  

where 
  
    
      
        
          
            Ï
            â²
          
        
        ,
        
          
            W
            â²
          
        
        ,
        
          Â andÂ 
        
        
          
            b
            â²
          
        
      
    
    {\displaystyle \mathbf {\sigma '} ,\mathbf {W'} ,{\text{ and }}\mathbf {b'} }
  
 for the decoder may be unrelated to the corresponding 
  
    
      
        
          Ï
        
        ,
        
          W
        
        ,
        
          Â andÂ 
        
        
          b
        
      
    
    {\displaystyle \mathbf {\sigma } ,\mathbf {W} ,{\text{ and }}\mathbf {b} }
  
 for the encoder.
Autoencoders are trained to minimise reconstruction errors (such as squared errors), often referred to as the "loss":


  
    
      
        
          
            L
          
        
        (
        
          x
        
        ,
        
          
            x
            â²
          
        
        )
        =
        â
        
          x
        
        â
        
          
            x
            â²
          
        
        
          â
          
            2
          
        
        =
        â
        
          x
        
        â
        
          Ï
          â²
        
        (
        
          
            W
            â²
          
        
        (
        Ï
        (
        
          W
          x
        
        +
        
          b
        
        )
        )
        +
        
          
            b
            â²
          
        
        )
        
          â
          
            2
          
        
      
    
    {\displaystyle {\mathcal {L}}(\mathbf {x} ,\mathbf {x'} )=\|\mathbf {x} -\mathbf {x'} \|^{2}=\|\mathbf {x} -\sigma '(\mathbf {W'} (\sigma (\mathbf {Wx} +\mathbf {b} ))+\mathbf {b'} )\|^{2}}
  

where 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 is usually averaged over the training set.
As mentioned before, autoencoder training is performed through backpropagation of the error, just like other feedforward neural networks.
Should the feature space 
  
    
      
        
          
            F
          
        
      
    
    {\displaystyle {\mathcal {F}}}
  
 have lower dimensionality than the input space 
  
    
      
        
          
            X
          
        
      
    
    {\displaystyle {\mathcal {X}}}
  
, the feature vector 
  
    
      
        Ï
        (
        x
        )
      
    
    {\displaystyle \phi (x)}
  
 can be regarded as a compressed representation of the input 
  
    
      
        x
      
    
    {\displaystyle x}
  
. This is the case of undercomplete autoencoders. If the hidden layers are larger than (overcomplete), or equal to, the input layer, or the hidden units are given enough capacity, an autoencoder can potentially learn the identity function and become useless. However, experimental results found that overcomplete autoencoders might still learn useful features.[14] In the ideal setting, the code dimension and the model capacity could be set on the basis of the complexity of the data distribution to be modeled. One way to do so is to exploit the model variants known as Regularized Autoencoders.[2]

Variations[edit]
Regularized autoencoders[edit]
Various techniques exist to prevent autoencoders from learning the identity function and to improve their ability to capture important information and learn richer representations.

Sparse autoencoder (SAE)[edit]
  Simple schema of a single-layer sparse autoencoder. The hidden nodes in bright yellow are activated, while the light yellow ones are inactive. The activation depends on the input.
Learning representations  in a way that encourages sparsity improves performance on classification tasks.[15] Sparse autoencoders may include more (rather than fewer) hidden units than inputs, but only a small number of the hidden units are allowed to be active at the same time (thus, sparse).[13] This constraint forces the model to respond to the unique statistical features of the training data.
Specifically, a sparse autoencoder is an autoencoder whose training criterion involves a sparsity penalty 
  
    
      
        Î©
        (
        
          h
        
        )
      
    
    {\displaystyle \Omega ({\boldsymbol {h}})}
  
 on the code layer 
  
    
      
        
          h
        
      
    
    {\displaystyle {\boldsymbol {h}}}
  
.


  
    
      
        
          
            L
          
        
        (
        
          x
        
        ,
        
          
            x
            â²
          
        
        )
        +
        Î©
        (
        
          h
        
        )
      
    
    {\displaystyle {\mathcal {L}}(\mathbf {x} ,\mathbf {x'} )+\Omega ({\boldsymbol {h}})}
  

Recalling that 
  
    
      
        
          h
        
        =
        f
        (
        
          W
        
        
          x
        
        +
        
          b
        
        )
      
    
    {\displaystyle {\boldsymbol {h}}=f({\boldsymbol {W}}{\boldsymbol {x}}+{\boldsymbol {b}})}
  
, the penalty encourages the model to activate (i.e. output value close to 1) specific areas of the network on the basis of the input data, while inactivating all other neurons (i.e. to have an output value close to 0).[16]
This sparsity can be achieved by formulating the penalty terms in different ways.

One way is to exploit the Kullback-Leibler (KL) divergence.[15][16][17][18]  Let

  
    
      
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
        =
        
          
            1
            m
          
        
        
          â
          
            i
            =
            1
          
          
            m
          
        
        [
        
          h
          
            j
          
        
        (
        
          x
          
            i
          
        
        )
        ]
      
    
    {\displaystyle {\hat {\rho _{j}}}={\frac {1}{m}}\sum _{i=1}^{m}[h_{j}(x_{i})]}
  

be the average activation of the hidden unit 
  
    
      
        j
      
    
    {\displaystyle j}
  
 (averaged over the  
  
    
      
        m
      
    
    {\displaystyle m}
  
 training examples). The notation 
  
    
      
        
          h
          
            j
          
        
        (
        
          x
          
            i
          
        
        )
      
    
    {\displaystyle h_{j}(x_{i})}
  
 identifies the input value that triggered the activation. To encourage most of the neurons to be inactive, 
  
    
      
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
      
    
    {\displaystyle {\hat {\rho _{j}}}}
  
 needs to be close to 0. Therefore, this method enforces the constraint 
  
    
      
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
        =
        Ï
      
    
    {\displaystyle {\hat {\rho _{j}}}=\rho }
  
  where 
  
    
      
        Ï
      
    
    {\displaystyle \rho }
  
 is the sparsity parameter, a value close to zero. The penalty term 
  
    
      
        Î©
        (
        
          h
        
        )
      
    
    {\displaystyle \Omega ({\boldsymbol {h}})}
  
 takes a form that penalizes 
  
    
      
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
      
    
    {\displaystyle {\hat {\rho _{j}}}}
  
 for deviating significantly from 
  
    
      
        Ï
      
    
    {\displaystyle \rho }
  
, exploiting the KL divergence:

  
    
      
        
          â
          
            j
            =
            1
          
          
            s
          
        
        K
        L
        (
        Ï
        
          |
        
        
          |
        
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
        )
        =
        
          â
          
            j
            =
            1
          
          
            s
          
        
        
          [
          
            Ï
            log
            â¡
            
              
                Ï
                
                  
                    
                      Ï
                      
                        j
                      
                    
                    ^
                  
                
              
            
            +
            (
            1
            â
            Ï
            )
            log
            â¡
            
              
                
                  1
                  â
                  Ï
                
                
                  1
                  â
                  
                    
                      
                        
                          Ï
                          
                            j
                          
                        
                        ^
                      
                    
                  
                
              
            
          
          ]
        
      
    
    {\displaystyle \sum _{j=1}^{s}KL(\rho ||{\hat {\rho _{j}}})=\sum _{j=1}^{s}\left[\rho \log {\frac {\rho }{\hat {\rho _{j}}}}+(1-\rho )\log {\frac {1-\rho }{1-{\hat {\rho _{j}}}}}\right]}
  

where 
  
    
      
        j
      
    
    {\displaystyle j}
  
 is summing over the 
  
    
      
        s
      
    
    {\displaystyle s}
  
 hidden nodes in the hidden layer, and 
  
    
      
        K
        L
        (
        Ï
        
          |
        
        
          |
        
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
        )
      
    
    {\displaystyle KL(\rho ||{\hat {\rho _{j}}})}
  
 is the KL-divergence between a Bernoulli random variable with mean 
  
    
      
        Ï
      
    
    {\displaystyle \rho }
  
 and a Bernoulli random variable with mean 
  
    
      
        
          
            
              
                Ï
                
                  j
                
              
              ^
            
          
        
      
    
    {\displaystyle {\hat {\rho _{j}}}}
  
.[16]
Another way to achieve sparsity is by applying L1 or L2 regularization terms on the activation, scaled by a certain parameter 
  
    
      
        Î»
      
    
    {\displaystyle \lambda }
  
.[19] For instance, in the case of L1 the loss function becomes

  
    
      
        
          
            L
          
        
        (
        
          x
        
        ,
        
          
            x
            â²
          
        
        )
        +
        Î»
        
          â
          
            i
          
        
        
          |
        
        
          h
          
            i
          
        
        
          |
        
      
    
    {\displaystyle {\mathcal {L}}(\mathbf {x} ,\mathbf {x'} )+\lambda \sum _{i}|h_{i}|}
  

A further proposed strategy to force sparsity is to manually zero all but the strongest hidden unit activations (k-sparse autoencoder).[20] The k-sparse autoencoder is based on a linear autoencoder (i.e. with linear activation function) and tied weights. The identification of the strongest activations can be achieved by sorting the activities and keeping only the first k values, or by using ReLU hidden units with thresholds that are adaptively adjusted until the k largest activities are identified. This selection acts like the previously mentioned regularization terms in that it prevents the model from reconstructing the input using too many neurons.[20]
Denoising autoencoder (DAE)[edit]
Denoising autoencoders (DAE) try to achieve a good representation by changing the reconstruction criterion.[2]
Indeed, DAEs take a partially corrupted input and are trained to recover the original undistorted input.  In practice, the objective of denoising autoencoders is that of cleaning the corrupted input, or denoising. Two assumptions are inherent to this approach:

Higher level representations are relatively stable and robust to the corruption of the input;
To perform denoising well, the model needs to extract features that capture useful structure in the input distribution.[3]
In other words, denoising is advocated as a training criterion for learning to extract useful features that will constitute better higher level representations of the input.[3]
The training process of a DAE works as follows:

The initial input 
  
    
      
        x
      
    
    {\displaystyle x}
  
 is corrupted into 
  
    
      
        
          
            
              x
              ~
            
          
        
      
    
    {\displaystyle {\boldsymbol {\tilde {x}}}}
  
 through stochastic mapping 
  
    
      
        
          
            
              x
              ~
            
          
        
        â¼
        
          q
          
            D
          
        
        (
        
          
            
              x
              ~
            
          
        
        
          |
        
        
          x
        
        )
      
    
    {\displaystyle {\boldsymbol {\tilde {x}}}\thicksim q_{D}({\boldsymbol {\tilde {x}}}|{\boldsymbol {x}})}
  
.
The corrupted input 
  
    
      
        
          
            
              x
              ~
            
          
        
      
    
    {\displaystyle {\boldsymbol {\tilde {x}}}}
  
 is then mapped to a hidden representation with the same process of the standard autoencoder, 
  
    
      
        
          h
        
        =
        
          f
          
            Î¸
          
        
        (
        
          
            
              x
              ~
            
          
        
        )
        =
        s
        (
        
          W
        
        
          
            
              x
              ~
            
          
        
        +
        
          b
        
        )
      
    
    {\displaystyle {\boldsymbol {h}}=f_{\theta }({\boldsymbol {\tilde {x}}})=s({\boldsymbol {W}}{\boldsymbol {\tilde {x}}}+{\boldsymbol {b}})}
  
.
From the hidden representation the model reconstructs 
  
    
      
        
          z
        
        =
        
          g
          
            
              Î¸
              â²
            
          
        
        (
        
          h
        
        )
      
    
    {\displaystyle {\boldsymbol {z}}=g_{\theta '}({\boldsymbol {h}})}
  
.[3]
The model's parameters 
  
    
      
        Î¸
      
    
    {\displaystyle \theta }
  
 and 
  
    
      
        
          Î¸
          â²
        
      
    
    {\displaystyle \theta '}
  
 are trained to minimize the average reconstruction error over the training data, specifically, minimizing the difference between 
  
    
      
        
          z
        
      
    
    {\displaystyle {\boldsymbol {z}}}
  
 and the original uncorrupted input  
  
    
      
        
          x
        
      
    
    {\displaystyle {\boldsymbol {x}}}
  
.[3] Note that each time a random example 
  
    
      
        
          x
        
      
    
    {\displaystyle {\boldsymbol {x}}}
  
 is presented to the model, a new corrupted version is generated stochastically on the basis of 
  
    
      
        
          q
          
            D
          
        
        (
        
          
            
              x
              ~
            
          
        
        
          |
        
        
          x
        
        )
      
    
    {\displaystyle q_{D}({\boldsymbol {\tilde {x}}}|{\boldsymbol {x}})}
  
.
The above-mentioned training process could be applied with any kind of corruption process. Some examples might be additive isotropic Gaussian noise, masking noise (a fraction of the input chosen at random for each example is forced to 0) or salt-and-pepper noise (a fraction of the input chosen at random for each example is set to its minimum or maximum value with uniform probability).[3]
The corruption of the input is performed only during training. After training, no corruption is added.

Contractive autoencoder (CAE)[edit]
A contractive autoencoder adds an explicit regularizer in its objective function that forces the model to learn an encoding robust to slight variations of input values. This regularizer corresponds to the Frobenius norm of the Jacobian matrix of the encoder activations with respect to the input. Since the penalty is applied to training examples only, this term forces the model to learn useful information about the training distribution. The final objective function has the following form:


  
    
      
        
          
            L
          
        
        (
        
          x
        
        ,
        
          
            x
            â²
          
        
        )
        +
        Î»
        
          â
          
            i
          
        
        
          |
        
        
          |
        
        
          â
          
            x
          
        
        
          h
          
            i
          
        
        
          |
        
        
          
            |
          
          
            2
          
        
      
    
    {\displaystyle {\mathcal {L}}(\mathbf {x} ,\mathbf {x'} )+\lambda \sum _{i}||\nabla _{x}h_{i}||^{2}}
  

The autoencoder is termed contractive because it is encouraged to map a neighborhood of input points to a smaller neighborhood of output points.[2]
DAE is connected to CAE: in the limit of small Gaussian input noise, DAEs make the reconstruction function resist small but finite-sized input perturbations, while CAEs make the extracted features resist infinitesimal input perturbations.

Concrete autoencoder[edit]
The concrete autoencoder is designed for discrete feature selection.[21] A concrete autoencoder forces the latent space to consist only of a user-specified number of features. The concrete autoencoder uses a continuous relaxation of the categorical distribution to allow gradients to pass through the feature selector layer, which makes it possible to use standard backpropagation to learn an optimal subset of input features that minimize reconstruction loss.

Variational autoencoder (VAE)[edit]
Main article: Variational autoencoder
Variational autoencoders (VAEs) belong to the families of variational Bayesian methods. Despite the architectural similarities with basic autoencoders, VAEs are architecture with different goals and with a completely different mathematical formulation. The latent space is in this case composed by a mixture of distributions instead of a fixed vector.
Given an input dataset 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 characterized by an unknown probability function 
  
    
      
        P
        (
        
          x
        
        )
      
    
    {\displaystyle P(\mathbf {x} )}
  
 and a multivariate latent encoding vector 
  
    
      
        
          z
        
      
    
    {\displaystyle \mathbf {z} }
  
, the objective is to model the data as a distribution 
  
    
      
        
          p
          
            Î¸
          
        
        (
        
          x
        
        )
      
    
    {\displaystyle p_{\theta }(\mathbf {x} )}
  
, with 
  
    
      
        Î¸
      
    
    {\displaystyle \theta }
  
 defined as the set of the network parameters so that 
  
    
      
        
          p
          
            Î¸
          
        
        (
        
          x
        
        )
        =
        
          â«
          
            
              z
            
          
        
        
          p
          
            Î¸
          
        
        (
        
          x
          ,
          z
        
        )
        d
        
          z
        
      
    
    {\displaystyle p_{\theta }(\mathbf {x} )=\int _{\mathbf {z} }p_{\theta }(\mathbf {x,z} )d\mathbf {z} }
  
.

Advantages of depth[edit]
  Schematic structure of an autoencoder with 3 fully connected hidden layers. The code (z, or h for reference in the text) is the most internal layer.
Autoencoders are often trained with a single layer encoder and a single layer decoder, but using many-layered (deep) encoders and decoders offers many advantages.[2]

Depth can exponentially reduce the computational cost of representing some functions.[2]
Depth can exponentially decrease the amount of training data needed to learn some functions.[2]
Experimentally, deep autoencoders yield better compression compared to shallow or linear autoencoders.[22]
Training[edit]
Geoffrey Hinton developed the deep belief network technique for training many-layered deep autoencoders. His method involves treating each neighbouring set of two layers as a restricted Boltzmann machine so that pretraining approximates a good solution, then using backpropagation to fine-tune the results.[22] 
Researchers have debated whether joint training (i.e. training the whole architecture together with a single global reconstruction objective to optimize) would be better for deep auto-encoders.[23] A 2015 study showed that joint training learns better data models along with more representative features for classification as compared to the layerwise method.[23] However, their experiments showed that the success of joint training depends heavily on the regularization strategies adopted.[23][24]

Applications[edit]
The two main applications of autoencoders are dimensionality reduction and information retrieval,[2] but modern variations have been applied to other tasks.

Dimensionality reduction[edit]
  Plot of the first two Principal Components (left) and a two-dimension hidden layer of a Linear Autoencoder (Right) applied to the Fashion MNIST dataset.[25] The two models being both linear learn to span the same subspace. The projection of the data points is indeed identical, apart from rotation of the subspace - to which PCA is invariant.Dimensionality reduction was one of the first deep learning applications.[2]
For Hinton's 2006 study,[22] he pretrained a multi-layer autoencoder with a stack of RBMs and then used their weights to initialize a deep autoencoder with gradually smaller hidden layers until hitting a bottleneck of 30 neurons. The resulting 30 dimensions of the code yielded a smaller reconstruction error compared to the first 30 components of a principal component analysis (PCA), and learned a representation that was qualitatively easier to interpret, clearly separating data clusters.[2][22]
Representing dimensions can improve performance on tasks such as classification.[2] Indeed, the hallmark of dimensionality reduction is to place semantically related examples near each other.[26]

Principal component analysis[edit]
  Reconstruction of 28x28pixel images by an Autoencoder with a code size of two (two-units hidden layer) and the reconstruction from the first two Principal Components of PCA. Images come from the Fashion MNIST dataset.[25]
If linear activations are used, or only a single sigmoid hidden layer, then the optimal solution to an autoencoder is strongly related to principal component analysis (PCA).[27][28] The weights of an autoencoder with a single hidden layer of size 
  
    
      
        p
      
    
    {\displaystyle p}
  
 (where 
  
    
      
        p
      
    
    {\displaystyle p}
  
 is less than the size of the input) span the same vector subspace as the one spanned by the first 
  
    
      
        p
      
    
    {\displaystyle p}
  
 principal components, and the output of the autoencoder is an orthogonal projection onto this subspace. The autoencoder weights are not equal to the principal components, and are generally not orthogonal, yet the principal components may be recovered from them using the singular value decomposition.[29]
However, the potential of autoencoders resides in their non-linearity, allowing the model to learn more powerful generalizations compared to PCA, and to reconstruct the input with significantly lower information loss.[22]

Information retrieval[edit]
Information retrieval benefits particularly from dimensionality reduction in that search can become more efficient in certain kinds of low dimensional spaces. Autoencoders were indeed applied to semantic hashing, proposed by Salakhutdinov and Hinton in 2007.[26] By training the algorithm to produce a low-dimensional binary code, all database entries could be stored in a hash table mapping binary code vectors to entries. This table would then support information retrieval by returning all entries with the same binary code as the query, or slightly less similar entries by flipping some bits from the query encoding.

Anomaly detection[edit]
Another application for autoencoders is anomaly detection.[30] [31][32][33][34] By learning to replicate the most salient features in the training data under some of the constraints described previously, the model is encouraged to learn to precisely reproduce the most frequently observed characteristics. When facing anomalies, the model should worsen its reconstruction performance. In most cases, only data with normal instances are used to train the autoencoder; in others, the frequency of anomalies is small compared to the observation set so that its contribution to the learned representation could be ignored. After training, the autoencoder will accurately reconstruct "normal" data, while failing to do so with unfamiliar anomalous data.[32] Reconstruction error (the error between the original data and its low dimensional reconstruction) is used as an anomaly score to detect anomalies.[32]
Recent literature has however shown that certain autoencoding models can, counterintuitively, be very good at reconstructing anomalous examples and consequently not able to reliably perform anomaly detection.[35][36]

Image processing[edit]
The characteristics of autoencoders are useful in image processing.
One example can be found in lossy image compression, where autoencoders outperformed other approaches and proved competitive against JPEG 2000.[37][38]
Another useful application of autoencoders in image preprocessing is image denoising.[39][40][41]
Autoencoders found use in more demanding contexts such as medical imaging where they have been used for image denoising[42] as well as super-resolution.[43][44] In image-assisted diagnosis, experiments have applied autoencoders for breast cancer detection[45] and for modelling the relation between the cognitive decline of Alzheimer's disease and the latent features of an autoencoder trained with MRI.[46]

Drug discovery[edit]
In 2019 molecules generated with variational autoencoders were validated experimentally in mice.[47][48]

Popularity prediction[edit]
Recently, a stacked autoencoder framework produced promising results in predicting popularity of social media posts,[49] which is helpful for online advertising strategies.

Machine translation[edit]
Autoencoders have been applied to machine translation, which is usually referred to as neural machine translation (NMT).[50][51] Unlike traditional autoencoders, the output does not match the input - it is in another language. In NMT, texts are treated as sequences to be encoded into the learning procedure, while on the decoder side sequences in the target language(s) are generated. Language-specific autoencoders incorporate further linguistic features into the learning procedure, such as Chinese decomposition features.[52]

See also[edit]
Representation learning
Sparse dictionary learning
Deep learning
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Kramer, Mark A. (1991). "Nonlinear principal component analysis using autoassociative neural networks" (PDF). AIChE Journal. 37 (2): 233â243. doi:10.1002/aic.690370209.

^ Jump up to: a b c d e f g h i j k l Goodfellow, Ian; Bengio, Yoshua; Courville, Aaron (2016). Deep Learning. MIT Press. ISBNÂ 978-0262035613.

^ Jump up to: a b c d e f Vincent, Pascal; Larochelle, Hugo (2010). "Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion". Journal of Machine Learning Research. 11: 3371â3408.

^ Welling, Max; Kingma, Diederik P. (2019). "An Introduction to Variational Autoencoders". Foundations and Trends in Machine Learning. 12 (4): 307â392. arXiv:1906.02691. Bibcode:2019arXiv190602691K. doi:10.1561/2200000056. S2CIDÂ 174802445.

^ Hinton GE, Krizhevsky A, Wang SD. Transforming auto-encoders. In International Conference on Artificial Neural Networks 2011 Jun 14 (pp. 44-51). Springer, Berlin, Heidelberg.

^ Jump up to: a b GÃ©ron, AurÃ©lien (2019). Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow. Canada: OâReilly Media, Inc. pp.Â 739â740.

^ Liou, Cheng-Yuan; Huang, Jau-Chi; Yang, Wen-Chie (2008). "Modeling word perception using the Elman network". Neurocomputing. 71 (16â18): 3150. doi:10.1016/j.neucom.2008.04.030.

^ Liou, Cheng-Yuan; Cheng, Wei-Chen; Liou, Jiun-Wei; Liou, Daw-Ran (2014). "Autoencoder for words". Neurocomputing. 139: 84â96. doi:10.1016/j.neucom.2013.09.055.

^ Schmidhuber, JÃ¼rgen (January 2015). "Deep learning in neural networks: An overview". Neural Networks. 61: 85â117. arXiv:1404.7828. doi:10.1016/j.neunet.2014.09.003. PMIDÂ 25462637. S2CIDÂ 11715509.

^ Hinton, G. E., & Zemel, R. S. (1994). Autoencoders, minimum description length and Helmholtz free energy. In Advances in neural information processing systems 6 (pp. 3-10).

^ Diederik P Kingma; Welling, Max (2013). "Auto-Encoding Variational Bayes". arXiv:1312.6114 [stat.ML].

^ Generating Faces with Torch, Boesen A., Larsen L. and Sonderby S.K., 2015 torch.ch/blog/2015/11/13/gan.html

^ Jump up to: a b Domingos, Pedro (2015). "4". The Master Algorithm: How the Quest for the Ultimate Learning Machine Will Remake Our World. Basic Books. "Deeper into the Brain" subsection. ISBNÂ 978-046506192-1.

^ Bengio, Y. (2009). "Learning Deep Architectures for AI" (PDF). Foundations and Trends in Machine Learning. 2 (8): 1795â7. CiteSeerXÂ 10.1.1.701.9550. doi:10.1561/2200000006. PMIDÂ 23946944.

^ Jump up to: a b Frey, Brendan; Makhzani, Alireza (2013-12-19). "k-Sparse Autoencoders". arXiv:1312.5663. Bibcode:2013arXiv1312.5663M. {{cite journal}}: Cite journal requires |journal= (help)

^ Jump up to: a b c Ng, A. (2011). Sparse autoencoder. CS294A Lecture notes, 72(2011), 1-19.

^ Nair, Vinod; Hinton, Geoffrey E. (2009). "3D Object Recognition with Deep Belief Nets". Proceedings of the 22Nd International Conference on Neural Information Processing Systems. NIPS'09. USA: Curran Associates Inc.: 1339â1347. ISBNÂ 9781615679119.

^ Zeng, Nianyin; Zhang, Hong; Song, Baoye; Liu, Weibo; Li, Yurong; Dobaie, Abdullah M. (2018-01-17). "Facial expression recognition via learning deep sparse autoencoders". Neurocomputing. 273: 643â649. doi:10.1016/j.neucom.2017.08.043. ISSNÂ 0925-2312.

^ Arpit, Devansh; Zhou, Yingbo; Ngo, Hung; Govindaraju, Venu (2015). "Why Regularized Auto-Encoders learn Sparse Representation?". arXiv:1505.05561 [stat.ML].

^ Jump up to: a b Makhzani, Alireza; Frey, Brendan (2013). "K-Sparse Autoencoders". arXiv:1312.5663 [cs.LG].

^ Abid, Abubakar; Balin, Muhammad Fatih; Zou, James (2019-01-27). "Concrete Autoencoders for Differentiable Feature Selection and Reconstruction". arXiv:1901.09346 [cs.LG].

^ Jump up to: a b c d e Hinton, G. E.; Salakhutdinov, R.R. (2006-07-28). "Reducing the Dimensionality of Data with Neural Networks". Science. 313 (5786): 504â507. Bibcode:2006Sci...313..504H. doi:10.1126/science.1127647. PMIDÂ 16873662. S2CIDÂ 1658773.

^ Jump up to: a b c Zhou, Yingbo; Arpit, Devansh; Nwogu, Ifeoma; Govindaraju, Venu (2014). "Is Joint Training Better for Deep Auto-Encoders?". arXiv:1405.1380 [stat.ML].

^ R. Salakhutdinov and G. E. Hinton, âDeep boltzmann machines,â in AISTATS, 2009, pp. 448â455.

^ Jump up to: a b "Fashion MNIST". GitHub. 2019-07-12.

^ Jump up to: a b Salakhutdinov, Ruslan; Hinton, Geoffrey (2009-07-01). "Semantic hashing". International Journal of Approximate Reasoning. Special Section on Graphical Models and Information Retrieval. 50 (7): 969â978. doi:10.1016/j.ijar.2008.11.006. ISSNÂ 0888-613X.

^ Bourlard, H.; Kamp, Y. (1988). "Auto-association by multilayer perceptrons and singular value decomposition". Biological Cybernetics. 59 (4â5): 291â294. doi:10.1007/BF00332918. PMIDÂ 3196773. S2CIDÂ 206775335.

^ Chicco, Davide; Sadowski, Peter; Baldi, Pierre (2014). "Deep autoencoder neural networks for gene ontology annotation predictions". Proceedings of the 5th ACM Conference on Bioinformatics, Computational Biology, and Health Informatics - BCB '14. p.Â 533. doi:10.1145/2649387.2649442. hdl:11311/964622. ISBNÂ 9781450328944. S2CIDÂ 207217210.

^ Plaut, E (2018). "From Principal Subspaces to Principal Components with Linear Autoencoders". arXiv:1804.10253 [stat.ML].

^  Morales-Forero, A., & Bassetto, S. (2019, December). Case Study: A Semi-Supervised Methodology for Anomaly Detection and Diagnosis. In 2019 IEEE International Conference on Industrial Engineering and Engineering Management (IEEM) (p. 4) (pp. 1031-1037). IEEE.

^ Sakurada, M., & Yairi, T. (2014, December). Anomaly detection using autoencoders with nonlinear dimensionality reduction. In Proceedings of the MLSDA 2014 2nd Workshop on Machine Learning for Sensory Data Analysis (p. 4). ACM.

^ Jump up to: a b c An, J., & Cho, S. (2015). Variational autoencoder based anomaly detection using reconstruction probability. Special Lecture on IE, 2, 1-18.

^ Zhou, C., & Paffenroth, R. C. (2017, August). Anomaly detection with robust deep autoencoders. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 665-674). ACM.

^ Ribeiro, ManassÃ©s; Lazzaretti, AndrÃ© EugÃªnio; Lopes, Heitor SilvÃ©rio (2018). "A study of deep convolutional auto-encoders for anomaly detection in videos". Pattern Recognition Letters. 105: 13â22. Bibcode:2018PaReL.105...13R. doi:10.1016/j.patrec.2017.07.016.

^ Nalisnick, Eric; Matsukawa, Akihiro; Teh, Yee Whye; Gorur, Dilan; Lakshminarayanan, Balaji (2019-02-24). "Do Deep Generative Models Know What They Don't Know?". arXiv:1810.09136 [stat.ML].

^ Xiao, Zhisheng; Yan, Qing; Amit, Yali (2020). "Likelihood Regret: An Out-of-Distribution Detection Score For Variational Auto-encoder". Advances in Neural Information Processing Systems. 33. arXiv:2003.02977.

^ Theis, Lucas; Shi, Wenzhe; Cunningham, Andrew; HuszÃ¡r, Ferenc (2017). "Lossy Image Compression with Compressive Autoencoders". arXiv:1703.00395 [stat.ML].

^ Balle, J; Laparra, V; Simoncelli, EP (April 2017). "End-to-end optimized image compression". International Conference on Learning Representations. arXiv:1611.01704.

^ Cho, K. (2013, February). Simple sparsification improves sparse denoising autoencoders in denoising highly corrupted images. In International Conference on Machine Learning (pp. 432-440).

^ Cho, Kyunghyun (2013). "Boltzmann Machines and Denoising Autoencoders for Image Denoising". arXiv:1301.3468 [stat.ML].

^ Buades, A.; Coll, B.; Morel, J. M. (2005). "A Review of Image Denoising Algorithms, with a New One". Multiscale Modeling & Simulation. 4 (2): 490â530. doi:10.1137/040616024.

^ Gondara, Lovedeep (December 2016). "Medical Image Denoising Using Convolutional Denoising Autoencoders". 2016 IEEE 16th International Conference on Data Mining Workshops (ICDMW). Barcelona, Spain: IEEE: 241â246. arXiv:1608.04667. Bibcode:2016arXiv160804667G. doi:10.1109/ICDMW.2016.0041. ISBNÂ 9781509059102. S2CIDÂ 14354973.

^ Zeng, Kun; Yu, Jun; Wang, Ruxin; Li, Cuihua; Tao, Dacheng (January 2017). "Coupled Deep Autoencoder for Single Image Super-Resolution". IEEE Transactions on Cybernetics. 47 (1): 27â37. doi:10.1109/TCYB.2015.2501373. ISSNÂ 2168-2267. PMIDÂ 26625442. S2CIDÂ 20787612.

^ Tzu-Hsi, Song; Sanchez, Victor; Hesham, EIDaly; Nasir M., Rajpoot (2017). "Hybrid deep autoencoder with Curvature Gaussian for detection of various types of cells in bone marrow trephine biopsy images". 2017 IEEE 14th International Symposium on Biomedical Imaging (ISBI 2017): 1040â1043. doi:10.1109/ISBI.2017.7950694. ISBNÂ 978-1-5090-1172-8. S2CIDÂ 7433130.

^ Xu, Jun; Xiang, Lei; Liu, Qingshan; Gilmore, Hannah; Wu, Jianzhong; Tang, Jinghai; Madabhushi, Anant (January 2016). "Stacked Sparse Autoencoder (SSAE) for Nuclei Detection on Breast Cancer Histopathology Images". IEEE Transactions on Medical Imaging. 35 (1): 119â130. doi:10.1109/TMI.2015.2458702. PMCÂ 4729702. PMIDÂ 26208307.

^ Martinez-Murcia, Francisco J.; Ortiz, Andres; Gorriz, Juan M.; Ramirez, Javier; Castillo-Barnes, Diego (2020). "Studying the Manifold Structure of Alzheimer's Disease: A Deep Learning Approach Using Convolutional Autoencoders". IEEE Journal of Biomedical and Health Informatics. 24 (1): 17â26. doi:10.1109/JBHI.2019.2914970. PMIDÂ 31217131. S2CIDÂ 195187846.

^ Zhavoronkov, Alex (2019). "Deep learning enables rapid identification of potent DDR1 kinase inhibitors". Nature Biotechnology. 37 (9): 1038â1040. doi:10.1038/s41587-019-0224-x. PMIDÂ 31477924. S2CIDÂ 201716327.

^ Gregory, Barber. "A Molecule Designed By AI Exhibits 'Druglike' Qualities". Wired.

^ De, Shaunak; Maity, Abhishek; Goel, Vritti; Shitole, Sanjay; Bhattacharya, Avik (2017). "Predicting the popularity of instagram posts for a lifestyle magazine using deep learning". 2017 2nd IEEE International Conference on Communication Systems, Computing and IT Applications (CSCITA). pp.Â 174â177. doi:10.1109/CSCITA.2017.8066548. ISBNÂ 978-1-5090-4381-1. S2CIDÂ 35350962.

^ Cho, Kyunghyun; Bart van Merrienboer; Bahdanau, Dzmitry; Bengio, Yoshua (2014). "On the Properties of Neural Machine Translation: Encoder-Decoder Approaches". arXiv:1409.1259 [cs.CL].

^ Sutskever, Ilya; Vinyals, Oriol; Le, Quoc V. (2014). "Sequence to Sequence Learning with Neural Networks". arXiv:1409.3215 [cs.CL].

^ Han, Lifeng; Kuang, Shaohui (2018). "Incorporating Chinese Radicals into Neural Machine Translation: Deeper Than Character Level". arXiv:1805.01565 [cs.CL].


.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}showvteDifferentiable computingGeneral
Differentiable programming
Neural Turing machine
Differentiable neural computer
Automatic differentiation
Neuromorphic engineering
Cable theory
Pattern recognition
Computational learning theory
Tensor calculus
Concepts
Gradient descent
SGD
Clustering
Regression
Overfitting
Adversary
Attention
Convolution
Loss functions
Backpropagation
Normalization
Activation
Softmax
Sigmoid
Rectifier
Regularization
Datasets
Augmentation
Programming languages
Python
Julia
Application
Machine learning
Artificial neural network
Deep learning
Scientific computing
Artificial Intelligence
Hardware
IPU
TPU
VPU
Memristor
SpiNNaker
Software library
TensorFlow
PyTorch
Keras
Theano
ImplementationAudio-visual
AlexNet
WaveNet
Human image synthesis
HWR
OCR
Speech synthesis
Speech recognition
Facial recognition
AlphaFold
DALL-E
Verbal
Word2vec
Transformer
BERT
NMT
Project Debater
Watson
GPT-2
GPT-3
Decisional
AlphaGo
AlphaZero
Q-learning
SARSA
OpenAI Five
Self-driving car
MuZero
Action selection
Robot control
People
Alex Graves
Ian Goodfellow
Yoshua Bengio
Geoffrey Hinton
Yann LeCun
Andrew Ng
Demis Hassabis
David Silver
Fei-Fei Li
Organizations
DeepMind
OpenAI
MIT CSAIL
Mila
Google Brain
FAIR

 Portals
Computer programming
Technology
 Category
Artificial neural networks
Machine learning

showvteNoise (physics and telecommunications)General
Acoustic quieting
Distortion
Noise cancellation
Noise control
Noise measurement
Noise power
Noise reduction
Noise temperature
Phase distortion
Noise in...
Audio
Buildings
Electronics
Environment
Government regulation
Human health
Images
Radio
Rooms
Ships
Sound masking
Transportation
Video
Class of noise
Additive white Gaussian noise (AWGN)
Atmospheric noise
Background noise
Brownian noise
Burst noise
Cosmic noise
Flicker noise
Gaussian noise
Grey noise
Jitter
JohnsonâNyquist noise (thermal noise)
Pink noise
Quantization error (or q. noise)
Shot noise
White noise
Coherent noise
Value noise
Gradient noise
Worley noise
Engineering terms
Channel noise level
Circuit noise level
Effective input noise temperature
Equivalent noise resistance
Equivalent pulse code modulation noise
Impulse noise (audio)
Noise figure
Noise floor
Noise shaping
Noise spectral density
Noise, vibration, and harshness (NVH)
Phase noise
Pseudorandom noise
Statistical noise
Ratios
Carrier-to-noise ratio (C/N)
Carrier-to-receiver noise density (C/kT)
dBrnC
Eb/N0 (energy per bit to noise density)
Es/N0 (energy per symbol to noise density)
Modulation error ratio (MER)
Signal, noise and distortion (SINAD)
Signal-to-interference ratio (S/I)
Signal-to-noise ratio (S/N,Â SNR)
Signal-to-noise ratio (imaging)
Signal-to-interference-plus-noise ratio (SINR)
Signal-to-quantization-noise ratio (SQNR)
Contrast-to-noise ratio (CNR)
Related topics
List of noise topics
Acoustics
Colors of noise
Interference (communication)
Noise generator
Spectrum analyzer
Thermal radiation
Denoise methodsGeneral
Low-pass filter
Median filter
Total variation denoising
Wavelet denoising
2D (Image)
Gaussian blur
Anisotropic diffusion
Bilateral filter
Non-local means
Block-matching and 3D filtering (BM3D)
Shrinkage Fields
Denoising autoencoder (DAE)
Deep Image Prior





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Autoencoder&oldid=1068573765"
		Categories: Artificial neural networksUnsupervised learningDimension reductionHidden categories: CS1 errors: missing periodicalArticles with short descriptionShort description matches WikidataUse dmy dates from March 2020
	
