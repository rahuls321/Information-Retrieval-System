In mathematics, particularly linear algebra and numerical analysis, the Gram–Schmidt process is a method for orthonormalizing a set of vectors in an inner product space, most commonly the Euclidean space Rn equipped with the standard inner product. The Gram–Schmidt process takes a finite, linearly independent set of vectors S = {v1, ..., vk} for k ≤ n and generates an orthogonal set S′ = {u1, ..., uk} that spans the same k-dimensional subspace of Rn as S.The method is named after Jørgen Pedersen Gram and Erhard Schmidt, but Pierre-Simon Laplace had been familiar with it before Gram and Schmidt. In the theory of Lie group decompositions it is generalized by the Iwasawa decomposition.The application of the Gram–Schmidt process to the column vectors of a full column rank matrix yields the QR decomposition (it is decomposed into an orthogonal and a triangular matrix). The Gram–Schmidt process We define the projection operator bywhere                     ⟨                  u                ,                  v                ⟩              {\displaystyle \langle \mathbf {u} ,\mathbf {v} \rangle }   denotes the inner product of the vectors u and v. This operator projects the vector v orthogonally onto the line spanned by vector u. If u = 0, we define                               proj                                    0                                      ⁡        (                  v                )        :=                  0                      {\displaystyle \operatorname {proj} _{\mathbf {0} }(\mathbf {v} ):=\mathbf {0} }  , i.e., the projection map                               proj                                    0                                            {\displaystyle \operatorname {proj} _{\mathbf {0} }}   is the zero map, sending every vector to the zero vector.The Gram–Schmidt process then works as follows:The sequence u1, ..., uk is the required system of orthogonal vectors, and the normalized vectors e1, ..., ek form an orthonormal set. The calculation of the sequence u1, ..., uk is known as Gram–Schmidt orthogonalization, while the calculation of the sequence e1, ..., ek is known as Gram–Schmidt orthonormalization as the vectors are normalized.To check that these formulas yield an orthogonal sequence, first compute                     ⟨                              u                                1                          ,                              u                                2                          ⟩              {\displaystyle \langle \mathbf {u} _{1},\mathbf {u} _{2}\rangle }   by substituting the above formula for u2: we get zero. Then use this to compute                     ⟨                              u                                1                          ,                              u                                3                          ⟩              {\displaystyle \langle \mathbf {u} _{1},\mathbf {u} _{3}\rangle }   again by substituting the formula for u3: we get zero. The general proof proceeds by mathematical induction.Geometrically, this method proceeds as follows: to compute ui, it projects vi orthogonally onto the subspace U generated by u1, ..., ui−1, which is the same as the subspace generated by v1, ..., vi−1. The vector ui is then defined to be the difference between vi and this projection, guaranteed to be orthogonal to all of the vectors in the subspace U.The Gram–Schmidt process also applies to a linearly independent countably infinite sequence {vi}i. The result is an orthogonal (or orthonormal) sequence {ui}i such that for natural number n:the algebraic span of v1, ..., vn is the same as that of u1, ..., un.If the Gram–Schmidt process is applied to a linearly dependent sequence, it outputs the 0 vector on the ith step, assuming that vi is a linear combination of v1, ..., vi−1. If an orthonormal basis is to be produced, then the algorithm should test for zero vectors in the output and discard them because no multiple of a zero vector can have a length of 1. The number of vectors output by the algorithm will then be the dimension of the space spanned by the original inputs.A variant of the Gram–Schmidt process using transfinite recursion applied to a (possibly uncountably) infinite sequence of vectors                     (                  v                      α                                    )                      α            <            λ                                {\displaystyle (v_{\alpha })_{\alpha <\lambda }}   yields a set of orthonormal vectors                     (                  u                      α                                    )                      α            <            κ                                {\displaystyle (u_{\alpha })_{\alpha <\kappa }}   with                     κ        ≤        λ              {\displaystyle \kappa \leq \lambda }   such that for any                     α        ≤        λ              {\displaystyle \alpha \leq \lambda }  , the completion of the span of                     {                  u                      β                          :        β        <        min        (        α        ,        κ        )        }              {\displaystyle \{u_{\beta }:\beta <\min(\alpha ,\kappa )\}}   is the same as that of                     {                  v                      β                          :        β        <        α        }              {\displaystyle \{v_{\beta }:\beta <\alpha \}}  . In particular, when applied to a (algebraic) basis of a Hilbert space (or, more generally, a basis of any dense subspace), it yields a (functional-analytic) orthonormal basis. Note that in the general case often the strict inequality                     κ        <        λ              {\displaystyle \kappa <\lambda }   holds, even if the starting set was linearly independent, and the span of                     (                  u                      α                                    )                      α            <            κ                                {\displaystyle (u_{\alpha })_{\alpha <\kappa }}   need not be a subspace of the span of                     (                  v                      α                                    )                      α            <            λ                                {\displaystyle (v_{\alpha })_{\alpha <\lambda }}   (rather, it's a subspace of its completion). Example = Euclidean space =Consider the following set of vectors in R2 (with the conventional inner product)Now, perform Gram–Schmidt, to obtain an orthogonal set of vectors:We check that the vectors u1 and u2 are indeed orthogonal:noting that if the dot product of two vectors is 0 then they are orthogonal.For non-zero vectors, we can then normalize the vectors by dividing out their sizes as shown above: Properties Denote by                     GS        ⁡        (                              v                                1                          ,        …        ,                              v                                k                          )              {\displaystyle \operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})}   the result of applying the Gram–Schmidt process to a collection of vectors                                           v                                1                          ,        …        ,                              v                                k                                {\displaystyle \mathbf {v} _{1},\dots ,\mathbf {v} _{k}}  . This yields a map                     GS        :        (                              R                                n                                    )                      k                          →        (                              R                                n                                    )                      k                                {\displaystyle \operatorname {GS} \colon (\mathbb {R} ^{n})^{k}\to (\mathbb {R} ^{n})^{k}}  .It has the following properties:It is continuousIt is orientation preserving in the sense that                     or        ⁡        (                              v                                1                          ,        …        ,                              v                                k                          )        =        or        ⁡        (        GS        ⁡        (                              v                                1                          ,        …        ,                              v                                k                          )        )              {\displaystyle \operatorname {or} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k})=\operatorname {or} (\operatorname {GS} (\mathbf {v} _{1},\dots ,\mathbf {v} _{k}))}  .It commutes with orthogonal maps:Let                     g        :                              R                                n                          →                              R                                n                                {\displaystyle g\colon \mathbb {R} ^{n}\to \mathbb {R} ^{n}}   be orthogonal (with respect to the given inner product). Then we haveFurther a parametrized version of the Gram–Schmidt process yields a (strong) deformation retraction of the general linear group                               G          L                (                              R                                n                          )              {\displaystyle \mathrm {GL} (\mathbb {R} ^{n})}   onto the orthogonal group                     O        (                              R                                n                          )              {\displaystyle O(\mathbb {R} ^{n})}  . Numerical stability When this process is implemented on a computer, the vectors                                           u                                k                                {\displaystyle \mathbf {u} _{k}}   are often not quite orthogonal, due to rounding errors. For the Gram–Schmidt process as described above (sometimes referred to as "classical Gram–Schmidt") this loss of orthogonality is particularly bad; therefore, it is said that the (classical) Gram–Schmidt process is numerically unstable.The Gram–Schmidt process can be stabilized by a small modification; this version is sometimes referred to as modified Gram-Schmidt or MGS. This approach gives the same result as the original formula in exact arithmetic and introduces smaller errors in finite-precision arithmetic.Instead of computing the vector uk asit is computed asThis method is used in the previous animation, when the intermediate v'3 vector is used when orthogonalizing the blue vector v3.Here is another description of the modified algorithm. Given the vectors                               v                      1                          ,                  v                      2                          ,        …        ,                  v                      n                                {\displaystyle v_{1},v_{2},\dots ,v_{n}}  , in our first step we produce vectors                               v                      1                          ,                  v                      2                                (            1            )                          ,        …        ,                  v                      n                                (            1            )                                {\displaystyle v_{1},v_{2}^{(1)},\dots ,v_{n}^{(1)}}  by removing components along the direction of                               v                      1                                {\displaystyle v_{1}}  . In formulas,                               v                      k                                (            1            )                          :=                  v                      k                          −                                            ⟨                              v                                  k                                            ,                              v                                  1                                            ⟩                                      ⟨                              v                                  1                                            ,                              v                                  1                                            ⟩                                                v                      1                                {\displaystyle v_{k}^{(1)}:=v_{k}-{\frac {\langle v_{k},v_{1}\rangle }{\langle v_{1},v_{1}\rangle }}v_{1}}  . After this step we already have two of our desired orthogonal vectors                               u                      1                          ,        …        ,                  u                      n                                {\displaystyle u_{1},\dots ,u_{n}}  , namely                               u                      1                          =                  v                      1                          ,                  u                      2                          =                  v                      2                                (            1            )                                {\displaystyle u_{1}=v_{1},u_{2}=v_{2}^{(1)}}  , but we also made                               v                      3                                (            1            )                          ,        …        ,                  v                      n                                (            1            )                                {\displaystyle v_{3}^{(1)},\dots ,v_{n}^{(1)}}   already orthogonal to                               u                      1                                {\displaystyle u_{1}}  . Next, we orthogonalize those remaining vectors against                               u                      2                          =                  v                      2                                (            1            )                                {\displaystyle u_{2}=v_{2}^{(1)}}  . This means we compute                               v                      3                                (            2            )                          ,                  v                      4                                (            2            )                          ,        …        ,                  v                      n                                (            2            )                                {\displaystyle v_{3}^{(2)},v_{4}^{(2)},\dots ,v_{n}^{(2)}}   by subtraction                               v                      k                                (            2            )                          :=                  v                      k                                (            1            )                          −                                            ⟨                              v                                  k                                                  (                  1                  )                                            ,                              u                                  2                                            ⟩                                      ⟨                              u                                  2                                            ,                              u                                  2                                            ⟩                                                u                      2                                {\displaystyle v_{k}^{(2)}:=v_{k}^{(1)}-{\frac {\langle v_{k}^{(1)},u_{2}\rangle }{\langle u_{2},u_{2}\rangle }}u_{2}}  . Now we have stored the vectors                               v                      1                          ,                  v                      2                                (            1            )                          ,                  v                      3                                (            2            )                          ,                  v                      4                                (            2            )                          ,        …        ,                  v                      n                                (            2            )                                {\displaystyle v_{1},v_{2}^{(1)},v_{3}^{(2)},v_{4}^{(2)},\dots ,v_{n}^{(2)}}   where the first three vectors are already                               u                      1                          ,                  u                      2                          ,                  u                      3                                {\displaystyle u_{1},u_{2},u_{3}}   and the remaining vectors are already orthogonal to                               u                      1                          ,                  u                      2                                {\displaystyle u_{1},u_{2}}  . As should be clear now, the next step orthogonalizes                               v                      4                                (            2            )                          ,        …        ,                  v                      n                                (            2            )                                {\displaystyle v_{4}^{(2)},\dots ,v_{n}^{(2)}}   against                               u                      3                          =                  v                      3                                (            2            )                                {\displaystyle u_{3}=v_{3}^{(2)}}  . Proceeding in this manner we find the full set of orthogonal vectors                               u                      1                          ,        …        ,                  u                      n                                {\displaystyle u_{1},\dots ,u_{n}}  . If orthonormal vectors are desired, then we normalize as we go, so that the denominators in the subtraction formulas turn into ones. Algorithm The following MATLAB algorithm implements the Gram–Schmidt orthonormalization for Euclidean Vectors. The vectors v1, ..., vk (columns of matrix V, so that V(:,j) is the jth vector) are replaced by orthonormal vectors (columns of U) which span the same subspace.The cost of this algorithm is asymptotically O(nk2) floating point operations, where n is the dimensionality of the vectors (Golub & Van Loan 1996, §5.2.8). Via Gaussian elimination If the rows {v1, ..., vk} are written as a matrix                     A              {\displaystyle A}  , then applying Gaussian elimination to the augmented matrix                               [                      A                          A                                                T                                                                    |                        A                    ]                      {\displaystyle \left[AA^{\mathsf {T}}|A\right]}   will produce the orthogonalized vectors in place of                     A              {\displaystyle A}  . However the matrix                     A                  A                                    T                                            {\displaystyle AA^{\mathsf {T}}}   must be brought to row echelon form, using only the row operation of adding a scalar multiple of one row to another. For example, taking                                           v                                1                          =                              [                                                            3                                                  1                                                      ]                          ,                              v                                2                          =                              [                                                            2                                                  2                                                      ]                                {\displaystyle \mathbf {v} _{1}={\begin{bmatrix}3&1\end{bmatrix}},\mathbf {v} _{2}={\begin{bmatrix}2&2\end{bmatrix}}}   as above, we haveAnd reducing this to row echelon form producesThe normalized vectors are thenas in the example above. Determinant formula The result of the Gram–Schmidt process may be expressed in a non-recursive formula using determinants.where D0=1 and, for j ≥ 1, Dj is the Gram determinantNote that the expression for uk is a "formal" determinant, i.e. the matrix contains both scalarsand vectors; the meaning of this expression is defined to be the result of a cofactor expansion along the row of vectors.The determinant formula for the Gram-Schmidt is computationally slower (exponentially slower) than the recursive algorithms described above; it is mainly of theoretical interest. Alternatives Other orthogonalization algorithms use Householder transformations or Givens rotations. The algorithms using Householder transformations are more stable than the stabilized Gram–Schmidt process. On the other hand, the Gram–Schmidt process produces the                     j              {\displaystyle j}  th orthogonalized vector after the                     j              {\displaystyle j}  th iteration, while orthogonalization using Householder reflections produces all the vectors only at the end. This makes only the Gram–Schmidt process applicable for iterative methods like the Arnoldi iteration.Yet another alternative is motivated by the use of Cholesky decomposition for inverting the matrix of the normal equations in linear least squares. Let                     V              {\displaystyle V}   be a full column rank matrix, whose columns need to be orthogonalized. The matrix                               V                      ∗                          V              {\displaystyle V^{*}V}   is Hermitian and positive definite, so it can be written as                               V                      ∗                          V        =        L                  L                      ∗                          ,              {\displaystyle V^{*}V=LL^{*},}   using the Cholesky decomposition. The lower triangular matrix                     L              {\displaystyle L}   with strictly positive diagonal entries is invertible. Then columns of the matrix                     U        =        V                              (                          L                              −                1                                      )                                ∗                                {\displaystyle U=V\left(L^{-1}\right)^{*}}   are orthonormal and span the same subspace as the columns of the original matrix                     V              {\displaystyle V}  . The explicit use of the product                               V                      ∗                          V              {\displaystyle V^{*}V}   makes the algorithm unstable, especially if the product's condition number is large. Nevertheless, this algorithm is used in practice and implemented in some software packages because of its high efficiency and simplicity.In quantum mechanics there are several orthogonalization schemes with characteristics better suited for certain applications than original Gram–Schmidt. Nevertheless, it remains a popular and effective algorithm for even the largest electronic structure calculations. References  Sources Bau III, David; Trefethen, Lloyd N. (1997), Numerical linear algebra, Philadelphia: Society for Industrial and Applied Mathematics, ISBN 978-0-89871-361-9.Golub, Gene H.; Van Loan, Charles F. (1996), Matrix Computations (3rd ed.), Johns Hopkins, ISBN 978-0-8018-5414-9.Greub, Werner (1975), Linear Algebra (4th ed.), Springer.Soliverez, C. E.; Gagliano, E. (1985), "Orthonormalization on the plane: a geometric approach" (PDF), Mex. J. Phys., 31 (4): 743–758. External links "Orthogonalization", Encyclopedia of Mathematics, EMS Press, 2001 [1994]Harvey Mudd College Math Tutorial on the Gram-Schmidt algorithmEarliest known uses of some of the words of mathematics: G The entry "Gram-Schmidt orthogonalization" has some information and references on the origins of the method.Demos: Gram Schmidt process in plane and Gram Schmidt process in spaceGram-Schmidt orthogonalization appletNAG Gram–Schmidt orthogonalization of n vectors of order m routineProof: Raymond Puzio, Keenan Kidwell. "proof of Gram-Schmidt orthogonalization algorithm" (version 8). PlanetMath.org.