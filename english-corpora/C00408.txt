
Title:
Monte Carlo tree search
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Heuristic search algorithm for evaluating game trees
.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}Monte Carlo tree searchClassSearch algorithm
.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Graph and treesearch algorithms
Î±âÎ²
A*
B*
Backtracking
Beam
BellmanâFord
Best-first
Bidirectional
BorÅ¯vka
Branch & bound
BFS
British Museum
D*
DFS
Dijkstra
Edmonds
FloydâWarshall
Fringe search
Hill climbing
IDA*
Iterative deepening
Johnson
Jump point
Kruskal
Lexicographic BFS
LPA*
Prim
SMA*

Listings
Graph algorithms
Search algorithms
List of graph algorithms

Related topics
Dynamic programming
Graph traversal
Tree traversal
Search games
Graph coloring
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
In computer science, Monte Carlo tree search (MCTS) is a heuristic search algorithm for some kinds of decision processes, most notably those employed in software that plays board games. In that context MCTS is used to solve the game tree. 
MCTS was combined with neural networks in 2016 for computer Go.[1] It has been used in other board games like chess and shogi,[2] games with incomplete information such as bridge[3] and poker,[4] as well as in turn-based-strategy video games (such as Total War: Rome II's implementation in the high level campaign AI[5]). MCTS has also been used in self-driving cars, for example in Tesla's Autopilot software.[6]

Contents

1 History

1.1 Monte Carlo method
1.2 Monte Carlo tree search (MCTS)


2 Principle of operation
3 Pure Monte Carlo game search
4 Exploration and exploitation
5 Advantages and disadvantages
6 Improvements
7 See also
8 References
9 Bibliography
10 External links



History[edit]
Monte Carlo method[edit]
The Monte Carlo method, which uses random sampling for deterministic problems which are difficult or impossible to solve using other approaches, dates back to the 1940s.[7] In his 1987 PhD thesis, Bruce Abramson combined minimax search with an expected-outcome model based on random game playouts to the end, instead of the usual static evaluation function. Abramson said the expected-outcome model "is shown to be precise, accurate, easily estimable, efficiently calculable, and domain-independent."[8]  He experimented in-depth with tic-tac-toe and then with machine-generated evaluation functions for Othello and chess.
Such methods were then explored and successfully applied to heuristic search in the field of automated theorem proving by W. Ertel, J. Schumann and C. Suttner in 1989,[9][10][11] thus improving the exponential search times of uninformed search algorithms such as e.g. breadth-first search, depth-first search or iterative deepening.
In 1992, B. BrÃ¼gmann employed it for the first time in a Go-playing program.[12] In 2002, Chang et al.[13] proposed the idea of "recursive rolling out and backtracking" with "adaptive" sampling choices in their Adaptive Multi-stage Sampling (AMS) algorithm for the model of Markov decision processes. AMS was the first work to explore the idea of UCB-based exploration and exploitation in constructing sampled/simulated (Monte Carlo) trees and was the main seed for UCT (Upper Confidence Trees).[14]

Monte Carlo tree search (MCTS)[edit]
  The rating of best Go-playing programs on the KGS server since 2007. Since 2006, all the best programs use Monte Carlo tree search.[15]
In 2006, inspired by these predecessors,[16] RÃ©mi Coulom described the application of the Monte Carlo method to game-tree search and coined the name Monte Carlo tree search,[17] L. Kocsis and Cs. SzepesvÃ¡ri developed the UCT (Upper Confidence bounds applied to Trees) algorithm,[18] and S. Gelly et al. implemented UCT in their program MoGo.[19] In 2008, MoGo achieved dan (master) level in 9Ã9 Go,[20] and the Fuego program began to win against strong amateur players in 9Ã9 Go.[21]
In January 2012, the Zen program won 3:1 in a Go match on a 19Ã19 board with an amateur 2 dan player.[22] Google Deepmind developed the program AlphaGo, which in October 2015 became the first Computer Go program to beat a professional human Go player without handicaps on a full-sized 19x19 board.[1][23][24] In March 2016, AlphaGo was awarded an honorary 9-dan (master) level in 19Ã19 Go for defeating Lee Sedol in a five-game match with a final score of four games to one.[25] AlphaGo represents a significant improvement over previous Go programs as well as a milestone in machine learning as it uses Monte Carlo tree search with artificial neural networks (a deep learning method) for policy (move selection) and value, giving it efficiency far surpassing previous programs.[26]
MCTS algorithm has also been used in programs that play other board games (for example Hex,[27] Havannah,[28] Game of the Amazons,[29] and Arimaa[30]), real-time video games (for instance Ms. Pac-Man[31][32] and Fable Legends[33]), and nondeterministic games (such as skat,[34] poker,[4] Magic: The Gathering,[35] or Settlers of Catan[36]).

Principle of operation[edit]
The focus of MCTS is on the analysis of the most promising moves, expanding the search tree based on random sampling of the search space.
The application of Monte Carlo tree search in games is based on many playouts, also called roll-outs. In each playout, the game is played out to the very end by selecting moves at random. The final game result of each playout is then used to weight the nodes in the game tree so that better nodes are more likely to be chosen in future playouts.
The most basic way to use playouts is to apply the same number of playouts after each legal move of the current player, then choose the move which led to the most victories.[12] The efficiency of this methodâcalled Pure Monte Carlo Game Searchâoften increases with time as more playouts are assigned to the moves that have frequently resulted in the current player's victory according to previous playouts. Each round of Monte Carlo tree search consists of four steps:[37]

Selection: Start from root R and select successive child nodes until a leaf node L is reached. The root is the current game state and a leaf is any node that has a potential child from which no simulation (playout) has yet been initiated. The section below says more about a way of biasing choice of child nodes that lets the game tree expand towards the most promising moves, which is the essence of Monte Carlo tree search.
Expansion: Unless L ends the game decisively (e.g. win/loss/draw) for either player, create one (or more) child nodes and choose node C from one of them. Child nodes are any valid moves from the game position defined by L.
Simulation: Complete one random playout from node C. This step is sometimes also called playout or rollout. A playout may be as simple as choosing uniform random moves until the game is decided (for example in chess, the game is won, lost, or drawn).
Backpropagation: Use the result of the playout to update information in the nodes on the path from C to R.
  Step of Monte Carlo tree search.
This graph shows the steps involved in one decision, with each node showing the ratio of wins to total playouts from that point in the game tree for the player that the node represents.[38] In the Selection diagram, black is about to move. The root node shows there are 11 wins out of 21 playouts for white from this position so far. It complements the total of 10/21 black wins shown along the three black nodes under it, each of which represents a possible black move.
If white loses the simulation, all nodes along the selection incremented their simulation count (the denominator), but among them only the black nodes were credited with wins (the numerator). If instead white wins, all nodes along the selection would still increment their simulation count, but among them only the white nodes would be credited with wins. In games where draws are possible, a draw causes the numerator for both black and white to be incremented by 0.5 and the denominator by 1. This ensures that during selection, each player's choices expand towards the most promising moves for that player, which mirrors the goal of each player to maximize the value of their move.
Rounds of search are repeated as long as the time allotted to a move remains. Then the move with the most simulations made (i.e. the highest denominator) is chosen as the final answer.

Pure Monte Carlo game search[edit]
This basic procedure can be applied to any game whose positions necessarily have a finite number of moves and finite length. For each position, all feasible moves are determined: k random games are played out to the very end, and the scores are recorded. The move leading to the best score is chosen. Ties are broken by fair coin flips. Pure Monte Carlo Game Search results in strong play in several games with random elements, as in the game EinStein wÃ¼rfelt nicht!. It converges to optimal play (as k tends to infinity) in board filling games with random turn order, for instance in Hex with random turn order.[39] DeepMind's AlphaZero replaces the simulation step with an evaluation based on a neural network.[2]

Exploration and exploitation[edit]
The main difficulty in selecting child nodes is maintaining some balance between the exploitation of deep variants after moves with high average win rate and the exploration of moves with few simulations. The first formula for balancing exploitation and exploration in games, called UCT (Upper Confidence Bound 1 applied to trees), was introduced by Levente Kocsis and Csaba SzepesvÃ¡ri.[18] UCT is based on the UCB1 formula derived by Auer, Cesa-Bianchi, and Fischer[40] and the provably convergent AMS (Adaptive Multi-stage Sampling) algorithm first applied to multi-stage decision-making models (specifically, Markov Decision Processes) by Chang, Fu, Hu, and Marcus.[13] Kocsis and SzepesvÃ¡ri recommend to choose in each node of the game tree the move for which the expression 
  
    
      
        
          
            
              w
              
                i
              
            
            
              n
              
                i
              
            
          
        
        +
        c
        
          
            
              
                ln
                â¡
                
                  N
                  
                    i
                  
                
              
              
                n
                
                  i
                
              
            
          
        
      
    
    {\displaystyle {\frac {w_{i}}{n_{i}}}+c{\sqrt {\frac {\ln N_{i}}{n_{i}}}}}
  
 has the highest value. In this formula:

wi stands for the number of wins for the node considered after the i-th move
ni stands for the number of simulations for the node considered after the i-th move
Ni stands for the total number of simulations after the i-th move run by the parent node of the one considered
c is the exploration parameterâtheoretically equal to â2; in practice usually chosen empirically
The first component of the formula above corresponds to exploitation; it is high for moves with high average win ratio. The second component corresponds to exploration; it is high for moves with few simulations.
Most contemporary implementations of Monte Carlo tree search are based on some variant of UCT that traces its roots back to the AMS simulation optimization algorithm for estimating the value function in finite-horizon Markov Decision Processes (MDPs) introduced by Chang et al.[13] (2005) in Operations Research. (AMS was the first work to explore the idea of UCB-based exploration and exploitation in constructing sampled/simulated (Monte Carlo) trees and was the main seed for UCT.[14])

Advantages and disadvantages[edit]
Although it has been proven that the evaluation of moves in Monte Carlo tree search converges to minimax,[41] the basic version of Monte Carlo tree search converges only in so called "Monte Carlo Perfect" games.[42] However Monte Carlo tree search does offer significant advantages over alphaâbeta pruning and similar algorithms that minimize the search space.
In particular, pure Monte Carlo tree search does not need an explicit evaluation function. Simply implementing the game's mechanics is sufficient to explore the search space (i.e. the generating of allowed moves in a given position and the game-end conditions). As such, Monte Carlo tree search can be employed in games without a developed theory or in general game playing.
The game tree in Monte Carlo tree search grows asymmetrically as the method concentrates on the more promising subtrees. Thus[dubious  â discuss] it achieves better results than classical algorithms in games with a high branching factor.
A disadvantage is that in certain positions, there may be moves that look superficially strong, but that actually lead to a loss via a subtle line of play. Such "trap states" require thorough analysis to be handled correctly, particularly when playing against an expert player; however, MCTS may not "see" such lines due to its policy of selective node expansion.[43][44] It is believed that this may have been part of the reason for AlphaGo's loss in its fourth game against Lee Sedol. In essence, the search attempts to prune sequences which are less relevant. In some cases, a play can lead to a very specific line of play which is significant, but which is overlooked when the tree is pruned, and this outcome is therefore "off the search radar".[45]

Improvements[edit]
Various modifications of the basic Monte Carlo tree search method have been proposed to shorten the search time. Some employ domain-specific expert knowledge, others do not.
Monte Carlo tree search can use either light or heavy playouts. Light playouts consist of random moves while heavy playouts apply various heuristics to influence the choice of moves.[46] These heuristics may employ the results of previous playouts (e.g. the Last Good Reply heuristic[47]) or expert knowledge of a given game. For instance, in many Go-playing programs certain stone patterns in a portion of the board influence the probability of moving into that area.[19] Paradoxically, playing suboptimally in simulations sometimes makes a Monte Carlo tree search program play stronger overall.[48]

  Patterns of hane (surrounding opponent stones) used in playouts by the MoGo program. It is advantageous for both black and white to put a stone on the middle square, except the rightmost pattern where it favors black only.[19]
Domain-specific knowledge may be employed when building the game tree to help the exploitation of some variants. One such method assigns nonzero priors to the number of won and played simulations when creating each child node, leading to artificially raised or lowered average win rates that cause the node to be chosen more or less frequently, respectively, in the selection step.[49] A related method, called progressive bias, consists in adding to the UCB1 formula a 
  
    
      
        
          
            
              b
              
                i
              
            
            
              n
              
                i
              
            
          
        
      
    
    {\displaystyle {\frac {b_{i}}{n_{i}}}}
  
 element, where bi is a heuristic score of the  i-th move.[37]
The basic Monte Carlo tree search collects enough information to find the most promising moves only after many rounds; until then its moves are essentially random. This exploratory phase may be reduced significantly in a certain class of games using RAVE (Rapid Action Value Estimation).[49] In these games, permutations of a sequence of moves lead to the same position. Typically, they are board games in which a move involves placement of a piece or a stone on the board. In such games the value of each move is often only slightly influenced by other moves.
In RAVE, for a given game tree node N, its child nodes Ci store not only the statistics of wins in playouts started in node N but also the statistics of wins in all playouts started in node N and below it, if they contain move i (also when the move was played in the tree, between node N and a playout). This way the contents of tree nodes are influenced not only by moves played immediately in a given position but also by the same moves played later.

  RAVE on the example of tic-tac-toe. In red nodes, the RAVE statistics will be updated after the b1-a2-b3 simulation.
When using RAVE, the selection step selects the node, for which the modified UCB1 formula 
  
    
      
        (
        1
        â
        Î²
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        )
        
          
            
              w
              
                i
              
            
            
              n
              
                i
              
            
          
        
        +
        Î²
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        
          
            
              
                
                  
                    w
                    ~
                  
                
              
              
                i
              
            
            
              
                
                  
                    n
                    ~
                  
                
              
              
                i
              
            
          
        
        +
        c
        
          
            
              
                ln
                â¡
                t
              
              
                n
                
                  i
                
              
            
          
        
      
    
    {\displaystyle (1-\beta (n_{i},{\tilde {n}}_{i})){\frac {w_{i}}{n_{i}}}+\beta (n_{i},{\tilde {n}}_{i}){\frac {{\tilde {w}}_{i}}{{\tilde {n}}_{i}}}+c{\sqrt {\frac {\ln t}{n_{i}}}}}
  
 has the highest value. In this formula, 
  
    
      
        
          
            
              
                w
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {w}}_{i}}
  
 and 
  
    
      
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {n}}_{i}}
  
 stand for the number of won playouts containing move i and the number of all playouts containing move i, and the 
  
    
      
        Î²
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})}
  
 function should be close to one and to zero for relatively small and relatively big ni and 
  
    
      
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
      
    
    {\displaystyle {\tilde {n}}_{i}}
  
, respectively. One of many formulas for 
  
    
      
        Î²
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})}
  
, proposed by D. Silver,[50] says that in balanced positions one can take 
  
    
      
        Î²
        (
        
          n
          
            i
          
        
        ,
        
          
            
              
                n
                ~
              
            
          
          
            i
          
        
        )
        =
        
          
            
              
                
                  
                    n
                    ~
                  
                
              
              
                i
              
            
            
              
                n
                
                  i
                
              
              +
              
                
                  
                    
                      n
                      ~
                    
                  
                
                
                  i
                
              
              +
              4
              
                b
                
                  2
                
              
              
                n
                
                  i
                
              
              
                
                  
                    
                      n
                      ~
                    
                  
                
                
                  i
                
              
            
          
        
      
    
    {\displaystyle \beta (n_{i},{\tilde {n}}_{i})={\frac {{\tilde {n}}_{i}}{n_{i}+{\tilde {n}}_{i}+4b^{2}n_{i}{\tilde {n}}_{i}}}}
  
, where b is an empirically chosen constant.
Heuristics used in Monte Carlo tree search often require many parameters. There are automated methods to tune the parameters to maximize the win rate.[51]
Monte Carlo tree search can be concurrently executed by many threads or processes. There are several fundamentally different methods of its parallel execution:[52]

Leaf parallelization, i.e. parallel execution of many playouts from one leaf of the game tree.
Root parallelization, i.e. building independent game trees in parallel and making the move basing on the root-level branches of all these trees.
Tree parallelization, i.e. parallel building of the same game tree, protecting data from simultaneous writes either with one, global mutex, with more mutexes, or with non-blocking synchronization.[53]
See also[edit]
AlphaGo, a Go program using Monte Carlo tree search, reinforcement learning and deep learning.
AlphaGo Zero, an updated Go program using Monte Carlo tree search, reinforcement learning and deep learning.
AlphaZero, a generalized version of AlphaGo Zero using Monte Carlo tree search, reinforcement learning and deep learning.
Leela Chess Zero, a free software implementation of AlphaZero's methods to chess, which is currently among the leading chess playing programs.
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Silver, David; Huang, Aja; Maddison, Chris J.; Guez, Arthur; Sifre, Laurent; Driessche, George van den; Schrittwieser, Julian; Antonoglou, Ioannis; Panneershelvam, Veda; Lanctot, Marc; Dieleman, Sander; Grewe, Dominik; Nham, John; Kalchbrenner, Nal; Sutskever, Ilya; Lillicrap, Timothy; Leach, Madeleine; Kavukcuoglu, Koray; Graepel, Thore; Hassabis, Demis (28 January 2016). "Mastering the game of Go with deep neural networks and tree search". Nature. 529 (7587): 484â489. Bibcode:2016Natur.529..484S. doi:10.1038/nature16961. ISSNÂ 0028-0836. PMIDÂ 26819042. S2CIDÂ 515925.

^ Jump up to: a b Silver, David (2017). "Mastering Chess and Shogi by Self-Play with a General Reinforcement Learning Algorithm". arXiv:1712.01815v1 [cs.AI].

^ Stuart J. Russell, Peter Norvig (2009). Artificial Intelligence: A Modern Approach (3rdÂ ed.). Prentice Hall.{{cite book}}:  CS1 maint: uses authors parameter (link)

^ Jump up to: a b Jonathan Rubin; Ian Watson (April 2011). "Computer poker: A review". Artificial Intelligence. 175 (5â6): 958â987. doi:10.1016/j.artint.2010.12.005.

^ "Monte-Carlo Tree Search in TOTAL WAR: ROME II's Campaign AI". AI Game Dev. Archived from the original on 13 March 2017. Retrieved 25 February 2017.

^ Tesla's AI Day video https://youtube.com/watch?v=j0z4FweCy4M

^ Nicholas, Metropolis; Stanislaw, Ulam (1949). "The monte carlo method". Journal of the American Statistical Association. 44 (247): 335â341. doi:10.1080/01621459.1949.10483310. PMIDÂ 18139350.

^ Abramson, Bruce (1987). The Expected-Outcome Model of Two-Player Games (PDF). Technical report, Department of Computer Science, Columbia University. Retrieved 23 December 2013.

^ Wolfgang Ertel; Johann Schumann; Christian Suttner (1989). "Learning Heuristics for a Theorem Prover using Back Propagation.".  In J. Retti; K. Leidlmair (eds.). 5. Ãsterreichische Artificial-Intelligence-Tagung. Informatik-Fachberichte 208,pp. 87-95. Springer.

^ Christian Suttner; Wolfgang Ertel (1990). "Automatic Acquisition of Search Guiding Heuristics.". CADE90, 10th Int. Conf. on Automated Deduction.pp. 470-484. LNAI 449. Springer.

^ Christian Suttner; Wolfgang Ertel (1991). "Using Back-Propagation Networks for Guiding the Search of a Theorem Prover". Journal of Neural Networks Research & Applications. 2 (1): 3â16.

^ Jump up to: a b BrÃ¼gmann, Bernd (1993). Monte Carlo Go (PDF). Technical report, Department of Physics, Syracuse University.

^ Jump up to: a b c Chang, Hyeong Soo; Fu, Michael C.; Hu, Jiaqiao; Marcus, Steven I. (2005). "An Adaptive Sampling Algorithm for Solving Markov Decision Processes" (PDF). Operations Research. 53: 126â139. doi:10.1287/opre.1040.0145. hdl:1903/6264.

^ Jump up to: a b Hyeong Soo Chang; Michael Fu; Jiaqiao Hu; Steven I. Marcus (2016). "Google DeepMind's Alphago: O.R.'s unheralded role in the path-breaking achievement". OR/MS Today. 45 (5): 24â29.

^ "Sensei's Library: KGSBotRatings". Retrieved 2012-05-03.

^ RÃ©mi Coulom (2008). "The Monte-Carlo Revolution in Go" (PDF). Japanese-French Frontiers of Science Symposium.

^ RÃ©mi Coulom (2007). "Efficient Selectivity and Backup Operators in Monte-Carlo Tree Search". Computers and Games, 5th International Conference, CG 2006, Turin, Italy, May 29â31, 2006. Revised Papers. H. Jaap van den Herik, Paolo Ciancarini, H. H. L. M. Donkers (eds.). Springer. pp.Â 72â83. CiteSeerXÂ 10.1.1.81.6817. ISBNÂ 978-3-540-75537-1.

^ Jump up to: a b Kocsis, Levente; SzepesvÃ¡ri, Csaba (2006). "Bandit based Monte-Carlo Planning".  In FÃ¼rnkranz, Johannes; Scheffer, Tobias; Spiliopoulou, Myra (eds.). Machine Learning: ECML 2006, 17th European Conference on Machine Learning, Berlin, Germany, September 18â22, 2006, Proceedings. Lecture Notes in Computer Science. Vol.Â 4212. Springer. pp.Â 282â293. CiteSeerXÂ 10.1.1.102.1296. doi:10.1007/11871842_29. ISBNÂ 3-540-45375-X.

^ Jump up to: a b c Sylvain Gelly; Yizao Wang; RÃ©mi Munos; Olivier Teytaud (November 2006). Modification of UCT with Patterns in Monte-Carlo Go (PDF). Technical report, INRIA.

^ Chang-Shing Lee; Mei-Hui Wang; Guillaume Chaslot; Jean-Baptiste Hoock; Arpad Rimmel; Olivier Teytaud; Shang-Rong Tsai; Shun-Chin Hsu; Tzung-Pei Hong (2009). "The Computational Intelligence of MoGo Revealed in Taiwan's Computer Go Tournaments" (PDF). IEEE Transactions on Computational Intelligence and AI in Games. 1 (1): 73â89. CiteSeerXÂ 10.1.1.470.6018. doi:10.1109/tciaig.2009.2018703. S2CIDÂ 15266518.

^ Markus Enzenberger; Martin MÅ«ller (2008). Fuego â An Open-Source Framework for Board Games and Go Engine Based on Monte Carlo Tree Search (PDF). Technical report, University of Alberta.

^ "The Shodan Go Bet". Retrieved 2012-05-02.

^ "Research Blog: AlphaGo: Mastering the ancient game of Go with Machine Learning". Google Research Blog. 27 January 2016.

^ "Google achieves AI 'breakthrough' by beating Go champion". BBC News. 27 January 2016.

^ "Match 1 - Google DeepMind Challenge Match: Lee Sedol vs AlphaGo". Youtube. 9 March 2016.

^ "Google AlphaGo AI clean sweeps European Go champion". ZDNet. 28 January 2016.

^ Broderick Arneson; Ryan Hayward; Philip Henderson (June 2009). "MoHex Wins Hex Tournament" (PDF). ICGA Journal. 32 (2): 114â116. doi:10.3233/ICG-2009-32218.

^ Timo Ewalds (2011). Playing and Solving Havannah (PDF). Master's thesis, University of Alberta.

^ Richard J. Lorentz (2008). "Amazons Discover Monte-Carlo". Computers and Games, 6th International Conference, CG 2008, Beijing, China, September 29 â October 1, 2008. Proceedings. H. Jaap van den Herik, Xinhe Xu, Zongmin Ma, Mark H. M. Winands (eds.). Springer. pp.Â 13â24. ISBNÂ 978-3-540-87607-6.

^ TomÃ¡Å¡ Kozelek (2009). Methods of MCTS and the game Arimaa (PDF). Master's thesis, Charles University in Prague.

^ Xiaocong Gan; Yun Bao; Zhangang Han (December 2011). "Real-Time Search Method in Nondeterministic Game â Ms. Pac-Man". ICGA Journal. 34 (4): 209â222. doi:10.3233/ICG-2011-34404.

^ Tom Pepels; Mark H. M. Winands; Marc Lanctot (September 2014). "Real-Time Monte Carlo Tree Search in Ms Pac-Man". IEEE Transactions on Computational Intelligence and AI in Games. 6 (3): 245â257. doi:10.1109/tciaig.2013.2291577.

^ Mountain, Gwaredd (2015). "Tactical Planning and Real-time MCTS in Fable Legends". Retrieved 2019-06-08. ..Â we implemented a simulation based approach, which involved modelling the game play and using MCTS to search the potential plan space. Overall this worked well,Â ...

^ Michael Buro; Jeffrey Richard Long; Timothy Furtak; Nathan R. Sturtevant (2009). "Improving State Evaluation, Inference, and Search in Trick-Based Card Games". IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11â17, 2009. Craig Boutilier (ed.). pp.Â 1407â1413. CiteSeerXÂ 10.1.1.150.3077.

^ C.D. Ward; P.I. Cowling (2009). "Monte Carlo Search Applied to Card Selection in Magic: The Gathering" (PDF). CIG'09 Proceedings of the 5th international conference on Computational Intelligence and Games. IEEE Press. Archived from the original (PDF) on 2016-05-28.

^ IstvÃ¡n Szita; Guillaume Chaslot; Pieter Spronck (2010). "Monte-Carlo Tree Search in Settlers of Catan" (PDF).  In Jaap Van Den Herik; Pieter Spronck (eds.). Advances in Computer Games, 12th International Conference, ACG 2009, Pamplona, Spain, May 11â13, 2009. Revised Papers. Springer. pp.Â 21â32. ISBNÂ 978-3-642-12992-6.

^ Jump up to: a b G.M.J.B. Chaslot; M.H.M. Winands; J.W.H.M. Uiterwijk; H.J. van den Herik; B. Bouzy (2008). "Progressive Strategies for Monte-Carlo Tree Search" (PDF). New Mathematics and Natural Computation. 4 (3): 343â359. doi:10.1142/s1793005708001094.

^ Bradberry, Jeff (2015-09-07). "Introduction to Monte Carlo Tree Search".

^ Peres, Yuval; Schramm, Oded; Sheffield, Scott; Wilson, David B. (2006). "Random-Turn Hex and other selection games". arXiv:math/0508580.

^ Auer, Peter; Cesa-Bianchi, NicolÃ²; Fischer, Paul (2002). "Finite-time Analysis of the Multiarmed Bandit Problem". Machine Learning. 47 (2/3): 235â256. doi:10.1023/a:1013689704352. S2CIDÂ 207609497.

^ Bouzy, Bruno. "Old-fashioned Computer Go vs Monte-Carlo Go" (PDF). IEEE Symposium on Computational Intelligence and Games, April 1â5, 2007, Hilton Hawaiian Village, Honolulu, Hawaii.

^ AlthÃ¶fer, Ingo (2012). "On Board-Filling Games with Random-Turn Order and Monte Carlo Perfectness". Advances in Computer Games. Lecture Notes in Computer Science. Vol.Â 7168. pp.Â 258â269. doi:10.1007/978-3-642-31866-5_22. ISBNÂ 978-3-642-31865-8.

^ Ramanujan, Raghuram; Sabharwal, Ashish; Selman, Bart (May 2010). "On adversarial search spaces and sampling-based planning". ICAPS '10: Proceedings of the Twentieth International Conference on International Conference on Automated Planning and Scheduling. Icaps'10: 242â245.

^ Ramanujan, Raghuram; Selman, Bart (March 2011). "Trade-Offs in Sampling-Based Adversarial Planning". ICAPS '11: Proceedings of the International Conference on Automated Planning and Scheduling. 21 (1): 202â209.

^ "Lee Sedol defeats AlphaGo in masterful comeback - Game 4". Go Game Guru. Archived from the original on 2016-11-16. Retrieved 2017-07-04.

^ Åwiechowski, M.; MaÅdziuk, J., "Self-Adaptation of Playing Strategies in General Game Playing" (2010), IEEE Transactions on Computational Intelligence and AI in Games, vol: 6(4), pp. 367-381, doi: 10.1109/TCIAIG.2013.2275163, http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6571225&isnumber=4804729

^ Drake, Peter (December 2009). "The Last-Good-Reply Policy for Monte-Carlo Go". ICGA Journal. 32 (4): 221â227. doi:10.3233/ICG-2009-32404.

^ Seth Pellegrino; Peter Drake (2010). "Investigating the Effects of Playout Strength in Monte-Carlo Go". Proceedings of the 2010 International Conference on Artificial Intelligence, ICAI 2010, July 12â15, 2010, Las Vegas Nevada, USA. Hamid R. Arabnia, David de la Fuente, Elena B. Kozerenko, JosÃ© Angel Olivas, Rui Chang, Peter M. LaMonica, Raymond A. Liuzzi, Ashu M. G. Solo (eds.). CSREA Press. pp.Â 1015â1018. ISBNÂ 978-1-60132-148-0.

^ Jump up to: a b Gelly, Sylvain; Silver, David (2007). "Combining Online and Offline Knowledge in UCT" (PDF). Machine Learning, Proceedings of the Twenty-Fourth International Conference (ICML 2007), Corvallis, Oregon, USA, June 20â24, 2007. Zoubin Ghahramani (ed.). ACM. pp.Â 273â280. ISBNÂ 978-1-59593-793-3. Archived from the original (PDF) on 2017-08-28.

^ David Silver (2009). Reinforcement Learning and Simulation-Based Search in Computer Go (PDF). PhD thesis, University of Alberta.

^ RÃ©mi Coulom. "CLOP: Confident Local Optimization for Noisy Black-Box Parameter Tuning". ACG 2011: Advances in Computer Games 13 Conference, Tilburg, the Netherlands, November 20â22.

^ Guillaume M.J-B. Chaslot, Mark H.M. Winands, Jaap van den Herik (2008). "Parallel Monte-Carlo Tree Search" (PDF). Computers and Games, 6th International Conference, CG 2008, Beijing, China, September 29 â October 1, 2008. Proceedings. H. Jaap van den Herik, Xinhe Xu, Zongmin Ma, Mark H. M. Winands (eds.). Springer. pp.Â 60â71. ISBNÂ 978-3-540-87607-6.{{cite book}}:  CS1 maint: multiple names: authors list (link)

^ Markus Enzenberger; Martin MÃ¼ller (2010). "A Lock-free Multithreaded Monte-Carlo Tree Search Algorithm".  In Jaap Van Den Herik; Pieter Spronck (eds.). Advances in Computer Games: 12th International Conference, ACG 2009, Pamplona, Spain, May 11â13, 2009, Revised Papers. Springer. pp.Â 14â20. CiteSeerXÂ 10.1.1.161.1984. ISBNÂ 978-3-642-12992-6.


Bibliography[edit]
Cameron Browne; Edward Powley; Daniel Whitehouse; Simon Lucas; Peter I. Cowling; Philipp Rohlfshagen; Stephen Tavener; Diego Perez; Spyridon Samothrakis; Simon Colton (March 2012). "A Survey of Monte Carlo Tree Search Methods". IEEE Transactions on Computational Intelligence and AI in Games. 4 (1): 1â43. CiteSeerXÂ 10.1.1.297.3086. doi:10.1109/tciaig.2012.2186810. S2CIDÂ 9316331.
External links[edit]
Beginner's Guide to Monte Carlo Tree Search




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Monte_Carlo_tree_search&oldid=1067396622"
		Categories: Combinatorial game theoryHeuristic algorithmsMonte Carlo methodsOptimal decisionsComputer GoHidden categories: CS1 maint: uses authors parameterCS1 maint: multiple names: authors listArticles with short descriptionShort description is different from WikidataAll accuracy disputesArticles with disputed statements from June 2019
	
