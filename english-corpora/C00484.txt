
Title:
Anonymous function
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Function definition that is not bound to an identifier
In computer programming, an anonymous function (function literal, lambda abstraction, lambda function, lambda expression or block) is a function definition that is not bound to an identifier. Anonymous functions are often arguments being passed to higher-order functions or used for constructing the result of a higher-order function that needs to return a function.[1]
If the function is only used once, or a limited number of times, an anonymous function may be syntactically lighter than using a named function. Anonymous functions are ubiquitous in functional programming languages and other languages with first-class functions, where they fulfil the same role for the function type as literals do for other data types.
Anonymous functions originate in the work of Alonzo Church in his invention of the lambda calculus, in which all functions are anonymous, in 1936, before electronic computers. [2] In several programming languages, anonymous functions are introduced using the keyword lambda, and anonymous functions are often referred to as lambdas or lambda abstractions. Anonymous functions have been a feature of programming languages since Lisp in 1958, and a growing number of modern programming languages support anonymous functions.

.mw-parser-output .toclimit-2 .toclevel-1 ul,.mw-parser-output .toclimit-3 .toclevel-2 ul,.mw-parser-output .toclimit-4 .toclevel-3 ul,.mw-parser-output .toclimit-5 .toclevel-4 ul,.mw-parser-output .toclimit-6 .toclevel-5 ul,.mw-parser-output .toclimit-7 .toclevel-6 ul{display:none}Contents

1 Names
2 Uses

2.1 Sorting
2.2 Closures
2.3 Currying
2.4 Higher-order functions

2.4.1 Map
2.4.2 Filter
2.4.3 Fold




3 List of languages
4 Examples

4.1 APL
4.2 C (non-standard extension)

4.2.1 GCC
4.2.2 Clang (C, C++, Objective-C, Objective-C++)


4.3 C++ (since C++11)
4.4 C#
4.5 ColdFusion Markup Language (CFML)
4.6 D
4.7 Dart
4.8 Delphi
4.9 PascalABC.NET
4.10 Elixir
4.11 Erlang
4.12 Go
4.13 Haskell
4.14 Haxe
4.15 Java

4.15.1 Java limitations


4.16 JavaScript
4.17 Julia
4.18 Lisp

4.18.1 Common Lisp
4.18.2 Scheme
4.18.3 Clojure


4.19 Lua
4.20 Wolfram Language, Mathematica
4.21 MATLAB, Octave
4.22 Maxima
4.23 ML

4.23.1 OCaml
4.23.2 F#
4.23.3 Standard ML


4.24 Next Generation Shell
4.25 Nim
4.26 Perl

4.26.1 Perl 5


4.27 PHP

4.27.1 PHP 4.0.1 to 5.3
4.27.2 PHP 5.3
4.27.3 PHP 7.4


4.28 Prolog's dialects

4.28.1 Logtalk
4.28.2 Visual Prolog


4.29 Python
4.30 R
4.31 Raku
4.32 Ruby
4.33 Rust
4.34 Scala
4.35 Smalltalk
4.36 Swift
4.37 Tcl
4.38 Vala
4.39 Visual Basic .NET


5 See also
6 References
7 External links



Names[edit]
The names "lambda abstraction", "lambda function", and "lambda expression" refer to the notation of function abstraction in lambda calculus, where the usual function f(x) = M would be written (Î»x.M) (M is an expression that uses x). Compare to the Python syntax of lambda x: M.
The name "arrow function" refers to the mathematical "maps to" symbol, x â¦ M. Compare to the JavaScript syntax of x => M.[3]

Uses[edit]
This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed.  (February 2018) (Learn how and when to remove this template message)
Anonymous functions can be used for containing functionality that need not be named and possibly for short-term use. Some notable examples include closures and currying.
The use of anonymous functions is a matter of style. Using them is never the only way to solve a problem; each anonymous function could instead be defined as a named function and called by name. Some programmers use anonymous functions to encapsulate specific, non-reusable code without littering the code with a lot of little one-line normal functions.
In some programming languages, anonymous functions are commonly implemented for very specific purposes such as binding events to callbacks or instantiating the function for particular values, which may be more efficient, more readable, and less error-prone than calling a more-generic named function.
The following examples are written in Python 3.

Sorting[edit]
When attempting to sort in a non-standard way, it may be easier to contain the sorting logic as an anonymous function instead of creating a named function.
Most languages provide a generic sort function that implements a sort algorithm that will sort arbitrary objects.
This function usually accepts an arbitrary function that determines how to compare whether two elements are equal or if one is greater or less than the other.
Consider this Python code sorting a list of strings by length of the string:

>>> a = ['house', 'car', 'bike']
>>> a.sort(key=lambda x: len(x))
>>> a
['car', 'bike', 'house']

The anonymous function in this example is the lambda expression:

lambda x: len(x)

The anonymous function accepts one argument, x, and returns the length of its argument, which is then used by the sort() method as the criteria for sorting.
Basic syntax of a lambda function in Python is 

lambda arg1, arg2, arg3, ...: <operation on the arguments returning a value>

The expression returned by the lambda function can be assigned to a variable and used in the code at multiple places.

>>> add = lambda a: a + a
>>> add(20)
40

Another example would be sorting items in a list by the name of their class (in Python, everything has a class):

>>> a = [10, 'number', 11.2]
>>> a.sort(key=lambda x: x.__class__.__name__)
>>> a
[11.2, 10, 'number']

Note that 11.2 has class name "float", 10 has class name "int", and 'number' has class name "str". The sorted order is "float", "int", then "str".

Closures[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Closure (computer science)
Closures are functions evaluated in an environment containing bound variables. The following example binds the variable "threshold" in an anonymous function that compares the input to the threshold.

def comp(threshold):
    return lambda x: x < threshold

This can be used as a sort of generator of comparison functions:

>>> func_a = comp(10)
>>> func_b = comp(20)

>>> print(func_a(5), func_a(8), func_a(13), func_a(21))
True True False False

>>> print(func_b(5), func_b(8), func_b(13), func_b(21))
True True True False

It would be impractical to create a function for every possible comparison function and may be too inconvenient to keep the threshold around for further use. Regardless of the reason why a closure is used, the anonymous function is the entity that contains the functionality that does the comparing.

Currying[edit]
Main article: currying
Currying is the process of changing a function so that rather than taking multiple inputs, it takes a single input and returns a function which accepts the second input, and so forth. In this example, a function that performs division by any integer is transformed into one that performs division by a set integer.

>>> def divide(x, y):
...     return x / y

>>> def divisor(d):
...     return lambda x: divide(x, d)

>>> half = divisor(2)
>>> third = divisor(3)

>>> print(half(32), third(32))
16.0 10.666666666666666

>>> print(half(40), third(40))
20.0 13.333333333333334

While the use of anonymous functions is perhaps not common with currying, it still can be used. In the above example, the function divisor generates functions with a specified divisor. The functions half and third curry the divide function with a fixed divisor.
The divisor function also forms a closure by binding the variable d.

Higher-order functions[edit]
A higher-order function is a function that takes a function as an argument. This is commonly used to customize the behavior of a generically defined function, often a looping construct or recursion scheme. Anonymous functions are a convenient way to specify such function arguments. The following examples are in Python 3.

Map[edit]
Main article: Map (higher-order function)
The map function performs a function call on each element of a list. The following example squares every element in an array with an anonymous function.

>>> a = [1, 2, 3, 4, 5, 6]
>>> list(map(lambda x: x*x, a))
[1, 4, 9, 16, 25, 36]

The anonymous function accepts an argument and multiplies it by itself (squares it). The above form is discouraged by the creators of the language, who maintain that the form presented below has the same meaning and is more aligned with the philosophy of the language:

>>> a = [1, 2, 3, 4, 5, 6]
>>> [x*x for x in a]
[1, 4, 9, 16, 25, 36]

Filter[edit]
Main article: Filter (higher-order function)
The filter function returns all elements from a list that evaluate True when passed to a certain function.

>>> a = [1, 2, 3, 4, 5, 6]
>>> list(filter(lambda x: x % 2 == 0, a))
[2, 4, 6]

The anonymous function checks if the argument passed to it is even. The same as with map form below is considered as more appropriate:

>>> a = [1, 2, 3, 4, 5, 6]
>>> [x for x in a if x % 2 == 0]
[2, 4, 6]

Fold[edit]
Main article: Fold (higher-order function)
A fold function runs over all elements in a structure (for lists usually left-to-right, a "left fold", called reduce in Python), accumulating a value as it goes. This can be used to combine all elements of a structure into one value, for example:

>>> from functools import reduce
>>> a = [1, 2, 3, 4, 5]
>>> reduce(lambda x,y: x*y, a)
120

This performs


  
    
      
        
          (
          
            
              (
              
                
                  (
                  
                    1
                    Ã
                    2
                  
                  )
                
                Ã
                3
              
              )
            
            Ã
            4
          
          )
        
        Ã
        5
        =
        120.
      
    
    {\displaystyle \left(\left(\left(1\times 2\right)\times 3\right)\times 4\right)\times 5=120.}
  

The anonymous function here is the multiplication of the two arguments.
The result of a fold need not be one value. Instead, both map and filter can be created using fold. In map, the value that is accumulated is a new list, containing the results of applying a function to each element of the original list. In filter, the value that is accumulated is a new list containing only those elements that match the given condition.

List of languages[edit]
The following is a list of programming languages that support unnamed anonymous functions fully, or partly as some variant, or not at all.
This table shows some general trends. First, the languages that do not support anonymous functions (C, Pascal, Object Pascal) are all statically typed languages. However, statically typed languages can support anonymous functions. For example, the ML languages are statically typed and fundamentally include anonymous functions, and Delphi, a dialect of Object Pascal, has been extended to support anonymous functions, as has C++ (by the C++11 standard). Second, the languages that treat functions as first-class functions (Dylan, Haskell, JavaScript, Lisp, ML, Perl, Python, Ruby, Scheme) generally have anonymous function support so that functions can be defined and passed around as easily as other data types.

This list is incomplete; you can help by adding missing items.  (August 2008)

List of languages


Language
Support
Notes


ActionScript

Y




Ada

N

Expression functions are a part of Ada2012


ALGOL 68

Y




APL

Y

Dyalog, ngn and dzaima APL fully support both dfns and tacit functions. GNU APL has rather limited support for dfns.


Assembly languages

N




Bash

Y

A library has been made to support anonymous functions in Bash.[4]


C

N

Support is provided in Clang and along with the LLVM compiler-rt lib. GCC support is given for a macro implementation which enables the possibility of use. See below for more details.


C#

Y

[5]


C++

Y

As of the C++11 standard


CFML

Y

As of Railo 4,[6] ColdFusion 10[7]


Clojure

Y

[8]


COBOL

N

Micro Focus's non-standard Managed COBOL dialect supports lambdas, which are called anonymous delegates/methods.[9]


Curl

Y




D

Y

[10]


Dart

Y

[11]


Delphi

Y

[12]


Dylan

Y

[13]


Eiffel

Y




Elm

Y

[14]


Elixir

Y

[15]


Erlang

Y

[16]


F#

Y

[17]


Excel

Y

Excel worksheet function, 2021 beta release[18]


Factor

Y

"Quotations" support this[19]


Fortran

N




Frink

Y

[20]


Go

Y

[21]


Gosu

Y

[22]


Groovy

Y

[23]


Haskell

Y

[24]


Haxe

Y

[25]


Java

Y

Supported in Java 8.  See the Java limitations section below for details.


JavaScript

Y

[26]


Julia

Y

[27]


Kotlin

Y

[28]


Lisp

Y




Logtalk

Y




Lua

Y

[29]


MUMPS

N




Mathematica

Y

[30]


Maple

Y

[31]


MATLAB

Y

[32]


Maxima

Y

[33]


Next Generation Shell

Y


Nim

Y

[34]


OCaml

Y

[35]


Octave

Y

[36]


Object Pascal

Y

Delphi, a dialect of Object Pascal, supports anonymous functions (formally, anonymous methods) natively since Delphi 2009. The Oxygene Object Pascal dialect also supports them.


Objective-C (Mac OS X 10.6+)

Y

Called blocks; in addition to Objective-C, blocks can also be used on C and C++ when programming on Apple's platform.


OpenSCAD

Y

Function Literal support was introduced with version 2021.01.[37]


Pascal

N




Perl

Y

[38]


PHP

Y

As of PHP 5.3.0, true anonymous functions are supported.[39] Formerly, only partial anonymous functions were supported, which worked much like C#'s implementation.


PL/I

N




Python

Y

Python supports anonymous functions through the lambda syntax,[40] which supports only expressions, not statements.


R

Y




Racket

Y

[41]


Raku

Y

[42]


Rexx

N




RPG

N




Ruby

Y

Ruby's anonymous functions, inherited from Smalltalk, are called blocks.[43]


Rust

Y

[44]


Scala

Y

[45]


Scheme

Y




Smalltalk

Y

Smalltalk's anonymous functions are called blocks.


Standard ML

Y

[46]


Swift

Y

Swift's anonymous functions are called Closures.[47]


TypeScript

Y

[48]


Tcl

Y

[49]


Vala

Y

[49]


Visual Basic .NET v9

Y

[50]


Visual Prolog v 7.2

Y

[51]


WLanguage v25

Y

PCSoft's W-Language used by its WinDev/WebDev/WinDev Mobile suite supports anonymous functions as-of release 25 (2019)


Wolfram Language

Y

[30]

Examples[edit]
This section contains instructions, advice, or how-to content. The purpose of Wikipedia is to present facts, not to train. Please help improve this article either by rewriting the how-to content or by moving it to Wikiversity, Wikibooks or Wikivoyage.  (December 2018)
Numerous languages support anonymous functions, or something similar.

APL[edit]
Only some dialects support anonymous functions, either as  dfns, in the tacit style or a combination of both.

      fâ{âµÃâµ} â As a dfn
      f 1 2 3
1 4 9     
      gââ¢Ãâ¢   â As a tacit 3-train (fork)
      g 1 2 3
1 4 9
      hâÃâ¨    â As a derived tacit function
      h 1 2 3
1 4 9

C (non-standard extension)[edit]
The anonymous function is not supported by standard C programming language, but supported by some C dialects, such as GCC[52] and Clang.

GCC[edit]
GNU Compiler Collection (GCC) supports anonymous functions, mixed by nested functions and statement expressions. It has the form:

( { return_type anonymous_functions_name (parameters) { function_body } anonymous_functions_name; } )

The following example works only with GCC. Because of how macros are expanded, the l_body cannot contain any commas outside of parentheses; GCC treats the comma as a delimiter between macro arguments.
The argument l_ret_type can be removed if __typeof__ is available; in the example below using __typeof__ on array would return testtype *, which can be dereferenced for the actual value if needed.

#include <stdio.h>

//* this is the definition of the anonymous function */
#define lambda(l_ret_type, l_arguments, l_body)        \
  ({                                                   \
   l_ret_type l_anonymous_functions_name l_arguments   \
   l_body                                              \
   &l_anonymous_functions_name;                        \
   })

#define forEachInArray(fe_arrType, fe_arr, fe_fn_body)                                    \
{                                                                                         \
  int i=0;                                                                                \
  for(;i<sizeof(fe_arr)/sizeof(fe_arrType);i++) {  fe_arr[i] = fe_fn_body(&fe_arr[i]); }  \
}

typedef struct
{
  int a;
  int b;
} testtype;

void printout(const testtype * array)
{
  int i;
  for ( i = 0; i < 3; ++ i )
    printf("%d %d\n", array[i].a, array[i].b);
  printf("\n");
}

int main(void)
{
  testtype array[] = { {0,1}, {2,3}, {4,5} };

  printout(array);
  /* the anonymous function is given as function for the foreach */
  forEachInArray(testtype, array,
    lambda (testtype, (void *item),
    {
      int temp = (*( testtype *) item).a;
      (*( testtype *) item).a = (*( testtype *) item).b;
      (*( testtype *) item).b = temp;
      return (*( testtype *) item);
    }));
  printout(array);
  return 0;
}

Clang (C, C++, Objective-C, Objective-C++)[edit]
Clang supports anonymous functions, called blocks,[53] which have the form:

^return_type ( parameters ) { function_body }

The type of the blocks above is return_type (^)(parameters).
Using the aforementioned blocks extension and Grand Central Dispatch (libdispatch), the code could look simpler:

#include <stdio.h>
#include <dispatch/dispatch.h>

int main(void) {
  void (^count_loop)() = ^{
    for (int i = 0; i < 100; i++)
      printf("%d\n", i);
    printf("ah ah ah\n");
  };

/* Pass as a parameter to another function */
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), count_loop);

/* Invoke directly */
  count_loop();

  return 0;
}

The code with blocks should be compiled with -fblocks and linked with -lBlocksRuntime

C++ (since C++11)[edit]
C++11 supports anonymous functions, called lambda expressions,[54] which have the form:

[capture](parameters) -> return_type { function_body }

This is an example lambda expression:

[](int x, int y) { return x + y; }

C++11 also supports closures, here called captures. Captures are defined between square brackets [and ] in the declaration of lambda expression. The mechanism allows these variables to be captured by value or by reference. The following table demonstrates this:

[]        // No captures, the lambda is implicitly convertible to a function pointer.
[x, &y]   // x is captured by value and y is captured by reference.
[&]       // Any external variable is implicitly captured by reference if used
[=]       // Any external variable is implicitly captured by value if used.
[&, x]    // x is captured by value. Other variables will be captured by reference.
[=, &z]   // z is captured by reference. Other variables will be captured by value.

Variables captured by value are constant by default. Adding mutable after the parameter list makes them non-constant.
C++14 and newer versions support init-capture, for example:

std::unique_ptr<int> ptr = std::make_unique<int>(42);
[ptr]{ /* ... */ }; // copy assignment is deleted for a unique pointer
[ptr = std::move(ptr)]{ /* ... */ }; // ok

auto counter = [i = 0]() mutable { return i++; }; // mutable is required to modify 'i'
counter(); // 0
counter(); // 1
counter(); // 2

The following two examples demonstrate use of a lambda expression:

std::vector<int> some_list{ 1, 2, 3, 4, 5 };
int total = 0;
std::for_each(begin(some_list), end(some_list), 
              [&total](int x) {	total += x; }); 
// Note that std::accumulate would be a way better alternative here...

This computes the total of all elements in the list. The variable total is stored as a part of the lambda function's closure. Since it is a reference to the stack variable total, it can change its value.

std::vector<int> some_list{ 1, 2, 3, 4, 5 };
int total = 0;
int value = 5;
std::for_each(begin(some_list), end(some_list), 
             [&total, value, this](int x) { total += x * value * this->some_func(); });

This will cause total to be stored as a reference, but value will be stored as a copy.
The capture of this is special. It can only be captured by value, not by reference. However in C++17, the current object can be captured by value (denoted by *this), or can be captured by reference (denoted by this). this can only be captured if the closest enclosing function is a non-static member function. The lambda will have the same access as the member that created it, in terms of protected/private members.
If this is captured, either explicitly or implicitly, then the scope of the enclosed class members is also tested. Accessing members of this does not need explicit use of this-> syntax.
The specific internal implementation can vary, but the expectation is that a lambda function that captures everything by reference will store the actual stack pointer of the function it is created in, rather than individual references to stack variables. However, because most lambda functions are small and local in scope, they are likely candidates for inlining, and thus need no added storage for references.
If a closure object containing references to local variables is invoked after the innermost block scope of its creation, the behaviour is undefined.
Lambda functions are function objects of an implementation-dependent type; this type's name is only available to the compiler. If the user wishes to take a lambda function as a parameter, the parameter type must be a template type, or they must create a std::function or a similar object to capture the lambda value. The use of the auto keyword can help store the lambda function,

auto my_lambda_func = [&](int x) { /*...*/ };
auto my_onheap_lambda_func = new auto([=](int x) { /*...*/ });

Here is an example of storing anonymous functions in variables, vectors, and arrays; and passing them as named parameters:

#include <functional>
#include <iostream>
#include <vector>

double eval(std::function<double(double)> f, double x = 2.0) {
  return f(x);
}

int main() {
  std::function<double(double)> f0 = [](double x) { return 1; };
  auto f1 = [](double x) { return x; };
  decltype(f0) fa[3] = {f0, f1, [](double x) { return x * x; }};
  std::vector<decltype(f0)> fv = {f0, f1};
  fv.push_back([](double x) { return x * x; });
  for (size_t i = 0; i < fv.size(); i++) {
    std::cout << fv[i](2.0) << std::endl;
  }
  for (size_t i = 0; i < 3; i++) {
    std::cout << fa[i](2.0) << std::endl;
  }
  for (auto& f : fv) {
    std::cout << f(2.0) << std::endl;
  }
  for (auto& f : fa) {
    std::cout << f(2.0) << std::endl;
  }
  std::cout << eval(f0) << std::endl;
  std::cout << eval(f1) << std::endl;
  std::cout << eval([](double x) { return x * x; }) << std::endl;
}

A lambda expression with an empty capture specification ([]) can be implicitly converted into a function pointer with the same type as the lambda was declared with. So this is legal:

auto a_lambda_func = [](int x) { /*...*/ };
void (* func_ptr)(int) = a_lambda_func;
func_ptr(4); //calls the lambda.

Starting from C++23, a lambda expression can be recursive through explicit this as first parameter:

auto fibonacci = [](this auto self, int n) { return n <= 1 ? n : self(n - 1) + self(n - 2); };
fibonacci(7); // 13

The Boost library provides its own syntax for lambda functions as well, using the following syntax:[55]

for_each(a.begin(), a.end(), std::cout << _1 << ' ');

C#[edit]
In C#, support for anonymous functions has deepened through the various versions of the language compiler. The language v3.0, released in November 2007 with .NET Framework v3.5, has full support of anonymous functions. C# names them lambda expressions, following the original version of anonymous functions, the lambda calculus.[56]

// the first int is the x' type
// the second int is the return type
// <see href="http://msdn.microsoft.com/en-us/library/bb549151.aspx" />
Func<int,int> foo = x => x * x;
Console.WriteLine(foo(7));

While the function is anonymous, it cannot be assigned to an implicitly typed variable, because the lambda syntax may be used for denoting an anonymous function or an expression tree, and the choice cannot automatically be decided by the compiler. E.g., this does not work:

// will NOT compile!
var foo = (int x) => x * x;

However, a lambda expression can take part in type inference and can be used as a method argument, e.g. to use anonymous functions with the Map capability available with System.Collections.Generic.List (in the ConvertAll() method):

// Initialize the list:
var values = new List<int>() { 7, 13, 4, 9, 3 };
// Map the anonymous function over all elements in the list, return the new list
var foo = values.ConvertAll(d => d * d) ; 
// the result of the foo variable is of type System.Collections.Generic.List<Int32>

Prior versions of C# had more limited support for anonymous functions. C# v1.0, introduced in February 2002 with the .NET Framework v1.0, provided partial anonymous function support through the use of delegates. This construct is somewhat similar to PHP delegates. In C# 1.0, delegates are like function pointers that refer to an explicitly named method within a class. (But unlike PHP, the name is unneeded at the time the delegate is used.) C# v2.0, released in November 2005 with the .NET Framework v2.0, introduced the concept of anonymous methods as a way to write unnamed inline statement blocks that can be executed in a delegate invocation. C# 3.0 continues to support these constructs, but also supports the lambda expression construct.
This example will compile in C# 3.0, and exhibits the three forms:

    public class TestDriver
    {
        delegate int SquareDelegate(int d);
        static int Square(int d)
        {
            return d * d;
        }
 
        static void Main(string[] args)
        {
            // C# 1.0: Original delegate syntax needed 
            // initializing with a named method.
            SquareDelegate A = new SquareDelegate(Square);
            System.Console.WriteLine(A(3));
 
            // C# 2.0: A delegate can be initialized with
            // inline code, called an "anonymous method". This
            // method takes an int as an input parameter.
            SquareDelegate B = delegate(int d) { return d * d; };
            System.Console.WriteLine(B(5));
 
            // C# 3.0. A delegate can be initialized with
            // a lambda expression. The lambda takes an int, and returns an int. 
            // The type of x is inferred by the compiler.
            SquareDelegate C = x => x * x;
            System.Console.WriteLine(C(7));
 
            // C# 3.0. A delegate that accepts one input and
            // returns one output can also be implicitly declared with the Func<> type.
            System.Func<int,int> D = x => x * x;
            System.Console.WriteLine(D(9));
        } 
    }

In the case of the C# 2.0 version, the C# compiler takes the code block of the anonymous function and creates a static private function. Internally, the function gets a generated name, of course; this generated name is based on the name of the method in which the Delegate is declared. But the name is not exposed to application code except by using reflection.
In the case of the C# 3.0 version, the same mechanism applies.

ColdFusion Markup Language (CFML)[edit]
Using the function keyword:

fn = function(){
  // statements
};

Or using an arrow function:

fn = () => {
  // statements
};

fn = () => singleExpression // singleExpression is implicitly returned. There is no need for the braces or the return keyword

fn = singleParam => { // if the arrow function has only one parameter, there's no need for parentheses
    // statements
}

fn = (x, y) => { // if the arrow function has zero or multiple parameters, one needs to use parentheses
    // statements
}

CFML supports any statements within the function's definition, not simply expressions.
CFML supports recursive anonymous functions:

factorial = function(n){
    return n > 1 ? n * factorial(n-1) : 1;
};

CFML anonymous functions implement closure.

D[edit]
D uses inline delegates to implement anonymous functions. The full syntax for an inline delegate is

return_type delegate(arguments){/*body*/}

If unambiguous, the return type and the keyword delegate can be omitted.

(x){return x*x;}
delegate (x){return x*x;} // if more verbosity is needed
(int x){return x*x;} // if parameter type cannot be inferred
delegate (int x){return x*x;} // ditto
delegate double(int x){return x*x;} // if return type must be forced manually

Since version 2.0, D allocates closures on the heap unless the compiler can prove it is unnecessary; the scope keyword can be used for forcing stack allocation.
Since version 2.058, it is possible to use shorthand notation:

x => x*x;
(int x) => x*x;
(x,y) => x*y;
(int x, int y) => x*y;

An anonymous function can be assigned to a variable and used like this:

auto sqr = (double x){return x*x;};
double y = sqr(4);

Dart[edit]
Dart supports anonymous functions.[11]

var sqr = (x) => x * x;
print(sqr(5));

or

print(((x) => x * x)(5));

Delphi[edit]
Delphi introduced anonymous functions in version 2009.

program demo;

type
  TSimpleProcedure = reference to procedure;
  TSimpleFunction = reference to function(const x: string): Integer;

var
  x1: TSimpleProcedure;
  y1: TSimpleFunction;

begin
  x1 := procedure
    begin
      Writeln('Hello World');
    end;
  x1;   //invoke anonymous method just defined

  y1 := function(const x: string): Integer
    begin
      Result := Length(x);
    end;
  Writeln(y1('bar')); 
end.

PascalABC.NET[edit]
PascalABC.NET supports anonymous functions using lambda syntax

begin
  var n := 10000000;
  var pp := Range(1,n)
    .Select(x->Rec(Random(),Random()))
    .Where(p->sqr(p.Item1)+sqr(p.Item2)<1)
    .Count/n*4;
  Print(pp);
end.

Elixir[edit]
Elixir uses the closure fn for anonymous functions.[15]

sum = fn(a, b) -> a + b end
sum.(4, 3)
#=> 7

square = fn(x) -> x * x end
Enum.map [1, 2, 3, 4], square
#=> [1, 4, 9, 16]

Erlang[edit]
Erlang uses a syntax for anonymous functions similar to that of named functions.[16]

% Anonymous function bound to the Square variable
Square = fun(X) -> X * X end.

% Named function with the same functionality
square(X) -> X * X.

Go[edit]
Go supports anonymous functions.[21]

foo := func(x int) int {
	return x * x
}
fmt.Println(foo(10))

Haskell[edit]
Haskell uses a concise syntax for anonymous functions (lambda expressions). The backslash is supposed to resemble Î».

\x -> x * x

Lambda expressions are fully integrated with the type inference engine, and support all the syntax and features of "ordinary" functions (except for the use of multiple definitions for pattern-matching, since the argument list is only specified once).

map (\x -> x * x) [1..5] -- returns [1, 4, 9, 16, 25]

The following are all equivalent:

f x y = x + y
f x = \y -> x + y
f = \x y -> x + y

Haxe[edit]
In Haxe, anonymous functions are called lambda, and use the syntax function(argument-list) expression; .

var f = function(x) return x*x;
f(8); // 64

(function(x,y) return x+y)(5,6); // 11

Java[edit]
Java supports anonymous functions, named Lambda Expressions, starting with JDK 8.[57]
A lambda expression consists of a comma separated list of the formal parameters enclosed in parentheses, an arrow token (->), and a body. Data types of the parameters can always be omitted, as can the parentheses if there is only one parameter. The body can consist of one statement or a statement block.[58]

// with no parameter
() -> System.out.println("Hello, world.")

// with one parameter (this example is an identity function).
a -> a

// with one expression
(a, b) -> a + b

// with explicit type information
(long id, String name) -> "id: " + id + ", name:" + name

// with a code block
(a, b) -> { return a + b; }

// with multiple statements in the lambda body. It needs a code block.
// This example also includes two nested lambda expressions (the first one is also a closure).
(id, defaultPrice) -> {
    Optional<Product> product = productList.stream().filter(p -> p.getId() == id).findFirst();
    return product.map(p -> p.getPrice()).orElse(defaultPrice);
}

Lambda expressions are converted to "functional interfaces" (defined as interfaces that contain only one abstract method in addition to one or more default or static methods),[58] as in the following example:

public class Calculator {
    interface IntegerMath {
        int operation(int a, int b);

        default IntegerMath swap() {
            return (a, b) -> operation(b, a);
        }
    }

    private static int apply(int a, int b, IntegerMath op) {
        return op.operation(a, b);
    }

    public static void main(String... args) {
        IntegerMath addition = (a, b) -> a + b;
        IntegerMath subtraction = (a, b) -> a - b;
        System.out.println("40 + 2 = " + apply(40, 2, addition));
        System.out.println("20 - 10 = " + apply(20, 10, subtraction));
        System.out.println("10 - 20 = " + apply(20, 10, subtraction.swap()));    
    }
}

In this example, a functional interface called IntegerMath is declared. Lambda expressions that implement IntegerMath are passed to the apply() method to be executed. Default methods like swap define methods on functions.
Java 8 introduced another mechanism named method reference (the :: operator) to create a lambda on an existing method. A method reference doesn't indicate the number or types of arguments because those are extracted from the abstract method of the functional interface.

IntBinaryOperator sum = Integer::sum;

In the example above, the functional interface IntBinaryOperator declares an abstract method int applyAsInt(int, int), so the compiler looks for a method int sum(int, int) in the class java.lang.Integer.

Java limitations[edit]
Java 8 lambdas have the following limitations:

Lambdas can throw checked exceptions, but such lambdas will not work with the interfaces used by the Collection API.
Variables that are in-scope where the lambda is declared may only be accessed inside the lambda if they are effectively final, i.e. if the variable is not mutated inside or outside of the lambda scope.
JavaScript[edit]
JavaScript/ECMAScript supports anonymous functions.

alert((function(x){
  return x * x;
})(10));

ES6 supports "arrow function" syntax, where a => symbol separates the anonymous function's parameter list from the body:

alert((x => x * x)(10));

This construct is often used in Bookmarklets. For example, to change the title of the current document (visible in its window's title bar) to its URL, the following bookmarklet may seem to work.

javascript:document.title=location.href;

However, as the assignment statement returns a value (the URL itself), many browsers actually create a new page to display this value.
Instead, an anonymous function, that does not return a value, can be used:

javascript:(function(){document.title=location.href;})();

The function statement in the first (outer) pair of parentheses declares an anonymous function, which is then executed when used with the last pair of parentheses. This is almost equivalent to the following, which populates the environment with f unlike an anonymous function.

javascript:var f = function(){document.title=location.href;}; f();

Use void() to avoid new pages for arbitrary anonymous functions:

javascript:void(function(){return document.title=location.href;}());

or just:

javascript:void(document.title=location.href);

JavaScript has syntactic subtleties for the semantics of defining, invoking and evaluating anonymous functions. These subliminal nuances are a direct consequence of the evaluation of parenthetical expressions. The following constructs which are called immediately-invoked function expression illustrate this:

(function(){ ... }())
 and 
(function(){ ... })()

Representing "function(){ ... }" by f, the form of the constructs are 
a parenthetical within a parenthetical (f()) and a parenthetical applied to a parenthetical (f)().
Note the general syntactic ambiguity of a parenthetical expression, parenthesized arguments to a function and the parentheses around the formal parameters in a function definition. In particular, JavaScript defines a , (comma) operator in the context of a parenthetical expression. It is no mere coincidence that the syntactic forms coincide for an expression and a function's arguments (ignoring the function formal parameter syntax)! If f is not identified in the constructs above, they become (()) and ()(). The first provides no syntactic hint of any resident function but the second MUST evaluate the first parenthetical as a function to be legal JavaScript. (Aside: for instance, the ()'s could be ([],{},42,"abc",function(){}) as long as the expression evaluates to a function.)
Also, a function is an Object instance (likewise objects are Function instances) and the object literal notation brackets, {} for braced code, are used when defining a function this way (as opposed to using new Function(...)). In a very broad non-rigorous sense (especially since global bindings are compromised), an arbitrary sequence of braced JavaScript statements, {stuff}, can be considered to be a fixed point of

(function(){( function(){( ... {( function(){stuff}() )} ... )}() )}() )

More correctly but with caveats, 

( function(){stuff}() ) ~=
   A_Fixed_Point_of(
      function(){ return function(){ return ... { return function(){stuff}() } ... }() }()
   )

Note the implications of the anonymous function in the JavaScript fragments that follow:

function(){ ... }() without surrounding ()'s is generally not legal
(f=function(){ ... }) does not "forget" f globally unlike (function f(){ ... })
Performance metrics to analyze the space and time complexities of function calls, call stack, etc. in a JavaScript interpreter engine implement easily with these last anonymous function constructs. From the implications of the results, it is possible to deduce some of an engine's recursive versus iterative implementation details, especially tail-recursion.
Julia[edit]
In Julia anonymous functions are defined using the syntax (arguments)->(expression),

julia> f = x -> x*x; f(8)
64
julia> ((x,y)->x+y)(5,6)
11

Lisp[edit]
Lisp and Scheme support anonymous functions using the "lambda" construct, which is a reference to lambda calculus. Clojure supports anonymous functions with the "fn" special form and #() reader syntax.

(lambda (arg) (* arg arg))

Common Lisp[edit]
Common Lisp has the concept of lambda expressions. A lambda expression is written as a list with the symbol "lambda" as its first element. The list then contains the argument list, documentation or declarations and a function body. Lambda expressions can be used inside lambda forms and with the special operator "function".

(function (lambda (arg) (do-something arg)))

"function" can be abbreviated as #'. Also,  macro lambda exists, which expands into a function form:

; using sharp quote
#'(lambda (arg) (do-something arg))
; using the lambda macro:
(lambda (arg) (do-something arg))

One typical use of anonymous functions in Common Lisp is to pass them to higher-order functions like mapcar, which applies a function to each element of a list and returns a list of the results.

(mapcar #'(lambda (x) (* x x))
        '(1 2 3 4))
; -> (1 4 9 16)

The lambda form in Common Lisp allows a lambda expression to be written in a function call:

((lambda (x y)
   (+ (sqrt x) (sqrt y)))
 10.0
 12.0)

Anonymous functions in Common Lisp can also later be given global names:

(setf (symbol-function 'sqr)
      (lambda (x) (* x x)))
; which allows us to call it using the name SQR:
(sqr 10.0)

Scheme[edit]
Scheme's named functions is simply syntactic sugar for anonymous functions bound to names:

(define (somename arg)
  (do-something arg))

expands (and is equivalent) to

(define somename
  (lambda (arg)
    (do-something arg)))

Clojure[edit]
Clojure supports anonymous functions through the "fn" special form:

(fn [x] (+ x 3))

There is also a reader syntax to define a lambda:

#(+ % %2%3) ; Defines an anonymous function that takes three arguments and sums them.

Like Scheme, Clojure's "named functions" are simply syntactic sugar for lambdas bound to names:

(defn func [arg] (+ 3 arg))

expands to:

(def func (fn [arg] (+ 3 arg)))

Lua[edit]
In Lua (much as in Scheme) all functions are anonymous. A named function in Lua is simply a variable holding a reference to a function object.[59]
Thus, in Lua

function foo(x) return 2*x end

is just syntactical sugar for

foo = function(x) return 2*x end

An example of using anonymous functions for reverse-order sorting:

table.sort(network, function(a,b)
  return a.name > b.name
end)

Wolfram Language, Mathematica[edit]
The Wolfram Language is the programming language of Mathematica. Anonymous functions are important in programming the latter. There are several ways to create them. Below are a few anonymous functions that increment a number. The first is the most common. #1 refers to the first argument and & marks the end of the anonymous function.

     #1+1&
     Function[x,x+1]
     x \[Function] x+1

So, for instance:

    f:= #1^2&;f[8]
     64
    #1+#2&[5,6]
     11

Also, Mathematica has an added construct to make recursive anonymous functions. The symbol '#0' refers to the entire function. The following function calculates the factorial of its input:

     If[#1 == 1, 1, #1 * #0[#1-1]]&

For example, 6 factorial would be:

     If[#1 == 1, 1, #1 * #0[#1-1]]&[6]
720

MATLAB, Octave[edit]
Anonymous functions in MATLAB or Octave are defined using the syntax @(argument-list)expression. Any variables that are not found in the argument list are inherited from the enclosing scope and are captured by value.

>> f = @(x)x*x; f(8)
ans =  64
>> (@(x,y)x+y)(5,6) % Only works in Octave
ans =  11

Maxima[edit]
In Maxima anonymous functions are defined using the syntax lambda(argument-list,expression),

 f: lambda([x],x*x); f(8);
 64

 lambda([x,y],x+y)(5,6);
 11

ML[edit]
The various dialects of ML support anonymous functions.

OCaml[edit]
Anonymous functions in OCaml are functions without a declared name. Here is an example of an anonymous function that multiplies its input by two: 

fun x -> x*2

In the example, fun is a keyword indicating that the function is an anonymous function. We are passing in an argument x and -> to separate the argument from the body.[60]

F#[edit]
F# supports anonymous functions,[17] as follows:

(fun x -> x * x) 20 // 400

Standard ML[edit]
Standard ML supports anonymous functions, as follows:

fn  arg => arg * arg

Next Generation Shell[edit]
Next Generation Shell has several syntaxes for anonymous functions due to their prevalence in the language and different use cases.

Syntaxes:f = X*X; f(8)                       # Result: 64
f = { A*B+C }; f(2,3,4)             # Result: 10
f = F(x:Int, y:Int) x*y+2; f(3, 4)  # Result: 14

f = "${X} is all about ${Y}"
f("programming", "semantics")       # Result: "programming is all about semantics"
Anonymous functions usage examples:[0,1,2].map(X*2)                    # Result: [0,2,4]

data = {"a": "xxx", "b": "yyy"}
data.map("${X} is ${Y}")            # Result: ["a is xxx", "b is yyy"]

Nim[edit]
Nim supports multi-line multi-expression anonymous functions. [34]

var anon = proc (var1, var2: int): int = var1 + var2
assert anon(1, 2) == 3

Multi-line example:

var anon = func (x: int): bool =
             if x > 0:
               result = true
             else: 
               result = false

assert anon(9)

Anonymous functions may be passed as input parameters of other functions:

var cities = @["Frankfurt", "Tokyo", "New York"]

cities.sort(
  proc (x, y: string): int = cmp(x.len, y.len)
)

An anonymous function is basically a function without a name.

Perl[edit]
Perl 5[edit]
Perl 5 supports anonymous functions,[38] as follows:

(sub { print "I got called\n" })->();         # 1. fully anonymous, called as created

my $squarer = sub { my $x = shift; $x * $x }; # 2. assigned to a variable

sub curry {
    my ($sub, @args) = @_;
    return sub { $sub->(@args, @_) };         # 3. as a return value of another function
}

# example of currying in Perl programming
sub sum { my $tot = 0; $tot += $_ for @_; $tot } # returns the sum of its arguments
my $curried = curry \&sum, 5, 7, 9;
print $curried->(1,2,3), "\n";    # prints 27 ( = 5 + 7 + 9 + 1 + 2 + 3 )

Other constructs take bare blocks as arguments, which serve a function similar to lambda functions of one parameter, but don't have the same parameter-passing convention as functions -- @_ is not set.

my @squares = map { $_ * $_ } 1..10;   # map and grep don't use the 'sub' keyword
my @square2 = map $_ * $_, 1..10;      # braces unneeded for one expression

my @bad_example = map { print for @_ } 1..10; # values not passed like normal Perl function

PHP[edit]
Before 4.0.1, PHP had no anonymous function support.[61]

PHP 4.0.1 to 5.3[edit]
PHP 4.0.1 introduced the create_function which was the initial anonymous function support. This function call makes a new randomly named function and returns its name (as a string)

$foo = create_function('$x', 'return $x*$x;');
$bar = create_function("\$x", "return \$x*\$x;");
echo $foo(10);

The argument list and function body must be in single quotes, or the dollar signs must be escaped.
Otherwise, PHP assumes "$x" means the variable $x and will substitute it into the string (despite possibly not existing) instead of leaving "$x" in the string.
For functions with quotes or functions with many variables, it can get quite tedious to ensure the intended function body is what PHP interprets.
Each invocation of create_function makes a new function, which exists for the rest of the program, and cannot be garbage collected, using memory in the program irreversibly. If this is used to create anonymous functions many times, e.g., in a loop, it can cause problems such as memory bloat.

PHP 5.3[edit]
PHP 5.3 added a new class called Closure and magic method __invoke() that makes a class instance invocable.[62]

$x = 3;
$func = function($z) { return $z * 2; };
echo $func($x); // prints 6

In this example, $func is an instance of Closure and echo $func($x) is equivalent to echo $func->__invoke($x).
PHP 5.3 mimics anonymous functions but it does not support true anonymous functions because PHP functions are still not first-class objects.
PHP 5.3 does support closures but the variables must be explicitly indicated as such:

$x = 3;
$func = function() use(&$x) { $x *= 2; };
$func();
echo $x; // prints 6

The variable $x is bound by reference so the invocation of $func modifies it and the changes are visible outside of the function.

PHP 7.4[edit]
Arrow functions were introduced in PHP 7.4

$x = 3;
$func = fn($z) => $z * 2;
echo $func($x); // prints 6

Prolog's dialects[edit]
Logtalk[edit]
Logtalk uses the following syntax for anonymous predicates (lambda expressions):

{FreeVar1, FreeVar2, ...}/[LambdaParameter1, LambdaParameter2, ...]>>Goal

A simple example with no free variables and using a list mapping predicate is:

| ?- meta::map([X,Y]>>(Y is 2*X), [1,2,3], Ys).
Ys = [2,4,6]
yes

Currying is also supported. The above example can be written as:

| ?- meta::map([X]>>([Y]>>(Y is 2*X)), [1,2,3], Ys).
Ys = [2,4,6]
yes

Visual Prolog[edit]
Anonymous functions (in general anonymous predicates) were introduced in Visual Prolog in version 7.2.[63] Anonymous predicates can capture values from the context. If created in an object member, it can also access the object state (by capturing This).
mkAdder returns an anonymous function, which has captured the argument X in the closure. The returned function is a function that adds X to its argument:

clauses
    mkAdder(X) = { (Y) = X+Y }.

Python[edit]
Python supports simple anonymous functions through the lambda form.[40] The executable body of the lambda must be an expression and can't be a statement, which is a restriction that limits its utility. The value returned by the lambda is the value of the contained expression. Lambda forms can be used anywhere ordinary functions can. However these restrictions make it a very limited version of a normal function. Here is an example:

>>> foo = lambda x: x * x
>>> foo(10)
100

In general, Python convention encourages the use of named functions defined in the same scope as one might typically use an anonymous functions in other languages. This is acceptable as locally defined functions implement the full power of closures and are almost as efficient as the use of a lambda in Python. In this example, the built-in power function can be said to have been curried:

>>> def make_pow(n):
...     def fixed_exponent_pow(x):
...         return pow(x, n)
...     return fixed_exponent_pow
...
>>> sqr = make_pow(2)
>>> sqr(10)
100
>>> cub = make_pow(3)
>>> cub(10)
1000

R[edit]
Further information: R (programming language)
In R the anonymous functions are defined using the syntax function(argument-list)expression .

> f <- function(x)x*x; f(8)
[1] 64
> (function(x,y)x+y)(5,6)
[1] 11

Raku[edit]
In Raku, all blocks (even those associated with if, while, etc.) are anonymous functions. A block that is not used as an rvalue is executed immediately.

fully anonymous, called as created
{ say "I got called" };

assigned to a variable
my $squarer1 = -> $x { $x * $x };             # 2a. pointy block
my $squarer2 = { $^x * $^x };                 # 2b. twigil
my $squarer3 = { my $x = shift @_; $x * $x }; # 2c. Perl 5 style

currying
sub add ($m, $n) { $m + $n }
my $seven   = add(3, 4);
my $add_one = &add.assuming(m => 1);
my $eight   = $add_one($seven);

WhateverCode object
my $w = * - 1;       # WhateverCode object
my $b = { $_ - 1 };  # same functionality, but as Callable block

Ruby[edit]
Further information: Ruby (programming language) Â§Â Blocks and iterators
Ruby supports anonymous functions by using a syntactical structure called block. There are two data types for blocks in Ruby. Procs behave similarly to closures, whereas lambdas behave more analogous to an anonymous function.[43] When passed to a method, a block is converted into a Proc in some circumstances.

irb(main):001:0> # Example 1:
irb(main):002:0* # Purely anonymous functions using blocks.
irb(main):003:0* ex = [16.2, 24.1, 48.3, 32.4, 8.5]
=> [16.2, 24.1, 48.3, 32.4, 8.5]
irb(main):004:0> ex.sort_by { |x| x - x.to_i } # Sort by fractional part, ignoring integer part.
=> [24.1, 16.2, 48.3, 32.4, 8.5]
irb(main):005:0> # Example 2:
irb(main):006:0* # First-class functions as an explicit object of Proc -
irb(main):007:0* ex = Proc.new { puts "Hello, world!" }
=> #<Proc:0x007ff4598705a0@(irb):7>
irb(main):008:0> ex.call
Hello, world!
=> nil
irb(main):009:0> # Example 3:
irb(main):010:0* # Function that returns lambda function object with parameters
irb(main):011:0* def is_multiple_of(n)
irb(main):012:1>   lambda{|x| x % n == 0}
irb(main):013:1> end
=> nil
irb(main):014:0> multiple_four = is_multiple_of(4)
=> #<Proc:0x007ff458b45f88@(irb):12 (lambda)>
irb(main):015:0> multiple_four.call(16)
=> true
irb(main):016:0> multiple_four[15]
=> false

Rust[edit]
In Rust, anonymous functions are called closures.[64] They are defined using the following syntax:

|<parameter-name>: <type>| -> <return-type> { <body> };

For example:

let f = |x: i32| -> i32 { x * 2 };

With type inference, however, the compiler is able to infer the type of each parameter and the return type, so the above form can be written as:

let f = |x| { x * 2 };

With closures with a single expression (i.e. a body with one line), the curly braces may be omitted:

let f = |x| x * 2;

Closures with no input parameter are written like so:

let f = || println!("Hello, world!");

Closures may be passed as input parameters of functions that expect a function pointer:

// A function which takes a function pointer as an argument and calls it with
// the value `5`.
fn apply(f: fn(i32) -> i32) -> i32 {
    // No semicolon to indicate an implicit return
    f(5)
}

fn main() {
    // Defining the closure
    let f = |x| x * 2;

    println!("{}", apply(f));  // 10
    println!("{}", f(5));      // 10
}

However, one may need complex rules to describe how values in the body of the closure are captured. They are implemented using the Fn, FnMut, and FnOnce traits:[65]

Fn: the closure captures by reference (&T). They are used for functions that can still be called if they only have reference access (with &) to their environment.
FnMut: the closure captures by mutable reference (&mut T). They are used for functions that can be called if they have mutable reference access (with &mut) to their environment.
FnOnce: the closure captures by value (T). They are used for functions that are only called once.
With these traits, the compiler will capture variables in the least restrictive manner possible.[65] They help govern how values are moved around between scopes, which is largely important since Rust follows a lifetime construct to ensure values are "borrowed" and moved in a predictable and explicit manner.[66]
The following demonstrates how one may pass a closure as an input parameter using the Fn trait:

// A function that takes a value of type F (which is defined as
// a generic type that implements the `Fn` trait, e.g. a closure)
// and calls it with the value `5`.
fn apply_by_ref<F>(f: F) -> i32
    where F: Fn(i32) -> i32
{
    f(5)
}

fn main() {
    let f = |x| {
        println!("I got the value: {}", x);
        x * 2
    };
    
    // Applies the function before printing its return value
    println!("5 * 2 = {}", apply_by_ref(f));
}

// ~~ Program output ~~
// I got the value: 5
// 5 * 2 = 10

Scala[edit]
In Scala, anonymous functions use the following syntax:[67]

(x: Int, y: Int) => x + y

In certain contexts, like when an anonymous function is a parameter being passed to another function, the compiler can infer the types of the parameters of the anonymous function and they can be omitted in the syntax.  In such contexts, it is also possible to use a shorthand for anonymous functions using the underscore character to introduce unnamed parameters.

val list = List(1, 2, 3, 4)
list.reduceLeft( (x, y) => x + y ) 
// Here, the compiler can infer that the types of x and y are both Int. 
// Thus, it needs no type annotations on the parameters of the anonymous function.

list.reduceLeft( _ + _ )   
// Each underscore stands for a new unnamed parameter in the anonymous function. 
// This results in an even shorter equivalent to the anonymous function above.

Smalltalk[edit]
In Smalltalk anonymous functions are called blocks and they are invoked (called) by sending them a "value" message. If arguments are to be passed, a "value:...value:" message with a corresponding number of value arguments must be used.
For example, in GNU Smalltalk,

st> f:=[:x|x*x]. f value: 8 .
64
st> [:x :y|x+y] value: 5 value: 6 .
11

Smalltalk blocks are technically closures, allowing them to outlive their defining scope and still refer to the variables declared therein.

st> f := [:a|[:n|a+n]] value: 100 .
a BlockClosure
"returns the inner block, which adds 100 (captured in "a" variable) to its argument."
st> f value: 1 .
101
st> f value: 2 .
102

Swift[edit]
In Swift, anonymous functions are called closures.[47] The syntax has following form:

{ (parameters) -> returnType in
  statement
}

For example:

{ (s1: String, s2: String) -> Bool in
  return s1 > s2
}

For sake of brevity and expressiveness, the parameter types and return type can be omitted if these can be inferred:

{ s1, s2 in return s1 > s2 }

Similarly, Swift also supports implicit return statements for one-statement closures:

{ s1, s2 in s1 > s2 }

Finally, the parameter names can be omitted as well; when omitted, the parameters are referenced using shorthand argument names, consisting of the $ symbol followed by their position (e.g. $0, $1, $2, etc.):

{ $0 > $1 }

Tcl[edit]
In Tcl, applying the anonymous squaring function to 2 looks as follows:[68]

apply {x {expr {$x*$x}}} 2
# returns 4

This example involves two candidates for what it means to be a function in Tcl. The most generic is usually called a command prefix, and if the variable f holds such a function, then the way to perform the function application f(x) would be

{*}$f $x

where {*} is the expansion prefix (new in Tcl 8.5). The command prefix in the above example is 
apply {x {expr {$x*$x}}}
 Command names can be bound to command prefixes by means of the interp alias command. Command prefixes support currying. Command prefixes are very common in Tcl APIs.
The other candidate for "function" in Tcl is usually called a lambda, and appears as the {x {expr {$x*$x}}} part of the above example. This is the part which caches the compiled form of the anonymous function, but it can only be invoked by being passed to the apply command. Lambdas do not support currying, unless paired with an apply to form a command prefix. Lambdas are rare in Tcl APIs.

Vala[edit]
In Vala, anonymous functions are supported as lambda expressions.[69]

delegate int IntOp (int x, int y);

void main () {
	IntOp foo = (x, y) => x * y;
	stdout.printf("%d\n", foo(10,5));
}

Visual Basic .NET[edit]
Visual Basic .NET 2008 introduced anonymous functions through the lambda form. Combined with implicit typing, VB provides an economical syntax for anonymous functions. As with Python, in VB.NET, anonymous functions must be defined on one line; they cannot be compound statements. Further, an anonymous function in VB.NET must truly be a VB.NET Function - it must return a value. 

Dim foo = Function(x) x * x
Console.WriteLine(foo(10))

Visual Basic.NET 2010 added support for multiline lambda expressions and anonymous functions without a return value. For example, a function for use in a Thread.

Dim t As New System.Threading.Thread(Sub ()
                                         For n As Integer = 0 To 10   'Count to 10
                                             Console.WriteLine(n)     'Print each number
                                         Next
                                     End Sub
                                     )
t.Start()

See also[edit]
.mw-parser-output .portalbox{float:right;border:solid #aaa 1px;padding:0}.mw-parser-output .portalbox.tleft{margin:0.5em 1em 0.5em 0}.mw-parser-output .portalbox.tright{margin:0.5em 0 0.5em 1em}.mw-parser-output .portalbox>ul{display:table;box-sizing:border-box;padding:0.1em;max-width:175px;background:#f9f9f9;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox>ul>li{display:table-row}.mw-parser-output .portalbox>ul>li>span:first-child{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox>ul>li>span:last-child{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}

Computer programming portal
First-class function

References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Higher order functions". learnyouahaskell.com. Retrieved 3 December 2014.

^ Fernandez, Maribel (2009), Models of Computation: An Introduction to Computability Theory, Undergraduate Topics in Computer Science, Springer Science & Business Media, p.Â 33, ISBNÂ 9781848824348, The Lambda calculus ... was introduced by Alonzo Church in the 1930s as a precise notation for a theory of anonymous functions

^ "Arrow function expressions - JavaScript". MDN.

^ "Bash lambda". GitHub. 2019-03-08.

^ BillWagner. "Lambda expressions - C# reference". docs.microsoft.com. Retrieved 2020-11-24.

^ "Closure support". Archived from the original on 2014-01-06. Retrieved 2014-01-05.

^ "Whats new in ColdFusion 10". Archived from the original on 2014-01-06. Retrieved 2014-01-05.

^ "Clojure - Higher Order Functions". clojure.org. Retrieved 2022-01-14.

^ "Managed COBOL Reference". Micro Focus Documentation. Micro Focus. Retrieved 25 February 2014.

^ "Functions - D Programming Language". dlang.org. Retrieved 2022-01-14.

^ a b "A tour of the Dart language". dart.dev. Retrieved 2020-11-24.

^ "Anonymous Methods in Delphi - RAD Studio". docwiki.embarcadero.com. Retrieved 2020-11-24.

^ "Functions â Dylan Programming". opendylan.org. Retrieved 2022-01-14.

^ "docs/syntax". elm-lang.org. Retrieved 2022-01-14.

^ a b "Erlang/Elixir Syntax: A Crash Course". elixir-lang.github.com. Retrieved 2020-11-24.

^ a b "Erlang -- Funs". erlang.org. Retrieved 2020-11-24.

^ a b cartermp. "Lambda Expressions: The fun Keyword - F#". docs.microsoft.com. Retrieved 2020-11-24.

^ "LAMBDA: The ultimate Excel worksheet function". microsoft.com. 25 January 2021. Retrieved 2021-03-30.

^ "Quotations - Factor Documentation". Retrieved 26 December 2015. A quotation is an anonymous function (a value denoting a snippet of code) which can be used as a value and called using the Fundamental combinators.

^ "Frink". frinklang.org. Retrieved 2020-11-24.

^ a b "Anonymous Functions in GoLang". GoLang Docs. Retrieved 2020-11-24.

^ "Gosu Documentation" (PDF). Retrieved 4 March 2013.

^ "Groovy Documentation". Archived from the original on 22 May 2012. Retrieved 29 May 2012.

^ "Anonymous function - HaskellWiki". wiki.haskell.org. Retrieved 2022-01-14.

^ "Lambda". Haxe - The Cross-platform Toolkit. Retrieved 2022-01-14.

^ "Functions - JavaScript | MDN". developer.mozilla.org. Retrieved 2022-01-14.

^ "Functions Â· The Julia Language". docs.julialang.org. Retrieved 2020-11-24.

^ "Higher-Order Functions and Lambdas - Kotlin Programming Language". Kotlin. Retrieved 2020-11-24.

^ "Programming in LuaÂ : 6". www.lua.org. Retrieved 2020-11-24.

^ a b "Pure Anonymous Function: Elementary Introduction to the Wolfram Language". www.wolfram.com. Retrieved 2022-01-14.

^ "Maple Programming: 1.6: Anonymous functions and expressions - Application Center". www.maplesoft.com. Retrieved 2020-11-24.

^ "Anonymous Functions - MATLAB & Simulink". www.mathworks.com. Retrieved 2022-01-14.

^ "Maxima 5.17.1 Manual: 39. Function Definition". maths.cnam.fr. Retrieved 2020-11-24.

^ a b "Nim Manual". nim-lang.github.io.

^ "Code Examples â OCaml". ocaml.org. Retrieved 2020-11-24.

^ "GNU Octave: Anonymous Functions". octave.org. Retrieved 2020-11-24.

^ "Function Literals". OpenSCAD User Manual. Wikibooks. Retrieved 22 February 2021.

^ a b "perlsub - Perl subroutines - Perldoc Browser". perldoc.perl.org. Retrieved 2020-11-24.

^ "PHP: Anonymous functions - Manual". www.php.net. Retrieved 2020-11-24.

^ a b "6. Expressions â Python 3.9.0 documentation". docs.python.org. Retrieved 2020-11-24.

^ "4.4 Functions: lambda". docs.racket-lang.org. Retrieved 2020-11-24.

^ "Functions". docs.raku.org. Retrieved 2022-01-14.

^ a b Sosinski, Robert (2008-12-21). "Understanding Ruby Blocks, Procs and Lambdas". Reactive.IO. Archived from the original on 2014-05-31. Retrieved 2014-05-30.

^ "Closures: Anonymous Functions that Can Capture Their Environment - The Rust Programming Language". doc.rust-lang.org. Retrieved 2022-01-14.

^ "Anonymous Functions". Scala Documentation. Retrieved 2022-01-14.

^ "Recitation 3: Higher order functions". www.cs.cornell.edu. Retrieved 2022-01-14.

^ a b "Closures â The Swift Programming Language (Swift 5.5)". docs.swift.org.

^ "Documentation - Everyday Types". www.typescriptlang.org. Retrieved 2022-01-14.

^ a b "Projects/Vala/Tutorial - GNOME Wiki!". wiki.gnome.org. Retrieved 2020-11-24.

^ KathleenDollard. "Lambda Expressions - Visual Basic". docs.microsoft.com. Retrieved 2022-01-14.

^ "Language Reference/Terms/Anonymous Predicates - wiki.visual-prolog.com". wiki.visual-prolog.com. Retrieved 2022-01-14.

^ "Statement Exprs (Using the GNU Compiler Collection (GCC))". gcc.gnu.org. Retrieved 2022-01-12.

^ "Language Specification for Blocks â Clang 13 documentation". clang.llvm.org. Retrieved 2022-01-14.

^ "Lambda expressions (since C++11) - cppreference.com". en.cppreference.com. Retrieved 2022-01-14.

^ JÃ¤rvi, Jaakko; Powell, Gary (n.d.). "Chapter 16. Boost.Lambda". Boost Documentation. Boost. Retrieved December 22, 2014.

^ "C# Language Specification 5.0". Microsoft Download Center.

^ "What's New in JDK 8".

^ a b The Java Tutorials: Lambda Expressions, docs.oracle.com

^ "Programming in Lua - More about Functions". Archived from the original on 14 May 2008. Retrieved 2008-04-25.

^ "2.7. Anonymous Functions Â· GitBook". www.cs.cornell.edu.

^ http://php.net/create_function the top of the page indicates this with "(PHP 4 >= 4.0.1, PHP 5)"

^ "PHP: rfc:closures". wiki.php.net.

^ "Anonymous Predicates". in Visual Prolog Language Reference

^ "Closures - Rust By Example". doc.rust-lang.org.

^ a b "As input parameters - Rust By Example". doc.rust-lang.org.

^ "Lifetimes - Rust By Example". doc.rust-lang.org.

^ "Anonymous Function Syntax - Scala Documentation". Archived from the original on 2013-07-23. Retrieved 2010-12-31.

^ apply manual page, retrieved 2012-09-06.

^ Vala Reference Manual, retrieved 2021-06-09.


External links[edit]
Anonymous Methods - When Should They Be Used? (blog about anonymous function in Delphi)
Compiling Lambda Expressions: Scala vs. Java 8
php anonymous functions php anonymous functions
Lambda functions in various programming languages




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Anonymous_function&oldid=1068872370"
		Categories: Data typesFunctional programmingLambda calculusSubroutinesHidden categories: Articles with short descriptionShort description matches WikidataArticles needing additional references from February 2018All articles needing additional referencesArticles using small message boxesIncomplete lists from August 2008Articles needing cleanup from December 2018All pages needing cleanupArticles containing how-to sectionsAC with 0 elementsArticles with example code
	
