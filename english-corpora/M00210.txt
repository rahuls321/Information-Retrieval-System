In Boolean algebra, the algebraic normal form (ANF), ring sum normal form (RSNF or RNF), Zhegalkin normal form, or Reed–Muller expansion is a way of writing logical formulas in one of three subforms:The entire formula is purely true or false:10One or more variables are ANDed together into a term, then one or more terms are XORed together into ANF. No NOTs are permitted:a ⊕ b ⊕ ab ⊕ abcor in standard propositional logic symbols:                    a        ⊻        b        ⊻                  (                      a            ∧            b                    )                ⊻                  (                      a            ∧            b            ∧            c                    )                      {\displaystyle a\veebar b\veebar \left(a\wedge b\right)\veebar \left(a\wedge b\wedge c\right)}  The previous subform with a purely true term:1 ⊕ a ⊕ b ⊕ ab ⊕ abcFormulas written in ANF are also known as Zhegalkin polynomials (Russian: полиномы Жегалкина) and Positive Polarity (or Parity) Reed–Muller expressions (PPRM). Common uses ANF is a normal form, which means that two equivalent formulas will convert to the same ANF, easily showing whether two formulas are equivalent for automated theorem proving. Unlike other normal forms, it can be represented as a simple list of lists of variable names. Conjunctive and disjunctive normal forms also require recording whether each variable is negated or not. Negation normal form is unsuitable for that purpose, since it doesn't use equality as its equivalence relation: a ∨ ¬a isn't reduced to the same thing as 1, even though they're equal.Putting a formula into ANF also makes it easy to identify linear functions (used, for example, in linear-feedback shift registers): a linear function is one that is a sum of single literals.  Properties of nonlinear-feedback shift registers can also be deduced from certain properties of the feedback function in ANF. Performing operations within algebraic normal form There are straightforward ways to perform the standard boolean operations on ANF inputs in order to get ANF results.XOR (logical exclusive disjunction) is performed directly:(1 ⊕ x) ⊕ (1 ⊕ x ⊕ y)1 ⊕ x ⊕ 1 ⊕ x ⊕ y1 ⊕ 1 ⊕ x ⊕ x ⊕ yyNOT (logical negation) is XORing 1:¬(1 ⊕ x ⊕ y)1 ⊕(1 ⊕ x ⊕ y)1 ⊕ 1 ⊕ x ⊕ yx ⊕ yAND (logical conjunction) is distributed algebraically(1 ⊕ x)(1 ⊕ x ⊕ y)1(1 ⊕ x ⊕ y) ⊕ x(1 ⊕ x ⊕ y)(1 ⊕ x ⊕ y) ⊕ (x ⊕ x ⊕ xy)1 ⊕ x ⊕ x ⊕ x ⊕ y ⊕ xy1 ⊕ x ⊕ y ⊕ xyOR (logical disjunction) uses either 1 ⊕ (1 ⊕ a)(1 ⊕ b) (easier when both operands have purely true terms) or a ⊕ b ⊕ ab (easier otherwise):(1 ⊕ x) + (1 ⊕ x ⊕ y)1 ⊕ (1 ⊕ 1 ⊕ x)(1 ⊕ 1 ⊕ x ⊕ y)1 ⊕ x(x ⊕ y)1 ⊕ x ⊕ xy Converting to algebraic normal form Each variable in a formula is already in pure ANF, so you only need to perform the formula's boolean operations as shown above to get the entire formula into ANF. For example:x + (y ⋅ ¬z)x + (y(1 ⊕ z))x + (y ⊕ yz)x ⊕ (y ⊕ yz) ⊕ x(y ⊕ yz)x ⊕ y ⊕ xy ⊕ yz ⊕ xyz Formal representation ANF is sometimes described in an equivalent way:where                               a                      0                          ,                  a                      1                          ,        …        ,                  a                      1            ,            2            ,            …            ,            n                          ∈        {        0        ,        1                  }                      ∗                                {\displaystyle a_{0},a_{1},\ldots ,a_{1,2,\ldots ,n}\in \{0,1\}^{*}}   fully describes                     f              {\displaystyle f}  .= Recursively deriving multiargument Boolean functions =There are only four functions with one argument:                    f        (        x        )        =        0              {\displaystyle f(x)=0}                      f        (        x        )        =        1              {\displaystyle f(x)=1}                      f        (        x        )        =        x              {\displaystyle f(x)=x}                      f        (        x        )        =        1        ⊕        x              {\displaystyle f(x)=1\oplus x}  To represent a function with multiple arguments one can use the following equality:                    f        (                  x                      1                          ,                  x                      2                          ,        …        ,                  x                      n                          )        =        g        (                  x                      2                          ,        …        ,                  x                      n                          )        ⊕                  x                      1                          h        (                  x                      2                          ,        …        ,                  x                      n                          )              {\displaystyle f(x_{1},x_{2},\ldots ,x_{n})=g(x_{2},\ldots ,x_{n})\oplus x_{1}h(x_{2},\ldots ,x_{n})}  , where                    g        (                  x                      2                          ,        …        ,                  x                      n                          )        =        f        (        0        ,                  x                      2                          ,        …        ,                  x                      n                          )              {\displaystyle g(x_{2},\ldots ,x_{n})=f(0,x_{2},\ldots ,x_{n})}                      h        (                  x                      2                          ,        …        ,                  x                      n                          )        =        f        (        0        ,                  x                      2                          ,        …        ,                  x                      n                          )        ⊕        f        (        1        ,                  x                      2                          ,        …        ,                  x                      n                          )              {\displaystyle h(x_{2},\ldots ,x_{n})=f(0,x_{2},\ldots ,x_{n})\oplus f(1,x_{2},\ldots ,x_{n})}  Indeed,if                               x                      1                          =        0              {\displaystyle x_{1}=0}   then                               x                      1                          h        =        0              {\displaystyle x_{1}h=0}   and so                     f        (        0        ,        …        )        =        f        (        0        ,        …        )              {\displaystyle f(0,\ldots )=f(0,\ldots )}  if                               x                      1                          =        1              {\displaystyle x_{1}=1}   then                               x                      1                          h        =        h              {\displaystyle x_{1}h=h}   and so                     f        (        1        ,        …        )        =        f        (        0        ,        …        )        ⊕        f        (        0        ,        …        )        ⊕        f        (        1        ,        …        )              {\displaystyle f(1,\ldots )=f(0,\ldots )\oplus f(0,\ldots )\oplus f(1,\ldots )}  Since both                     g              {\displaystyle g}   and                     h              {\displaystyle h}   have fewer arguments than                     f              {\displaystyle f}   it follows that using this process recursively we will finish with functions with one variable. For example, let us construct ANF of                     f        (        x        ,        y        )        =        x        ∨        y              {\displaystyle f(x,y)=x\lor y}   (logical or):                    f        (        x        ,        y        )        =        f        (        0        ,        y        )        ⊕        x        (        f        (        0        ,        y        )        ⊕        f        (        1        ,        y        )        )              {\displaystyle f(x,y)=f(0,y)\oplus x(f(0,y)\oplus f(1,y))}  since                     f        (        0        ,        y        )        =        0        ∨        y        =        y              {\displaystyle f(0,y)=0\lor y=y}   and                     f        (        1        ,        y        )        =        1        ∨        y        =        1              {\displaystyle f(1,y)=1\lor y=1}  it follows that                     f        (        x        ,        y        )        =        y        ⊕        x        (        y        ⊕        1        )              {\displaystyle f(x,y)=y\oplus x(y\oplus 1)}  by distribution, we get the final ANF:                     f        (        x        ,        y        )        =        y        ⊕        x        y        ⊕        x        =        x        ⊕        y        ⊕        x        y              {\displaystyle f(x,y)=y\oplus xy\oplus x=x\oplus y\oplus xy}   See also Reed–Muller expansionZhegalkin normal formBoolean functionLogical graphZhegalkin polynomialNegation normal formConjunctive normal formDisjunctive normal formKarnaugh mapBoolean ring References  Further reading Wegener, Ingo (1987). The complexity of Boolean functions. Wiley-Teubner. p. 6. ISBN 3-519-02107-2."Presentation" (PDF) (in German). University of Duisburg-Essen. Archived (PDF) from the original on 2017-04-20. Retrieved 2017-04-19.Maxfield, Clive "Max" (2006-11-29). "Reed-Muller Logic". Logic 101. EETimes. Part 3. Archived from the original on 2017-04-19. Retrieved 2017-04-19.