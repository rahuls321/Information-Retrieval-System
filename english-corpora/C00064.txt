
Title:
Quicksort
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Divide and conquer sorting algorithm


.mw-parser-output .infobox-subbox{padding:0;border:none;margin:-3px;width:auto;min-width:100%;font-size:100%;clear:none;float:none;background-color:transparent}.mw-parser-output .infobox-3cols-child{margin:auto}.mw-parser-output .infobox .navbar{font-size:100%}body.skin-minerva .mw-parser-output .infobox-header,body.skin-minerva .mw-parser-output .infobox-subheader,body.skin-minerva .mw-parser-output .infobox-above,body.skin-minerva .mw-parser-output .infobox-title,body.skin-minerva .mw-parser-output .infobox-image,body.skin-minerva .mw-parser-output .infobox-full-data,body.skin-minerva .mw-parser-output .infobox-below{text-align:center}QuicksortAnimated visualization of the quicksort algorithm. The horizontal lines are pivot values.ClassSorting algorithmWorst-case performance
  
    
      
        O
        (
        
          n
          
            2
          
        
        )
      
    
    {\displaystyle O(n^{2})}
  
Best-case performance
  
    
      
        O
        (
        n
        log
        â¡
        n
        )
      
    
    {\displaystyle O(n\log n)}
  
 (simple partition)or 
  
    
      
        O
        (
        n
        )
      
    
    {\displaystyle O(n)}
  
 (three-way partition and equal keys)Average performance
  
    
      
        O
        (
        n
        log
        â¡
        n
        )
      
    
    {\displaystyle O(n\log n)}
  
Worst-case space complexity
  
    
      
        O
        (
        n
        )
      
    
    {\displaystyle O(n)}
  
 auxiliary (naive)
  
    
      
        O
        (
        log
        â¡
        n
        )
      
    
    {\displaystyle O(\log n)}
  
 auxiliary (Hoare 1962)
Quicksort is an in-place sorting algorithm. Developed by British computer scientist Tony Hoare in 1959[1] and published in 1961,[2] it is still a commonly used algorithm for sorting. When implemented well, it can be somewhat faster than merge sort and about two or three times faster than heapsort.[3][contradictory]
Quicksort is a divide-and-conquer algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. For this reason, it is sometimes called partition-exchange sort.[4] The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.
Quicksort is a comparison sort, meaning that it can sort items of any type for which a "less-than" relation (formally, a total order) is defined. Efficient implementations of Quicksort are not a stable sort, meaning that the relative order of equal sort items is not preserved.
Mathematical analysis of quicksort shows that, on average, the algorithm takes 
  
    
      
        O
        (
        n
        log
        â¡
        
          n
        
        )
      
    
    {\displaystyle O(n\log {n})}
  
 comparisons to sort n items. In the worst case, it makes 
  
    
      
        O
        (
        
          n
          
            2
          
        
        )
      
    
    {\displaystyle O(n^{2})}
  
 comparisons.

Contents

1 History
2 Algorithm

2.1 Lomuto partition scheme
2.2 Hoare partition scheme
2.3 Implementation issues

2.3.1 Choice of pivot
2.3.2 Repeated elements
2.3.3 Optimizations
2.3.4 Parallelization




3 Formal analysis

3.1 Worst-case analysis
3.2 Best-case analysis
3.3 Average-case analysis

3.3.1 Using percentiles
3.3.2 Using recurrences
3.3.3 Using a binary search tree


3.4 Space complexity


4 Relation to other algorithms

4.1 Selection-based pivoting
4.2 Variants

4.2.1 Multi-pivot quicksort
4.2.2 External quicksort
4.2.3 Three-way radix quicksort
4.2.4 Quick radix sort
4.2.5 BlockQuicksort
4.2.6 Partial and incremental quicksort


4.3 Generalization


5 See also
6 Notes
7 References
8 External links



History[edit]
The quicksort algorithm was developed in 1959 by Tony Hoare while he was a visiting student at Moscow State University. At that time, Hoare was working on a machine translation project for the National Physical Laboratory. As a part of the translation process, he needed to sort the words in Russian sentences before looking them up in a Russian-English dictionary, which was in alphabetical order on magnetic tape.[5] After recognizing that his first idea, insertion sort, would be slow, he came up with a new idea. He wrote the partition part in Mercury Autocode but had trouble dealing with the list of unsorted segments. On return to England, he was asked to write code for Shellsort. Hoare mentioned to his boss that he knew of a faster algorithm and his boss bet sixpence that he did not. His boss ultimately accepted that he had lost the bet. Later, Hoare learned about ALGOL and its ability to do recursion that enabled him to publish the code in Communications of the Association for Computing Machinery, the premier computer science journal of the time.[2][6]
Quicksort gained widespread adoption, appearing, for example, in Unix as the default library sort subroutine. Hence, it lent its name to the C standard library subroutine .mw-parser-output .monospaced{font-family:monospace,monospace}qsort[7] and in the reference implementation of Java.
Robert Sedgewick's PhD thesis in 1975 is considered a milestone in the study of Quicksort where he resolved many open problems related to the analysis of various pivot selection schemes including Samplesort, adaptive partitioning by Van Emden[8] as well as derivation of expected number of comparisons and swaps.[7] Jon Bentley and Doug McIlroy incorporated various improvements for use in programming libraries, including a technique to deal with equal elements and a pivot scheme known as pseudomedian of nine, where a sample of nine elements is divided into groups of three and then the median of the three medians from three groups is chosen.[7] Bentley described another simpler and compact partitioning scheme in his book Programming Pearls that he attributed to Nico Lomuto. Later Bentley wrote that he used Hoare's version for years but never really understood it but Lomuto's version was simple enough to prove correct.[9] Bentley described Quicksort as the "most beautiful code I had ever written" in the same essay. Lomuto's partition scheme was also popularized by the textbook Introduction to Algorithms although it is inferior to Hoare's scheme because it does three times more swaps on average and degrades to O(n2) runtime when all elements are equal.[10][self-published source?]
In 2009, Vladimir Yaroslavskiy proposed a new Quicksort implementation using two pivots instead of one.[11] In the Java core library mailing lists, he initiated a discussion claiming his new algorithm to be superior to the runtime library's sorting method, which was at that time based on the widely used and carefully tuned variant of classic Quicksort by Bentley and McIlroy.[12] Yaroslavskiy's Quicksort has been chosen as the new default sorting algorithm in Oracle's Java 7 runtime library[13] after extensive empirical performance tests.[14]

Algorithm[edit]
  Full example of quicksort on a random set of numbers. The shaded element is the pivot. It is always chosen as the last element of the partition. However, always choosing the last element in the partition as the pivot in this way results in poor performance (O(n2)) on already sorted arrays, or arrays of identical elements. Since sub-arrays of sorted / identical elements crop up a lot towards the end of a sorting procedure on a large set, versions of the quicksort algorithm that choose the pivot as the middle element run much more quickly than the algorithm described in this diagram on large sets of numbers.
Quicksort is a type of divide and conquer algorithm for sorting an array, based on a partitioning routine; the details of this partitioning can vary somewhat, so that quicksort is really a family of closely related algorithms. Applied to a range of at least two elements, partitioning produces a division into two consecutive non empty sub-ranges, in such a way that no element of the first sub-range is greater than any element of the second sub-range. After applying this partition, quicksort then recursively sorts the sub-ranges, possibly after excluding from them an element at the point of division that is at this point known to be already in its final location. Due to its recursive nature, quicksort (like  the partition routine) has to be formulated so as to be callable for a range within a larger array, even if the ultimate goal is to sort a complete array. The steps for in-place quicksort are:

If the range has less than two elements, return immediately as there is nothing to do. Possibly for other very short lengths a special-purpose sorting method is applied and the remainder of these steps skipped.
Otherwise pick a value, called a pivot, that occurs in the range (the precise manner of choosing depends on the partition routine, and can involve randomness).
Partition the range: reorder its elements, while determining a point of division, so that all elements with values less than the pivot come before the division, while all elements with values greater than the pivot come after it; elements that are equal to the pivot can go either way. Since at least one instance of the pivot is present,  most partition routines ensure that the value that ends up at the point of division is equal to the pivot, and is now in its final position (but termination of quicksort does not depend on this, as long as sub-ranges strictly smaller than the original are produced).
Recursively apply the quicksort to the sub-range up to the point of division and to the sub-range after it, possibly excluding from both ranges the element equal to the pivot at the point of division. (If the partition produces a possibly larger sub-range near the boundary where all elements are known to be equal to the pivot, these can be excluded as well.)
The choice of partition routine (including the pivot selection) and other details not entirely specified above can affect the algorithm's performance, possibly to a great extent for specific input arrays. In discussing the efficiency of quicksort, it is therefore necessary to specify these choices first. Here we mention two specific partition methods.

Lomuto partition scheme[edit]
This scheme is attributed to Nico Lomuto and popularized by Bentley in his book Programming Pearls[15] and Cormen et al. in their book Introduction to Algorithms.[16] This scheme chooses a pivot that is typically the last element in the array. The algorithm maintains index i as it scans the array using another index j such that the elements at lo through i-1 (inclusive) are less than the pivot, and the elements at i through j (inclusive) are equal to or greater than the pivot. As this scheme is more compact and easy to understand, it is frequently used in introductory material, although it is less efficient than Hoare's original scheme e.g., when all elements are equal.[17] This scheme degrades to O(n2) when the array is already in order.[10] There have been various variants proposed to boost performance including various ways to select pivot, deal with equal elements, use other sorting algorithms such as Insertion sort for small arrays and so on. In pseudocode, a quicksort that sorts elements at lo through hi (inclusive) of an array A can be expressed as:[16]

// Sorts a (portion of an) array, divides it into partitions, then sorts those
algorithm quicksort(A, lo, hi) is 
  // Ensure indices are in correct order
  if lo >= hi || lo < 0 then 
    return
    
  // Partition array and get the pivot index
  pÂ := partition(A, lo, hi) 
      
  // Sort the two partitions
  quicksort(A, lo, p - 1) // Left side of pivot
  quicksort(A, p + 1, hi) // Right side of pivot

// Divides array into two partitions
algorithm partition(A, lo, hi) is 
  pivotÂ := A[hi] // Choose the last element as the pivot

  // Temporary pivot index
  iÂ := lo - 1

  for jÂ := lo to hi do 
    // If the current element is less than or equal to the pivot
    if A[j] <= pivot then 
      // Move the temporary pivot index forward
      iÂ := i + 1

      // Swap the current element with the element at the temporary pivot index
      swap A[i] with A[j] 
  // Move the pivot element to the correct pivot position (between the smaller and larger elements)
  iÂ := i + 1
  swap A[i] with A[hi]
  return i // the pivot index

Sorting the entire array is accomplished by quicksort(A, 0, length(A) - 1).

Hoare partition scheme[edit]
  An animated demonstration of Quicksort using Hoare's partition scheme. The red outlines show the positions of the left and right pointers (i and j respectively), the black outlines show the positions of the sorted elements, and the filled black square shows the value that is being compared to (pivot).The original partition scheme described by Tony Hoare uses two pointers (indices into the range) that start at both ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the bound (Hoare's terms for the pivot value) at the first pointer, and one less than the bound at the second pointer; if at this point the first pointer is still before the second, these elements are in the wrong order relative to each other, and they are then exchanged.[18] After this the pointers are moved inwards, and the search for an inversion is repeated; when eventually the pointers cross (the first points after the second), no exchange is performed; a valid partition is found, with the point of division between the crossed pointers (any entries that might be strictly between the crossed pointers are equal to the pivot and can be excluded from both sub-ranges formed). With this formulation it is possible that one sub-range turns out to be the whole original range, which would prevent the algorithm from advancing. Hoare therefore stipulates that at the end, the sub-range containing the pivot element (which still is at its original position) can be decreased in size by excluding that pivot, after (if necessary) exchanging it with the sub-range element closest to the separation; thus, termination of quicksort is ensured.
With respect to this original description, implementations often make minor but important variations. Notably, the scheme as presented below includes elements equal to the pivot among the candidates for an inversion (so "greater than or equal" and "less than or equal" tests are used instead of "greater than" and "less than" respectively; since the formulation uses do...while rather than repeat...until which is actually reflected by the use of strict comparison operators). While there is no reason to exchange elements equal to the bound, this change allows tests on the pointers themselves to be omitted, which are otherwise needed to ensure they do not run out of range. Indeed, since at least one instance of the pivot value is present in the range, the first advancement of either pointer cannot pass across this instance if an inclusive test is used; once an exchange is performed, these exchanged elements are now both strictly ahead of the pointer that found them, preventing that pointer from running off. (The latter is true independently of the test used, so it would be possible to use the inclusive test only when looking for the first inversion. However, using an inclusive test throughout also ensures that a division near the middle is found when all elements in the range are equal, which gives an important efficiency gain for sorting arrays with many equal elements.) The risk of producing a non-advancing separation is avoided in a different manner than described by Hoare. Such a separation can only result when no inversions are found, with both pointers advancing to the pivot element at the first iteration (they are then considered to have crossed, and no exchange takes place). The division returned is after the final position of the second pointer, so the case to avoid is where the pivot is the final element of the range and all others are smaller than it. Therefore the pivot choice must avoid the final element (in Hoare's description it could be any element in the range); this is done here by rounding down the middle position, using the floor function.[19] This illustrates that the argument for correctness of an implementation of the Hoare partition scheme can be subtle, and it is easy to get it wrong.
In pseudocode,[16]

// Sorts a (portion of an) array, divides it into partitions, then sorts those
algorithm quicksort(A, lo, hi) is 
  if lo >= 0 && hi >= 0 && lo < hi then
    pÂ := partition(A, lo, hi) 
    quicksort(A, lo, p) // Note: the pivot is now included
    quicksort(A, p + 1, hi) 

// Divides array into two partitions
algorithm partition(A, lo, hi) is 
  // Pivot value
  pivotÂ := A[ floor((hi + lo) / 2) ] // The value in the middle of the array

  // Left index
  iÂ := lo - 1 

  // Right index
  jÂ := hi + 1

  loop forever 
    // Move the left index to the right at least once and while the element at
    // the left index is less than the pivot
    do iÂ := i + 1 while A[i] < pivot
    
    // Move the right index to the left at least once and while the element at
    // the right index is greater than the pivot
    do jÂ := j - 1 while A[j] > pivot

    // If the indices crossed, return
    if i â¥ j then return j
    
    // Swap the elements at the left and right indices
    swap A[i] with A[j]

The entire array is sorted by quicksort(A, 0, length(A) - 1).
Hoare's scheme is more efficient than Lomuto's partition scheme because it does three times fewer swaps on average. Also, as mentioned, the implementation given creates a balanced partition even when all values are equal.[10][self-published source?], which Lomuto's scheme does not. Like Lomuto's partition scheme, Hoare's partitioning also would cause Quicksort to degrade to O(n2) for already sorted input, if the pivot was chosen as the first or the last element. With the middle element as the pivot, however, sorted data results with (almost) no swaps in equally sized partitions leading to best case behavior of Quicksort, i.e. O(n log(n)). Like others, Hoare's partitioning doesn't produce a stable sort. In this scheme, the pivot's final location is not necessarily at the index that is returned, as the pivot and elements equal to the pivot can end up anywhere within the partition after a partition step, and may not be sorted until the base case of a partition with a single element is reached via recursion. The next two segments that the main algorithm recurs on are (lo..p) (elements â¤ pivot) and (p+1..hi) (elements â¥ pivot) as opposed to (lo..p-1) and (p+1..hi) as in Lomuto's scheme.[why?]

Implementation issues[edit]
Choice of pivot[edit]
In the very early versions of quicksort, the leftmost element of the partition would often be chosen as the pivot element. Unfortunately, this causes worst-case behavior on already sorted arrays, which is a rather common use-case.[20] The problem was easily solved by choosing either a random index for the pivot, choosing the middle index of the partition or (especially for longer partitions) choosing the median of the first, middle and last element of the partition for the pivot (as recommended by Sedgewick).[21] This "median-of-three" rule counters the case of sorted (or reverse-sorted) input, and gives a better estimate of the optimal pivot (the true median) than selecting any single element, when no information about the ordering of the input is known.
Median-of-three code snippet for Lomuto partition:

midÂ := â(lo + hi) / 2â
if A[mid] < A[lo]
    swap A[lo] with A[mid]
if A[hi] < A[lo]
    swap A[lo] with A[hi]
if A[mid] < A[hi]
    swap A[mid] with A[hi]
pivotÂ := A[hi]

It puts a median into A[hi] first, then that new value of A[hi] is used for a pivot, as in a basic algorithm presented above.
Specifically, the expected number of comparisons needed to sort n elements (see Â§Â Analysis of randomized quicksort) with random pivot selection is 1.386 n log n. Median-of-three pivoting brings this down to Cn, 2 â 1.188 n log n, at the expense of a three-percent increase in the expected number of swaps.[7] An even stronger pivoting rule, for larger arrays, is to pick the ninther, a recursive median-of-three (Mo3), defined as[7]

ninther(a) = median(Mo3(first .mw-parser-output .sfrac{white-space:nowrap}.mw-parser-output .sfrac.tion,.mw-parser-output .sfrac .tion{display:inline-block;vertical-align:-0.5em;font-size:85%;text-align:center}.mw-parser-output .sfrac .num,.mw-parser-output .sfrac .den{display:block;line-height:1em;margin:0 0.1em}.mw-parser-output .sfrac .den{border-top:1px solid}.mw-parser-output .sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}1/3 of a), Mo3(middle 1/3 of a), Mo3(final 1/3 of a))
Selecting a pivot element is also complicated by the existence of integer overflow. If the boundary indices of the subarray being sorted are sufficiently large, the naÃ¯ve expression for the middle index, (lo + hi)/2, will cause overflow and provide an invalid pivot index. This can be overcome by using, for example, lo + (hiâlo)/2 to index the middle element, at the cost of more complex arithmetic. Similar issues arise in some other methods of selecting the pivot element.

Repeated elements[edit]
With a partitioning algorithm such as the Lomuto partition scheme described above (even one that chooses good pivot values), quicksort exhibits poor performance for inputs that contain many repeated elements. The problem is clearly apparent when all the input elements are equal: at each recursion, the left partition is empty (no input values are less than the pivot), and the right partition has only decreased by one element (the pivot is removed). Consequently, the Lomuto partition scheme takes quadratic time to sort an array of equal values. However, with a partitioning algorithm such as the Hoare partition scheme, repeated elements generally results in better partitioning, and although needless swaps of elements equal to the pivot may occur, the running time generally decreases as the number of repeated elements increases (with memory cache reducing the swap overhead). In the case where all elements are equal, Hoare partition scheme needlessly swaps elements, but the partitioning itself is best case, as noted in the Hoare partition section above.
To solve the Lomuto partition scheme problem (sometimes called the Dutch national flag problem[7]), an alternative linear-time partition routine can be used that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. (Bentley and McIlroy call this a "fat partition" and it was already implemented in the qsort of Version 7 Unix.[7]) The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted. In pseudocode, the quicksort algorithm becomes

algorithm quicksort(A, lo, hi) is
    if lo < hi then
        pÂ := pivot(A, lo, hi)
        left, rightÂ := partition(A, p, lo, hi)  // note: multiple return values
        quicksort(A, lo, left - 1)
        quicksort(A, right + 1, hi)

The partition algorithm returns indices to the first ('leftmost') and to the last ('rightmost') item of the middle partition. Every item of the partition is equal to p and is therefore sorted. Consequently, the items of the partition need not be included in the recursive calls to quicksort.
The best case for the algorithm now occurs when all elements are equal (or are chosen from a small set of k âª n elements). In the case of all equal elements, the modified quicksort will perform only two recursive calls on empty subarrays and thus finish in linear time (assuming the partition subroutine takes no longer than linear time).

Optimizations[edit]
Two other important optimizations, also suggested by Sedgewick and widely used in practice, are:[22][23]

To make sure at most O(log n) space is used, recur first into the smaller side of the partition, then use a tail call to recur into the other, or update the parameters to no longer include the now sorted smaller side, and iterate to sort the larger side.
When the number of elements is below some threshold (perhaps ten elements), switch to a non-recursive sorting algorithm such as insertion sort that performs fewer swaps, comparisons or other operations on such small arrays. The ideal 'threshold' will vary based on the details of the specific implementation.
An older variant of the previous optimization: when the number of elements is less than the threshold k, simply stop; then after the whole array has been processed, perform insertion sort on it. Stopping the recursion early leaves the array k-sorted, meaning that each element is at most k positions away from its final sorted position. In this case, insertion sort takes O(kn) time to finish the sort, which is linear if k is a constant.[24][15]:â117â Compared to the "many small sorts" optimization, this version may execute fewer instructions, but it makes suboptimal use of the cache memories in modern computers.[25]
Parallelization[edit]
Quicksort's divide-and-conquer formulation makes it amenable to parallelization using task parallelism. The partitioning step is accomplished through the use of a parallel prefix sum algorithm to compute an index for each array element in its section of the partitioned array.[26][27] Given an array of size n, the partitioning step performs O(n) work in O(log n) time and requires O(n) additional scratch space. After the array has been partitioned, the two partitions can be sorted recursively in parallel. Assuming an ideal choice of pivots, parallel quicksort sorts an array of size n in O(n log n) work in O(log2 n) time using O(n) additional space.
Quicksort has some disadvantages when compared to alternative sorting algorithms, like merge sort, which complicate its efficient parallelization. The depth of quicksort's divide-and-conquer tree directly impacts the algorithm's scalability, and this depth is highly dependent on the algorithm's choice of pivot. Additionally, it is difficult to parallelize the partitioning step efficiently in-place. The use of scratch space simplifies the partitioning step, but increases the algorithm's memory footprint and constant overheads.
Other more sophisticated parallel sorting algorithms can achieve even better time bounds.[28] For example, in 1991 David Powers described a parallelized quicksort (and a related radix sort) that can operate in O(log n) time on a CRCW (concurrent read and concurrent write) PRAM (parallel random-access machine) with n processors by performing partitioning implicitly.[29]

Formal analysis[edit]
Worst-case analysis[edit]
The most unbalanced partition occurs when one of the sublists returned by the partitioning routine is of size n â 1.[30] This may occur if the pivot happens to be the smallest or largest element in the list, or in some implementations (e.g., the Lomuto partition scheme as described above) when all the elements are equal.
If this happens repeatedly in every partition, then each recursive call processes a list of size one less than the previous list. Consequently, we can make n â 1 nested calls before we reach a list of size 1. This means that the call tree is a linear chain of n â 1 nested calls. The ith call does O(n â i) work to do the partition, and 
  
    
      
        
          
            â
            
              i
              =
              0
            
            
              n
            
          
          (
          n
          â
          i
          )
          =
          O
          (
          
            n
            
              2
            
          
          )
        
      
    
    {\displaystyle \textstyle \sum _{i=0}^{n}(n-i)=O(n^{2})}
  
, so in that case quicksort takes O(n2) time.

Best-case analysis[edit]
In the most balanced case, each time we perform a partition we divide the list into two nearly equal pieces. This means each recursive call processes a list of half the size. Consequently, we can make only log2 n nested calls before we reach a list of size 1. This means that the depth of the call tree is log2 n. But no two calls at the same level of the call tree process the same part of the original list; thus, each level of calls needs only O(n) time all together (each call has some constant overhead, but since there are only O(n) calls at each level, this is subsumed in the O(n) factor). The result is that the algorithm uses only O(n log n) time.

Average-case analysis[edit]
To sort an array of n distinct elements, quicksort takes O(n log n) time in expectation, averaged over all n! permutations of n elements with equal probability. We list here three common proofs to this claim providing different insights into quicksort's workings.

Using percentiles[edit]
If each pivot has rank somewhere in the middle 50 percent, that is, between the 25th percentile and the 75th percentile, then it splits the elements with at least 25% and at most 75% on each side. If we could consistently choose such pivots, we would only have to split the list at most 
  
    
      
        
          log
          
            4
            
              /
            
            3
          
        
        â¡
        n
      
    
    {\displaystyle \log _{4/3}n}
  
 times before reaching lists of size 1, yielding an O(n log n) algorithm.
When the input is a random permutation, the pivot has a random rank, and so it is not guaranteed to be in the middle 50 percent. However, when we start from a random permutation, in each recursive call the pivot has a random rank in its list, and so it is in the middle 50 percent about half the time. That is good enough. Imagine that a coin is flipped: heads means that the rank of the pivot is in the middle 50 percent, tail means that it isn't. Now imagine that the coin is flipped over and over until it gets k heads. Although this could take a long time, on average only 2k flips are required, and the chance that the coin won't get k heads after 100k flips is highly improbable (this can be made rigorous using Chernoff bounds). By the same argument, Quicksort's recursion will terminate on average at a call depth of only 
  
    
      
        2
        
          log
          
            4
            
              /
            
            3
          
        
        â¡
        n
      
    
    {\displaystyle 2\log _{4/3}n}
  
. But if its average call depth is O(log n), and each level of the call tree processes at most n elements, the total amount of work done on average is the product, O(n log n). The algorithm does not have to verify that the pivot is in the middle halfâif we hit it any constant fraction of the times, that is enough for the desired complexity.

Using recurrences[edit]
An alternative approach is to set up a recurrence relation for the T(n) factor, the time needed to sort a list of size n. In the most unbalanced case, a single quicksort call involves O(n) work plus two recursive calls on lists of size 0 and nâ1, so the recurrence relation is


  
    
      
        T
        (
        n
        )
        =
        O
        (
        n
        )
        +
        T
        (
        0
        )
        +
        T
        (
        n
        â
        1
        )
        =
        O
        (
        n
        )
        +
        T
        (
        n
        â
        1
        )
        .
      
    
    {\displaystyle T(n)=O(n)+T(0)+T(n-1)=O(n)+T(n-1).}
  

This is the same relation as for insertion sort and selection sort, and it solves to worst case T(n) = O(n2).
In the most balanced case, a single quicksort call involves O(n) work plus two recursive calls on lists of size n/2, so the recurrence relation is


  
    
      
        T
        (
        n
        )
        =
        O
        (
        n
        )
        +
        2
        T
        
          (
          
            
              n
              2
            
          
          )
        
        .
      
    
    {\displaystyle T(n)=O(n)+2T\left({\frac {n}{2}}\right).}
  

The master theorem for divide-and-conquer recurrences tells us that T(n) = O(n log n).
The outline of a formal proof of the O(n log n) expected time complexity follows. Assume that there are no duplicates as duplicates could be handled with linear time pre- and post-processing, or considered cases easier than the analyzed. When the input is a random permutation, the rank of the pivot is uniform random from 0 to n â 1. Then the resulting parts of the partition have sizes i and n â i â 1, and i is uniform random from 0 to n â 1. So, averaging over all possible splits and noting that the number of comparisons for the partition is n â 1, the average number of comparisons over all permutations of the input sequence can be estimated accurately by solving the recurrence relation:


  
    
      
        C
        (
        n
        )
        =
        n
        â
        1
        +
        
          
            1
            n
          
        
        
          â
          
            i
            =
            0
          
          
            n
            â
            1
          
        
        (
        C
        (
        i
        )
        +
        C
        (
        n
        â
        i
        â
        1
        )
        )
        =
        n
        â
        1
        +
        
          
            2
            n
          
        
        
          â
          
            i
            =
            0
          
          
            n
            â
            1
          
        
        C
        (
        i
        )
      
    
    {\displaystyle C(n)=n-1+{\frac {1}{n}}\sum _{i=0}^{n-1}(C(i)+C(n-i-1))=n-1+{\frac {2}{n}}\sum _{i=0}^{n-1}C(i)}
  


  
    
      
        n
        C
        (
        n
        )
        =
        n
        (
        n
        â
        1
        )
        +
        2
        
          â
          
            i
            =
            0
          
          
            n
            â
            1
          
        
        C
        (
        i
        )
      
    
    {\displaystyle nC(n)=n(n-1)+2\sum _{i=0}^{n-1}C(i)}
  


  
    
      
        n
        C
        (
        n
        )
        â
        (
        n
        â
        1
        )
        C
        (
        n
        â
        1
        )
        =
        n
        (
        n
        â
        1
        )
        â
        (
        n
        â
        1
        )
        (
        n
        â
        2
        )
        +
        2
        C
        (
        n
        â
        1
        )
      
    
    {\displaystyle nC(n)-(n-1)C(n-1)=n(n-1)-(n-1)(n-2)+2C(n-1)}
  


  
    
      
        n
        C
        (
        n
        )
        =
        (
        n
        +
        1
        )
        C
        (
        n
        â
        1
        )
        +
        2
        n
        â
        2
      
    
    {\displaystyle nC(n)=(n+1)C(n-1)+2n-2}
  


  
    
      
        
          
            
              
                
                  
                    
                      C
                      (
                      n
                      )
                    
                    
                      n
                      +
                      1
                    
                  
                
              
              
                
                =
                
                  
                    
                      C
                      (
                      n
                      â
                      1
                      )
                    
                    n
                  
                
                +
                
                  
                    2
                    
                      n
                      +
                      1
                    
                  
                
                â
                
                  
                    2
                    
                      n
                      (
                      n
                      +
                      1
                      )
                    
                  
                
                â¤
                
                  
                    
                      C
                      (
                      n
                      â
                      1
                      )
                    
                    n
                  
                
                +
                
                  
                    2
                    
                      n
                      +
                      1
                    
                  
                
              
            
            
              
              
                
                =
                
                  
                    
                      C
                      (
                      n
                      â
                      2
                      )
                    
                    
                      n
                      â
                      1
                    
                  
                
                +
                
                  
                    2
                    n
                  
                
                â
                
                  
                    2
                    
                      (
                      n
                      â
                      1
                      )
                      n
                    
                  
                
                +
                
                  
                    2
                    
                      n
                      +
                      1
                    
                  
                
                â¤
                
                  
                    
                      C
                      (
                      n
                      â
                      2
                      )
                    
                    
                      n
                      â
                      1
                    
                  
                
                +
                
                  
                    2
                    n
                  
                
                +
                
                  
                    2
                    
                      n
                      +
                      1
                    
                  
                
              
            
            
              
              
                Â 
                Â 
                â®
              
            
            
              
              
                
                =
                
                  
                    
                      C
                      (
                      1
                      )
                    
                    2
                  
                
                +
                
                  â
                  
                    i
                    =
                    2
                  
                  
                    n
                  
                
                
                  
                    2
                    
                      i
                      +
                      1
                    
                  
                
                â¤
                2
                
                  â
                  
                    i
                    =
                    1
                  
                  
                    n
                    â
                    1
                  
                
                
                  
                    1
                    i
                  
                
                â
                2
                
                  â«
                  
                    1
                  
                  
                    n
                  
                
                
                  
                    1
                    x
                  
                
                
                  d
                
                x
                =
                2
                ln
                â¡
                n
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}{\frac {C(n)}{n+1}}&={\frac {C(n-1)}{n}}+{\frac {2}{n+1}}-{\frac {2}{n(n+1)}}\leq {\frac {C(n-1)}{n}}+{\frac {2}{n+1}}\\&={\frac {C(n-2)}{n-1}}+{\frac {2}{n}}-{\frac {2}{(n-1)n}}+{\frac {2}{n+1}}\leq {\frac {C(n-2)}{n-1}}+{\frac {2}{n}}+{\frac {2}{n+1}}\\&\ \ \vdots \\&={\frac {C(1)}{2}}+\sum _{i=2}^{n}{\frac {2}{i+1}}\leq 2\sum _{i=1}^{n-1}{\frac {1}{i}}\approx 2\int _{1}^{n}{\frac {1}{x}}\mathrm {d} x=2\ln n\end{aligned}}}
  

Solving the recurrence gives C(n) = 2n ln n â 1.39n log2 n.
This means that, on average, quicksort performs only about 39% worse than in its best case. In this sense, it is closer to the best case than the worst case. A comparison sort cannot use less than log2(n!) comparisons on average to sort n items (as explained in the article Comparison sort) and in case of large n, Stirling's approximation yields log2(n!) â n(log2 n â log2 e), so quicksort is not much worse than an ideal comparison sort. This fast average runtime is another reason for quicksort's practical dominance over other sorting algorithms.

Using a binary search tree[edit]
The following binary search tree (BST) corresponds to each execution of quicksort: the initial pivot is the root node; the pivot of the left half is the root of the left subtree, the pivot of the right half is the root of the right subtree, and so on. The number of comparisons of the execution of quicksort equals the number of comparisons during the construction of the BST by a sequence of insertions. So, the average number of comparisons for randomized quicksort equals the average cost of constructing a BST when the values inserted 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle (x_{1},x_{2},\ldots ,x_{n})}
  
 form a random permutation.
Consider a BST created by insertion of a sequence 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle (x_{1},x_{2},\ldots ,x_{n})}
  
 of values forming a random permutation. Let C denote the cost of creation of the BST. We have 
  
    
      
        C
        =
        
          â
          
            i
          
        
        
          â
          
            j
            <
            i
          
        
        
          c
          
            i
            ,
            j
          
        
      
    
    {\displaystyle C=\sum _{i}\sum _{j<i}c_{i,j}}
  
, where 
  
    
      
        
          c
          
            i
            ,
            j
          
        
      
    
    {\displaystyle c_{i,j}}
  
 is a binary random variable expressing whether during the insertion of 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 there was a comparison to 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
.
By linearity of expectation, the expected value 
  
    
      
        E
        â¡
        [
        C
        ]
      
    
    {\displaystyle \operatorname {E} [C]}
  
 of C is 
  
    
      
        E
        â¡
        [
        C
        ]
        =
        
          â
          
            i
          
        
        
          â
          
            j
            <
            i
          
        
        Pr
        (
        
          c
          
            i
            ,
            j
          
        
        )
      
    
    {\displaystyle \operatorname {E} [C]=\sum _{i}\sum _{j<i}\Pr(c_{i,j})}
  
.
Fix i and j<i. The values 
  
    
      
        
          
            x
            
              1
            
          
          ,
          
            x
            
              2
            
          
          ,
          â¦
          ,
          
            x
            
              j
            
          
        
      
    
    {\displaystyle {x_{1},x_{2},\ldots ,x_{j}}}
  
, once sorted, define j+1 intervals. The core structural observation is that 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 is compared to 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
 in the algorithm if and only if 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 falls inside one of the two intervals adjacent to 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
.
Observe that since 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            n
          
        
        )
      
    
    {\displaystyle (x_{1},x_{2},\ldots ,x_{n})}
  
 is a random permutation, 
  
    
      
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        â¦
        ,
        
          x
          
            j
          
        
        ,
        
          x
          
            i
          
        
        )
      
    
    {\displaystyle (x_{1},x_{2},\ldots ,x_{j},x_{i})}
  
 is also a random permutation, so the probability that 
  
    
      
        
          x
          
            i
          
        
      
    
    {\displaystyle x_{i}}
  
 is adjacent to 
  
    
      
        
          x
          
            j
          
        
      
    
    {\displaystyle x_{j}}
  
 is exactly 
  
    
      
        
          
            2
            
              j
              +
              1
            
          
        
      
    
    {\displaystyle {\frac {2}{j+1}}}
  
.
We end with a short calculation:


  
    
      
        E
        â¡
        [
        C
        ]
        =
        
          â
          
            i
          
        
        
          â
          
            j
            <
            i
          
        
        
          
            2
            
              j
              +
              1
            
          
        
        =
        O
        
          (
          
            
              â
              
                i
              
            
            log
            â¡
            i
          
          )
        
        =
        O
        (
        n
        log
        â¡
        n
        )
        .
      
    
    {\displaystyle \operatorname {E} [C]=\sum _{i}\sum _{j<i}{\frac {2}{j+1}}=O\left(\sum _{i}\log i\right)=O(n\log n).}
  

Space complexity[edit]
The space used by quicksort depends on the version used.
The in-place version of quicksort has a space complexity of O(log n), even in the worst case, when it is carefully implemented using the following strategies.

In-place partitioning is used. This unstable partition requires O(1) space.
After partitioning, the partition with the fewest elements is (recursively) sorted first, requiring at most O(log n) space. Then the other partition is sorted using tail recursion or iteration, which doesn't add to the call stack. This idea, as discussed above, was described by R. Sedgewick, and keeps the stack depth bounded by O(log n).[21][24]
Quicksort with in-place and unstable partitioning uses only constant additional space before making any recursive call. Quicksort must store a constant amount of information for each nested recursive call. Since the best case makes at most O(log n) nested recursive calls, it uses O(log n) space. However, without Sedgewick's trick to limit the recursive calls, in the worst case quicksort could make O(n) nested recursive calls and need O(n) auxiliary space.
From a bit complexity viewpoint, variables such as lo and hi do not use constant space; it takes O(log n) bits to index into a list of n items. Because there are such variables in every stack frame, quicksort using Sedgewick's trick requires O((log n)2) bits of space. This space requirement isn't too terrible, though, since if the list contained distinct elements, it would need at least O(n log n) bits of space.
Another, less common, not-in-place, version of quicksort uses O(n) space for working storage and can implement a stable sort. The working storage allows the input array to be easily partitioned in a stable manner and then copied back to the input array for successive recursive calls. Sedgewick's optimization is still appropriate.

Relation to other algorithms[edit]
Quicksort is a space-optimized version of the binary tree sort. Instead of inserting items sequentially into an explicit tree, quicksort organizes them concurrently into a tree that is implied by the recursive calls. The algorithms make exactly the same comparisons, but in a different order. An often desirable property of a sorting algorithm is stability â that is the order of elements that compare equal is not changed, allowing controlling order of multikey tables (e.g. directory or folder listings) in a natural way. This property is hard to maintain for in situ (or in place) quicksort (that uses only constant additional space for pointers and buffers, and O(log n) additional space for the management of explicit or implicit recursion). For variant quicksorts involving extra memory due to representations using pointers (e.g. lists or trees) or files (effectively lists), it is trivial to maintain stability. The more complex, or disk-bound, data structures tend to increase time cost, in general making increasing use of virtual memory or disk.
The most direct competitor of quicksort is heapsort. Heapsort's running time is O(n log n), but heapsort's average running time is usually considered slower than in-place quicksort.[31] This result is debatable; some publications indicate the opposite.[32][33] Introsort is a variant of quicksort that switches to heapsort when a bad case is detected to avoid quicksort's worst-case running time.
Quicksort also competes with merge sort, another O(n log n) sorting algorithm. Mergesort is a stable sort, unlike standard in-place quicksort and heapsort, and has excellent worst-case performance.  The main disadvantage of mergesort is that, when operating on arrays, efficient implementations require O(n) auxiliary space, whereas the variant of quicksort with in-place partitioning and tail recursion uses only O(log n) space.
Mergesort works very well on linked lists, requiring only a small, constant amount of auxiliary storage.  Although quicksort can be implemented as a stable sort using linked lists, it will often suffer from poor pivot choices without random access.  Mergesort is also the algorithm of choice for external sorting of very large data sets stored on slow-to-access media such as disk storage or network-attached storage.
Bucket sort with two buckets is very similar to quicksort; the pivot in this case is effectively the value in the middle of the value range, which does well on average for uniformly distributed inputs.

Selection-based pivoting[edit]
A selection algorithm chooses the kth smallest of a list of numbers; this is an easier problem in general than sorting. One simple but effective selection algorithm works nearly in the same manner as quicksort, and is accordingly known as quickselect. The difference is that instead of making recursive calls on both sublists, it only makes a single tail-recursive call on the sublist that contains the desired element. This change lowers the average complexity to linear or O(n) time, which is optimal for selection, but the selection algorithm is still O(n2) in the worst case.
A variant of quickselect, the median of medians algorithm, chooses pivots more carefully, ensuring that the pivots are near the middle of the data (between the 30th and 70th percentiles), and thus has guaranteed linear time â O(n). This same pivot strategy can be used to construct a variant of quicksort (median of medians quicksort) with O(n log n) time. However, the overhead of choosing the pivot is significant, so this is generally not used in practice.
More abstractly, given an O(n) selection algorithm, one can use it to find the ideal pivot (the median) at every step of quicksort and thus produce a sorting algorithm with O(n log n) running time. Practical implementations of this variant are considerably slower on average, but they are of theoretical interest because they show an optimal selection algorithm can yield an optimal sorting algorithm.

Variants[edit]
Multi-pivot quicksort[edit]
Instead of partitioning into two subarrays using a single pivot, multi-pivot quicksort (also multiquicksort[25]) partitions its input into some s number of subarrays using s â 1 pivots. While the dual-pivot case (s = 3) was considered by Sedgewick and others already in the mid-1970s, the resulting algorithms were not faster in practice than the "classical" quicksort.[34] A 1999 assessment of a multiquicksort with a variable number of pivots, tuned to make efficient use of processor caches, found it to increase the instruction count by some 20%, but simulation results suggested that it would be more efficient on very large inputs.[25] A version of dual-pivot quicksort developed by Yaroslavskiy in 2009[11] turned out to be fast enough to warrant implementation in Java 7, as the standard algorithm to sort arrays of primitives (sorting arrays of objects is done using Timsort).[35] The performance benefit of this algorithm was subsequently found to be mostly related to cache performance,[36] and experimental results indicate that the three-pivot variant may perform even better on modern machines.[37][38]

External quicksort[edit]
For disk files, an external sort based on partitioning similar to quicksort is possible. It is slower than external merge sort, but doesn't require extra disk space. 4 buffers are used, 2 for input, 2 for output. Let N = number of records in the file, B = the number of records per buffer, and M = N/B = the number of buffer segments in the file. Data is read (and written) from both ends of the file inwards. Let X represent the segments that start at the beginning of the file and Y represent segments that start at the end of the file. Data is read into the X and Y read buffers. A pivot record is chosen and the records in the X and Y buffers other than the pivot record are copied to the X write buffer in ascending order and Y write buffer in descending order based comparison with the pivot record. Once either X or Y buffer is filled, it is written to the file and the next X or Y buffer is read from the file. The process continues until all segments are read and one write buffer remains. If that buffer is an X write buffer, the pivot record is appended to it and the X buffer written. If that buffer is a Y write buffer, the pivot record is prepended to the Y buffer and the Y buffer written. This constitutes one partition step of the file, and the file is now composed of two subfiles. The start and end positions of each subfile are pushed/popped to a stand-alone stack or the main stack via recursion. To limit stack space to O(log2(n)), the smaller subfile is processed first. For a stand-alone stack, push the larger subfile parameters onto the stack, iterate on the smaller subfile. For recursion, recurse on the smaller subfile first, then iterate to handle the larger subfile. Once a sub-file is less than or equal to 4 B records, the subfile is sorted in place via quicksort and written. That subfile is now sorted and in place in the file. The process is continued until all sub-files are sorted and in place. The average number of passes on the file is approximately 1 + ln(N+1)/(4 B), but worst case pattern is N passes (equivalent to O(n^2) for worst case internal sort).[39]

Three-way radix quicksort[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}Main article: Multi-key quicksort
This algorithm is a combination of radix sort and quicksort. Pick an element from the array (the pivot) and consider the first character (key) of the string (multikey). Partition the remaining elements into three sets: those whose corresponding character is less than, equal to, and greater than the pivot's character. Recursively sort the "less than" and "greater than" partitions on the same character. Recursively sort the "equal to" partition by the next character (key). Given we sort using bytes or words of length W bits, the best case is O(KN) and the worst case O(2KN) or at least O(N2) as for standard quicksort, given for unique keys N<2K, and K is a hidden constant in all standard comparison sort algorithms including quicksort. This is a kind of three-way quicksort in which the middle partition represents a (trivially) sorted subarray of elements that are exactly equal to the pivot.

Quick radix sort[edit]
Also developed by Powers as an O(K) parallel PRAM algorithm. This is again a combination of radix sort and quicksort but the quicksort left/right partition decision is made on successive bits of the key, and is thus O(KN) for N K-bit keys. All comparison sort algorithms impliclty assume the transdichotomous model with K in Î(log N), as if K is smaller we can sort in O(N) time using a hash table or integer sorting.  If K â« log N but elements are unique within O(log N) bits, the remaining bits will not be looked at by either quicksort or quick radix sort.  Failing that, all comparison sorting algorithms will also have the same overhead of looking through O(K) relatively useless bits but quick radix sort will avoid the worst case O(N2) behaviours of standard quicksort and radix quicksort, and will be faster even in the best case of those comparison algorithms under these conditions of uniqueprefix(K) â« log N. See Powers[40] for further discussion of the hidden overheads in comparison, radix and parallel sorting.

BlockQuicksort[edit]
In any comparison-based sorting algorithm, minimizing the number of comparisons requires maximizing the amount of information gained from each comparison, meaning that the comparison results are unpredictable.  This causes frequent branch mispredictions, limiting performance.[41] BlockQuicksort[42] rearranges the computations of quicksort to convert unpredictable branches to data dependencies.  When partitioning, the input is divided into moderate-sized blocks (which fit easily into the data cache), and two arrays are filled with the positions of elements to swap.  (To avoid conditional branches, the position is unconditionally stored at the end of the array, and the index of the end is incremented if a swap is needed.) A second pass exchanges the elements at the positions indicated in the arrays.  Both loops have only one conditional branch, a test for termination, which is usually taken.

Partial and incremental quicksort[edit]
Main article: Partial sorting
Several variants of quicksort exist that separate the k smallest or largest elements from the rest of the input.

Generalization[edit]
Richard Cole and David C. Kandathil, in 2004, discovered a one-parameter family of sorting algorithms, called partition sorts, which on average (with all input orderings equally likely) perform at most 
  
    
      
        n
        log
        â¡
        n
        +
        
          O
        
        (
        n
        )
      
    
    {\displaystyle n\log n+{O}(n)}
  
 comparisons (close to the information theoretic lower bound) and 
  
    
      
        
          Î
        
        (
        n
        log
        â¡
        n
        )
      
    
    {\displaystyle {\Theta }(n\log n)}
  
 operations; at worst they perform 
  
    
      
        
          Î
        
        (
        n
        
          log
          
            2
          
        
        â¡
        n
        )
      
    
    {\displaystyle {\Theta }(n\log ^{2}n)}
  
 comparisons (and also operations); these are in-place, requiring only additional 
  
    
      
        
          O
        
        (
        log
        â¡
        n
        )
      
    
    {\displaystyle {O}(\log n)}
  
 space. Practical efficiency and smaller variance in performance were demonstrated against optimised quicksorts (of Sedgewick and Bentley-McIlroy).[43]

See also[edit]
.mw-parser-output .portalbox{float:right;border:solid #aaa 1px;padding:0}.mw-parser-output .portalbox.tleft{margin:0.5em 1em 0.5em 0}.mw-parser-output .portalbox.tright{margin:0.5em 0 0.5em 1em}.mw-parser-output .portalbox>ul{display:table;box-sizing:border-box;padding:0.1em;max-width:175px;background:#f9f9f9;font-size:85%;line-height:110%;font-style:italic;font-weight:bold}.mw-parser-output .portalbox>ul>li{display:table-row}.mw-parser-output .portalbox>ul>li>span:first-child{display:table-cell;padding:0.2em;vertical-align:middle;text-align:center}.mw-parser-output .portalbox>ul>li>span:last-child{display:table-cell;padding:0.2em 0.2em 0.2em 0.3em;vertical-align:middle}

Computer programming portal
IntrosortÂ â Hybrid sorting algorithm
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"Sir Antony Hoare". Computer History Museum. Archived from the original on 3 April 2015. Retrieved 22 April 2015.

^ Jump up to: a b Hoare, C. A. R. (1961). "Algorithm 64: Quicksort". Comm. ACM. 4 (7): 321. doi:10.1145/366622.366644.

^ Skiena, Steven S. (2008). The Algorithm Design Manual. Springer. p.Â 129. ISBNÂ 978-1-84800-069-8.

^ C.L. Foster, Algorithms, Abstraction and Implementation, 1992, ISBNÂ 0122626605, p. 98

^ Shustek, L. (2009). "Interview: An interview with C.A.R. Hoare". Comm. ACM. 52 (3): 38â41. doi:10.1145/1467247.1467261. S2CIDÂ 1868477.

^ "My Quickshort interview with Sir Tony Hoare, the inventor of Quicksort". Marcelo M De Barros. 15 March 2015.

^ Jump up to: a b c d e f g Bentley, Jon L.; McIlroy, M. Douglas (1993). "Engineering a sort function". Software: Practice and Experience. 23 (11): 1249â1265. CiteSeerXÂ 10.1.1.14.8162. doi:10.1002/spe.4380231105. S2CIDÂ 8822797.

^ Van Emden, M. H. (1 November 1970). "Algorithms 402: Increasing the Efficiency of Quicksort". Commun. ACM. 13 (11): 693â694. doi:10.1145/362790.362803. ISSNÂ 0001-0782. S2CIDÂ 4774719.

^ Bentley, Jon (2007). "The most beautiful code I never wrote".  In Oram, Andy; Wilson, Greg (eds.). Beautiful Code: Leading Programmers Explain How They Think. O'Reilly Media. p.Â 30. ISBNÂ 978-0-596-51004-6.

^ Jump up to: a b c "Quicksort Partitioning: Hoare vs. Lomuto". cs.stackexchange.com. Retrieved 3 August 2015.

^ Jump up to: a b Yaroslavskiy, Vladimir (2009). "Dual-Pivot Quicksort" (PDF). Archived from the original (PDF) on 2 October 2015.

^ "Replacement of Quicksort in java.util.Arrays with new Dual-Pivot Quick". permalink.gmane.org. Archived from the original on 6 November 2018. Retrieved 3 August 2015.

^ "Java 7 Arrays API documentation". Oracle. Retrieved 23 July 2018.

^ Wild, S.; Nebel, M.; Reitzig, R.; Laube, U. (7 January 2013). Engineering Java 7's Dual Pivot Quicksort Using MaLiJAn. Proceedings. Society for Industrial and Applied Mathematics. pp.Â 55â69. doi:10.1137/1.9781611972931.5. ISBNÂ 978-1-61197-253-5.

^ Jump up to: a b Jon Bentley (1999). Programming Pearls. Addison-Wesley Professional.

^ Jump up to: a b c Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2009) [1990]. "Quicksort". Introduction to Algorithms (3rdÂ ed.). MIT Press and McGraw-Hill. pp.Â 170â190. ISBNÂ 0-262-03384-4.

^ Wild, Sebastian (2012). "Java 7's Dual Pivot Quicksort". Technische UniversitÃ¤t Kaiserslautern.

^ Hoare, C. A. R. (1 January 1962). "Quicksort". The Computer Journal. 5 (1): 10â16. doi:10.1093/comjnl/5.1.10. ISSNÂ 0010-4620.

^ in many languages this is the standard behavior of integer division

^ Chandramouli, Badrish; Goldstein, Jonathan (18 June 2014). "Patience is a virtue: revisiting merge and sort on modern processors". Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data. Snowbird Utah USA: ACM: 731â742. doi:10.1145/2588555.2593662. ISBNÂ 978-1-4503-2376-5. S2CIDÂ 7830071.

^ Jump up to: a b Sedgewick, Robert (1 September 1998). Algorithms in C: Fundamentals, Data Structures, Sorting, Searching, Parts 1â4 (3Â ed.). Pearson Education. ISBNÂ 978-81-317-1291-7.

^ qsort.c in GNU libc: [1], [2]

^ http://www.ugrad.cs.ubc.ca/~cs260/chnotes/ch6/Ch6CovCompiled.html[permanent dead link]

^ Jump up to: a b Sedgewick, R. (1978). "Implementing Quicksort programs". Comm. ACM. 21 (10): 847â857. doi:10.1145/359619.359631. S2CIDÂ 10020756.

^ Jump up to: a b c LaMarca, Anthony; Ladner, Richard E. (1999). "The Influence of Caches on the Performance of Sorting". Journal of Algorithms. 31 (1): 66â104. CiteSeerXÂ 10.1.1.27.1788. doi:10.1006/jagm.1998.0985. S2CIDÂ 206567217. Although saving small subarrays until the end makes sense from an instruction count perspective, it is exactly the wrong thing to do from a cache performance perspective.

^ Umut A. Acar, Guy E Blelloch, Margaret Reid-Miller, and Kanat Tangwongsan, Quicksort and Sorting Lower Bounds, Parallel and Sequential Data Structures and Algorithms. 2013.

^ Breshears, Clay (2012). "Quicksort Partition via Prefix Scan". Dr. Dobb's.

^ Miller, Russ; Boxer, Laurence (2000). Algorithms sequential & parallel: a unified approach. Prentice Hall. ISBNÂ 978-0-13-086373-7.

^ Powers, David M. W. (1991). Parallelized Quicksort and Radixsort with Optimal Speedup. Proc. Int'l Conf. on Parallel Computing Technologies. CiteSeerXÂ 10.1.1.57.9071.

^ The other one may either have 1 element or be empty (have 0 elements), depending on whether the pivot is included in one of subpartitions, as in the Hoare's partitioning routine, or is excluded from both of them, like in the Lomuto's routine.

^ Edelkamp, Stefan; WeiÃ, Armin (7â8 January 2019). Worst-Case Efficient Sorting with QuickMergesort. ALENEX 2019: 21st Workshop on Algorithm Engineering and Experiments. San Diego. arXiv:1811.99833. doi:10.1137/1.9781611975499.1. ISBNÂ 978-1-61197-549-9. on small instances Heapsort is already considerably slower than Quicksort (in our experiments more than 30% for n = 210) and on larger instances it suffers from its poor cache behavior (in our experiments more than eight times slower than Quicksort for sorting 228 elements).

^ Hsieh, Paul (2004). "Sorting revisited". azillionmonkeys.com.

^ MacKay, David (December 2005). "Heapsort, Quicksort, and Entropy". Archived from the original on 1 April 2009.

^ Wild, Sebastian; Nebel, Markus E. (2012). Average case analysis of Java 7's dual pivot quicksort. European Symposium on Algorithms. arXiv:1310.7409. Bibcode:2013arXiv1310.7409W.

^ "Arrays". Java Platform SE 7. Oracle. Retrieved 4 September 2014.

^ Wild, Sebastian (3 November 2015). "Why Is Dual-Pivot Quicksort Fast?". arXiv:1511.01138 [cs.DS].

^ Kushagra, Shrinu; LÃ³pez-Ortiz, Alejandro; Qiao, Aurick; Munro, J. Ian (2014). Multi-Pivot Quicksort: Theory and Experiments. Proc. Workshop on Algorithm Engineering and Experiments (ALENEX). doi:10.1137/1.9781611973198.6.

^ Kushagra, Shrinu; LÃ³pez-Ortiz, Alejandro; Munro, J. Ian; Qiao, Aurick (7 February 2014). Multi-Pivot Quicksort: Theory and Experiments (PDF) (Seminar presentation). Waterloo, Ontario.

^ https://fdocuments.net/reader/full/an-efficient-external-sorting-with-minimal-space-requirement

^ David M. W. Powers, Parallel Unification: Practical Complexity, Australasian Computer Architecture Workshop, Flinders University, January 1995

^ Kaligosi, Kanela; Sanders, Peter (11â13 September 2006). How Branch Mispredictions Affect Quicksort (PDF). ESA 2006: 14th Annual European Symposium on Algorithms. Zurich. doi:10.1007/11841036_69.

^ Edelkamp, Stefan; WeiÃ, Armin (22 April 2016). "BlockQuicksort: How Branch Mispredictions don't affect Quicksort". arXiv:1604.06697 [cs.DS].

^ Richard Cole, David C. Kandathil: "The average case analysis of Partition sorts", European Symposium on Algorithms, 14â17 September 2004, Bergen, Norway. Published: Lecture Notes in Computer Science 3221, Springer Verlag, pp. 240â251.


References[edit]
Sedgewick, R. (1978). "Implementing Quicksort programs". Comm. ACM. 21 (10): 847â857. doi:10.1145/359619.359631. S2CIDÂ 10020756.
Dean, B. C. (2006). "A simple expected running time analysis for randomized 'divide and conquer' algorithms". Discrete Applied Mathematics. 154: 1â5. doi:10.1016/j.dam.2005.07.005.
Hoare, C. A. R. (1961). "Algorithm 63: Partition". Comm. ACM. 4 (7): 321. doi:10.1145/366622.366642. S2CIDÂ 52800011.
Hoare, C. A. R. (1961). "Algorithm 65: Find". Comm. ACM. 4 (7): 321â322. doi:10.1145/366622.366647.
Hoare, C. A. R. (1962). "Quicksort". Comput. J. 5 (1): 10â16. doi:10.1093/comjnl/5.1.10. (Reprinted in Hoare and Jones: Essays in computing science, 1989.)
Musser, David R. (1997). "Introspective Sorting and Selection Algorithms". Software: Practice and Experience. 27 (8): 983â993. doi:10.1002/(SICI)1097-024X(199708)27:8<983::AID-SPE117>3.0.CO;2-#.
Donald Knuth. The Art of Computer Programming, Volume 3: Sorting and Searching, Third Edition. Addison-Wesley, 1997. ISBNÂ 0-201-89685-0. Pages 113â122 of section 5.2.2: Sorting by Exchanging.
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBNÂ 0-262-03293-7. Chapter 7: Quicksort, pp.Â 145â164.
Faron Moller. Analysis of Quicksort. CS 332: Designing Algorithms. Department of Computer Science, Swansea University.
MartÃ­nez, C.; Roura, S. (2001). "Optimal Sampling Strategies in Quicksort and Quickselect". SIAM J. Comput. 31 (3): 683â705. CiteSeerXÂ 10.1.1.17.4954. doi:10.1137/S0097539700382108.
Bentley, J. L.; McIlroy, M. D. (1993). "Engineering a sort function". Software: Practice and Experience. 23 (11): 1249â1265. CiteSeerXÂ 10.1.1.14.8162. doi:10.1002/spe.4380231105. S2CIDÂ 8822797.
External links[edit]



The Wikibook Algorithm implementation has a page on the topic of: Quicksort

"Animated Sorting Algorithms: Quick Sort". Archived from the original on 2 March 2015. Retrieved 25 November 2008. â graphical demonstration
"Animated Sorting Algorithms: Quick Sort (3-way partition)". Archived from the original on 6 March 2015. Retrieved 25 November 2008.
Open Data Structures â Section 11.1.2 â Quicksort, Pat Morin
Interactive illustration of Quicksort, with code walkthrough
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hide.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteSorting algorithmsTheory
Computational complexity theory
Big O notation
Total order
Lists
Inplacement
Stability
Comparison sort
Adaptive sort
Sorting network
Integer sorting
X + Y sorting
Transdichotomous model
Quantum sort
Exchange sorts
Bubble sort
Cocktail shaker sort
Oddâeven sort
Comb sort
Gnome sort
Proportion extend sort
Quicksort
Slowsort
Stooge sort
Bogosort
Selection sorts
Selection sort
Heapsort
Smoothsort
Cartesian tree sort
Tournament sort
Cycle sort
Weak-heap sort
Insertion sorts
Insertion sort
Shellsort
Splaysort
Tree sort
Library sort
Patience sorting
Merge sorts
Merge sort
Cascade merge sort
Oscillating merge sort
Polyphase merge sort
Distribution sorts
American flag sort
Bead sort
Bucket sort
Burstsort
Counting sort
Interpolation sort
Pigeonhole sort
Proxmap sort
Radix sort
Flashsort
Concurrent sorts
Bitonic sorter
Batcher oddâeven mergesort
Pairwise sorting network
Samplesort
Hybrid sorts
Block merge sort
Kirkpatrick-Reisch sort
Timsort
Introsort
Spreadsort
Merge-insertion sort
Other
Topological sorting
Pre-topological order
Pancake sorting
Spaghetti sort





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Quicksort&oldid=1068882347"
		Categories: 1961 in computingComparison sortsSorting algorithmsDivide-and-conquer algorithmsHidden categories: All articles with dead external linksArticles with dead external links from July 2016Articles with permanently dead external linksArticles with short descriptionShort description is different from WikidataUse dmy dates from September 2020All self-contradictory articlesSelf-contradictory articles from July 2017All articles with self-published sourcesArticles with self-published sources from August 2015Wikipedia articles needing clarification from September 2021Articles with example pseudocode
	
