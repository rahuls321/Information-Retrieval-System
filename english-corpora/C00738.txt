
Title:
Prefix sum
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		In computer science, the prefix sum, cumulative sum, inclusive scan, or simply scan of a sequence of numbers x0, x1, x2, ... is a second sequence of numbers y0, y1, y2, ..., the sums of prefixes (running totals) of the input sequence:

y0 = x0
y1 = x0 + x1
y2 = x0 + x1+ x2
...
For instance, the prefix sums of the natural numbers are the triangular numbers:




input numbers

Â 1
Â 2
Â 3
Â 4
Â 5
Â 6
...


prefix sums

Â 1
Â 3
Â 6
10
15
21
...

Prefix sums are trivial to compute in sequential models of computation, by using the formula yi = yi â 1 + xi to compute each output value in sequence order. However, despite their ease of computation, prefix sums are a useful primitive in certain algorithms such as counting sort,[1][2]
and they form the basis of the scan higher-order function in functional programming languages. Prefix sums have also been much studied in parallel algorithms, both as a test problem to be solved and as a useful primitive to be used as a subroutine in other parallel algorithms.[3][4][5]
Abstractly, a prefix sum requires only a binary associative operator â, making it useful for many applications from calculating well-separated pair decompositions of points to string processing.[6][7]
Mathematically, the operation of taking prefix sums can be generalized from finite to infinite sequences; in that context, a prefix sum is known as a partial sum of a series. Prefix summation or partial summation form linear operators on the vector spaces of finite or infinite sequences; their inverses are finite difference operators.

Contents

1 Scan higher order function

1.1 Inclusive and exclusive scans


2 Parallel algorithms

2.1 Algorithm 1: Shorter span, more parallel
2.2 Algorithm 2: Work-efficient
2.3 Discussion
2.4 Concrete implementations of prefix sum algorithms

2.4.1 Shared memory: Two-level algorithm
2.4.2 Distributed memory: Hypercube algorithm
2.4.3 Large message sizes: pipelined binary tree

2.4.3.1 Pipelining






3 Data structures
4 Applications
5 See also
6 References
7 External links



Scan higher order function[edit]
In functional programming terms, the prefix sum may be generalized to any binary operation (not just the addition operation); the higher order function resulting from this generalization is called a scan, and it is closely related to the fold operation. Both the scan and the fold operations apply the given binary operation to the same sequence of values, but differ in that the scan returns the whole sequence of results from the binary operation, whereas the fold returns only the final result. For instance, the sequence of factorial numbers may be generated by a scan of the natural numbers using multiplication instead of addition:




input numbers

1
2
3
4
5
6
...


prefix products

1
2
6
24
120
720
...

Inclusive and exclusive scans[edit]
Programming language and library implementations of scan may be either inclusive or exclusive. An inclusive scan includes input xi when computing output yi (i.e., 
  
    
      
        
          y
          
            i
          
        
        =
        
          â¨
          
            j
            =
            0
          
          
            i
          
        
        
          x
          
            j
          
        
      
    
    {\displaystyle y_{i}=\bigoplus _{j=0}^{i}x_{j}}
  
) while an exclusive scan does not (i.e., 
  
    
      
        
          y
          
            i
          
        
        =
        
          â¨
          
            j
            =
            0
          
          
            i
            â
            1
          
        
        
          x
          
            j
          
        
      
    
    {\displaystyle y_{i}=\bigoplus _{j=0}^{i-1}x_{j}}
  
). In the latter case, implementations either leave y0 undefined or accept a separate "xâ1" value with which to seed the scan. Either type of scan can be transformed into the other: an inclusive scan can be transformed into an exclusive scan by shifting the array produced by the scan right by one element and inserting the identity value at the left of the array. Conversely, an exclusive scan be transformed into an inclusive scan by shifting the array produced by the scan left and inserting the sum of the last element of the scan and the last element of the input array at the right of the array.[8]
The following table lists examples of the inclusive and exclusive scan functions provided by a few programming languages and libraries:




Language/library

Inclusive scan

Exclusive scan


Haskell

scanl1

scanl


MPI

MPI_Scan

MPI_Exscan


C++

std::inclusive_scan

std::exclusive_scan


Scala

scan




Rust

scan




Parallel algorithms[edit]
There are two key algorithms for computing a prefix sum in parallel. The first offers a shorter span and more parallelism but is not work-efficient. The second is work-efficient but requires double the span and offers less parallelism. These are presented in turn below.

Algorithm 1: Shorter span, more parallel[edit]
  Circuit representation of a highly parallel 16-input parallel prefix sum
Hillis and Steele present the
following parallel prefix sum algorithm:[9]

for 
  
    
      
        i
        â
        0
      
    
    {\displaystyle i\gets 0}
  
 to 
  
    
      
        â
        
          log
          
            2
          
        
        â¡
        n
        â
        â
        1
      
    
    {\displaystyle \lceil \log _{2}n\rceil -1}
  
 do
for 
  
    
      
        j
        â
        0
      
    
    {\displaystyle j\gets 0}
  
 to 
  
    
      
        n
        â
        1
      
    
    {\displaystyle n-1}
  
 do in parallel
if 
  
    
      
        j
        <
        
          2
          
            i
          
        
      
    
    {\displaystyle j<2^{i}}
  
 then

  
    
      
        
          x
          
            j
          
          
            i
            +
            1
          
        
        â
        
          x
          
            j
          
          
            i
          
        
      
    
    {\displaystyle x_{j}^{i+1}\gets x_{j}^{i}}
  

else

  
    
      
        
          x
          
            j
          
          
            i
            +
            1
          
        
        â
        
          x
          
            j
          
          
            i
          
        
        +
        
          x
          
            j
            â
            
              2
              
                i
              
            
          
          
            i
          
        
      
    
    {\displaystyle x_{j}^{i+1}\gets x_{j}^{i}+x_{j-2^{i}}^{i}}
  

In the above, the notation 
  
    
      
        
          x
          
            j
          
          
            i
          
        
      
    
    {\displaystyle x_{j}^{i}}
  
 means the value of the jth element of array x in timestep i.
With a single processor this algorithm would run in O(nlog n) time. However if the machine has at least n processors to perform the inner loop in parallel, the algorithm as a whole runs in O(log n) time, the number of iterations of the outer loop.

Algorithm 2: Work-efficient[edit]
  Circuit representation of a work-efficient 16-input parallel prefix sum
A work-efficient parallel prefix sum can be computed by the following steps.[3][10][11]

Compute the sums of consecutive pairs of items in which the first item of the pair has an even index: z0 = x0 + x1, z1 = x2 + x3, etc.
Recursively compute the prefix sum w0, w1, w2, ... of the sequence z0, z1, z2, ...
Express each term of the final sequence y0, y1, y2, ... as the sum of up to two terms of these intermediate sequences: y0 = x0, y1 = z0, y2 = z0 + x2, y3 = w0, etc. After the first value, each successive number yi is either copied from a position half as far through the w sequence, or is the previous value added to one value in the x sequence.
If the input sequence has n steps, then the recursion continues to a depth of O(log n), which is also the bound on the parallel running time of this algorithm. The number of steps of the algorithm is O(n), and it can be implemented on a parallel random access machine with O(n/log n) processors without any asymptotic slowdown by assigning multiple indices to each processor in rounds of the algorithm for which there are more elements than processors.[3]

Discussion[edit]
Each of the preceding algorithms runs in O(log n) time. However, the former takes exactly log2 n steps, while the latter requires 2 log2Â n â 2 steps. For the 16-input examples illustrated, AlgorithmÂ 1 is 12-way parallel (49 units of work divided by a span of 4) while AlgorithmÂ 2 is only 4-way parallel (26 units of work divided by a span of 6). However, AlgorithmÂ 2 is work-efficientâit performs only a constant factorÂ (2) of the amount of work required by the sequential algorithmâwhile AlgorithmÂ 1 is work-inefficientâit performs asymptotically more work (a logarithmic factor) than is required sequentially. Consequently, AlgorithmÂ 1 is likely to perform better when abundant parallelism is available, but AlgorithmÂ 2 is likely to perform better when parallelism is more limited.
Parallel algorithms for prefix sums can often be generalized to other scan operations on associative binary operations,[3][4] and they can also be computed efficiently on modern parallel hardware such as a GPU.[12] The idea of building in hardware a functional unit dedicated to computing multi-parameter prefix-sum was patented by Uzi Vishkin.[13]
Many parallel implementations follow a two pass procedure where partial prefix sums are calculated in the first pass on each processing unit; the prefix sum of these partial sums is then calculated and broadcast back to the processing units for a second pass using the now known prefix as the initial value. Asymptotically this method takes approximately two read operations and one write operation per item.

Concrete implementations of prefix sum algorithms[edit]
An implementation of a parallel prefix sum algorithm, like other parallel algorithms, has to take the parallelization architecture of the platform into account. More specifically, multiple algorithms exist which are adapted for platforms working on shared memory as well as algorithms which are well suited for platforms using distributed memory, relying on message passing as the only form of interprocess communication.

Shared memory: Two-level algorithm[edit]
The following algorithm assumes a shared memory machine model; all processing elements (PEs) have access to the same memory. A version of this algorithm is implemented in the Multi-Core Standard Template Library (MCSTL),[14][15] a parallel implementation of the C++ standard template library which provides adapted versions for parallel computing of various algorithms.
In order to concurrently calculate the prefix sum over 
  
    
      
        n
      
    
    {\displaystyle n}
  
 data elements with 
  
    
      
        p
      
    
    {\displaystyle p}
  
 processing elements, the data is divided into 
  
    
      
        p
        +
        1
      
    
    {\displaystyle p+1}
  
 blocks, each containing 
  
    
      
        
          
            n
            
              p
              +
              1
            
          
        
      
    
    {\displaystyle {\frac {n}{p+1}}}
  
 elements (for simplicity we assume that 
  
    
      
        p
        +
        1
      
    
    {\displaystyle p+1}
  
 divides 
  
    
      
        n
      
    
    {\displaystyle n}
  
). Note, that although the algorithm divides the data into 
  
    
      
        p
        +
        1
      
    
    {\displaystyle p+1}
  
 blocks, only 
  
    
      
        p
      
    
    {\displaystyle p}
  
 processing elements run in parallel at a time.
In a first sweep, each PE calculates a local prefix sum for its block. The last block does not need to be calculated, since these prefix sums are only calculated as offsets to the prefix sums of succeeding blocks and the last block is by definition not succeeded.
The 
  
    
      
        p
      
    
    {\displaystyle p}
  
 offsets which are stored in the last position of each block are accumulated in a prefix sum of their own and stored in their succeeding positions. For 
  
    
      
        p
      
    
    {\displaystyle p}
  
 being a small number, it is faster to do this sequentially, for a large 
  
    
      
        p
      
    
    {\displaystyle p}
  
, this step could be done in parallel as well.
A second sweep is performed. This time the first block does not have to be processed, since it does not need to account for the offset of a preceding block. However, in this sweep the last block is included instead and the prefix sums for each block are calculated taking the prefix sum block offsets calculated in the previous sweep into account.

function prefix_sum(elements) {
    n := size(elements)
    p := number of processing elements
    prefix_sum := [0...0] of size n
    
    do parallel i = 0 to p-1 {
        // iÂ := index of current PE
        from j = i * n / (p+1) to (i+1) * n / (p+1) - 1 do {
            // This only stores the prefix sum of the local blocks
            store_prefix_sum_with_offset_in(elements, 0, prefix_sum)
        }
    }
    
    x = 0
    
    for i = 1 to p {                        // Serial accumulation of total sum of blocks 
        x +=  prefix_sum[i * n / (p+1) - 1] // Build the prefix sum over the first p blocks
        prefix_sum[i * n / (p+1)] = x       // Save the results to be used as offsets in second sweep
    }
    
    do parallel i = 1 to p {
        // iÂ := index of current PE
        from j = i * n / (p+1) to (i+1) * n / (p+1) - 1 do {
            offset := prefix_sum[i * n / (p+1)]
            // Calculate the prefix sum taking the sum of preceding blocks as offset
            store_prefix_sum_with_offset_in(elements, offset, prefix_sum)
        }
    }
    
    return prefix_sum
}

Improvement: In case that the number of blocks are too much that makes the serial step time-consuming by deploying a single processor, the Hillis and Steele algorithm can be used to accelerate the second phase.

Distributed memory: Hypercube algorithm[edit]
The Hypercube Prefix Sum Algorithm[16] is well adapted for distributed memory platforms and works with the exchange of messages between the processing elements. It assumes to have 
  
    
      
        p
        =
        
          2
          
            d
          
        
      
    
    {\displaystyle p=2^{d}}
  
 processor elements (PEs) participating in the algorithm equal to the number of corners in a 
  
    
      
        d
      
    
    {\displaystyle d}
  
-dimensional hypercube.

  Different hypercubes for varying number of nodes
Throughout the algorithm, each PE is seen as a corner in a hypothetical hyper cube with knowledge of the total prefix sum 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 as well as the prefix sum 
  
    
      
        x
      
    
    {\displaystyle x}
  
 of all elements up to itself (according to the ordered indices among the PEs), both in its own hypercube.

The algorithm starts by assuming every PE is the single corner of a zero dimensional hyper cube and therefore 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 and 
  
    
      
        x
      
    
    {\displaystyle x}
  
 are equal to the local prefix sum of its own elements.
The algorithm goes on by unifying hypercubes which are adjacent along one dimension. During each unification, 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 is exchanged and aggregated between the two hyper cubes which keeps the invariant that all PEs at corners of this new hyper cube store the total prefix sum of this newly unified hyper cube in their variable 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
. However, only the hyper cube containing the PEs with higher index also adds this 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 to their local variable 
  
    
      
        x
      
    
    {\displaystyle x}
  
, keeping the invariant that 
  
    
      
        x
      
    
    {\displaystyle x}
  
 only stores the value of the prefix sum of all elements at PEs with indices smaller or equal to their own index.
In a 
  
    
      
        d
      
    
    {\displaystyle d}
  
-dimensional hyper cube with 
  
    
      
        
          2
          
            d
          
        
      
    
    {\displaystyle 2^{d}}
  
 PEs at the corners, the algorithm has to be repeated 
  
    
      
        d
      
    
    {\displaystyle d}
  
 times to have the 
  
    
      
        
          2
          
            d
          
        
      
    
    {\displaystyle 2^{d}}
  
zero-dimensional hyper cubes be unified into one 
  
    
      
        d
      
    
    {\displaystyle d}
  
-dimensional hyper cube.
Assuming a duplex communication model where the 
  
    
      
        Ï
      
    
    {\displaystyle \sigma }
  
 of two adjacent PEs in different hyper cubes can be exchanged in both directions in one communication step, this means 
  
    
      
        d
        =
        
          log
          
            2
          
        
        â¡
        p
      
    
    {\displaystyle d=\log _{2}p}
  
 communication startups.

i := Index of own processor element (PE)
m := prefix sum of local elements of this PE
d := number of dimensions of the hyper cube

x = m;     // Invariant: The prefix sum up to this PE in the current sub cube
Ï = m;     // Invariant: The prefix sum of all elements in the current sub cube

for (k=0; k <= d-1; k++) {
    y = Ï @ PE(i xor 2^k)  // Get the total prefix sum of the opposing sub cube along dimension k
    Ï = Ï + y              // Aggregate the prefix sum of both sub cubes

    if (i & 2^k) {
        x = x + y  // Only aggregate the prefix sum from the other sub cube, if this PE is the higher index one.
    }
}

Large message sizes: pipelined binary tree[edit]
The Pipelined Binary Tree Algorithm[17] is another algorithm for distributed memory platforms which is specifically well suited for large message sizes.
Like the hypercube algorithm, it assumes a special communication structure. The processing elements (PEs) are hypothetically arranged in a binary tree (e.g. a Fibonacci Tree) with infix numeration according to their index within the PEs. Communication on such a tree always occurs between parent and child nodes.
The infix numeration ensures that for any given PEj, the indices of all nodes reachable by its left subtree 
  
    
      
        
          [
          l
          .
          .
          .
          j
          â
          1
          ]
        
      
    
    {\displaystyle \mathbb {[l...j-1]} }
  
 are less than 
  
    
      
        j
      
    
    {\displaystyle j}
  
 and the indices 
  
    
      
        
          [
          j
          +
          1...
          r
          ]
        
      
    
    {\displaystyle \mathbb {[j+1...r]} }
  
 of all nodes in the right subtree are greater than 
  
    
      
        j
      
    
    {\displaystyle j}
  
. The parent's index is greater than any of the indices in PEj's subtree if PEj is a left child and smaller if PEj is a right child. 
This allows for the following reasoning:

  Information exchange between processing elements during upward (blue) and downward (red) phase in the Pipelined Binary Tree Prefix Sum algorithm.
The local prefix sum 
  
    
      
        
          â
          [
          l
          .
          .
          j
          â
          1
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [l..j-1]} }
  
 of the left subtree has to be aggregated to calculate PEj's local prefix sum 
  
    
      
        
          â
          [
          l
          .
          .
          j
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [l..j]} }
  
.
The local prefix sum 
  
    
      
        
          â
          [
          j
          +
          1..
          r
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [j+1..r]} }
  
 of the right subtree has to be aggregated to calculate the local prefix sum of higher level PEh which are reached on a path containing a left children connection (which means 
  
    
      
        h
        >
        j
      
    
    {\displaystyle h>j}
  
).
The total prefix sum 
  
    
      
        
          â
          [
          0..
          j
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [0..j]} }
  
 of PEj is necessary to calculate the total prefix sums in the right subtree (e.g. 
  
    
      
        
          â
          [
          0..
          j
          .
          .
          r
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [0..j..r]} }
  
 for the highest index node in the subtree).
PEj needs to include the total prefix sum 
  
    
      
        
          â
          [
          0..
          l
          â
          1
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [0..l-1]} }
  
 of the first higher order node which is reached via an upward path including a right children connection to calculate its total prefix sum.
Note the distinction between subtree-local and total prefix sums. The points two, three and four can lead to believe they would form a circular dependency, but this is not the case. Lower level PEs might require the total prefix sum of higher level PEs to calculate their total prefix sum, but higher level PEs only require subtree local prefix sums to calculate their total prefix sum. The root node as highest level node only requires the local prefix sum of its left subtree to calculate its own prefix sum. Each PE on the path from PE0 to the root PE only requires the local prefix sum of its left subtree to calculate its own prefix sum, whereas every node on the path from PEp-1 (last PE) to the PEroot requires the total prefix sum of its parent to calculate its own total prefix sum.
This leads to a two-phase algorithm:
Upward PhasePropagate the subtree local prefix sum 
  
    
      
        
          â
          [
          l
          .
          .
          j
          .
          .
          r
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [l..j..r]} }
  
 to its parent for each PEj.
Downward phasePropagate the exclusive (exclusive PEj as well as the PEs in its left subtree) total prefix sum 
  
    
      
        
          â
          [
          0..
          l
          â
          1
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [0..l-1]} }
  
 of all lower index PEs which are not included in the addressed subtree of PEj to lower level PEs in the left child subtree of PEj. Propagate the inclusive prefix sum 
  
    
      
        
          â
          [
          0..
          j
          ]
        
      
    
    {\displaystyle \mathbb {\oplus [0..j]} }
  
 to the right child subtree of PEj.
Note that the algorithm is run in parallel at each PE and the PEs will block upon receive until their children/parents provide them with packets.

k := number of packets in a message m of a PE
m @ {left, right, parent, this} := // Messages at the different PEs

x = m @ this

// Upward phase - Calculate subtree local prefix sums
for j=0 to k-1: // Pipelining: For each packet of a message
    if hasLeftChild:
        blocking receive m[j] @ left // This replaces the local m[j] with the received m[j]
        // Aggregate inclusive local prefix sum from lower index PEs
        x[j] = m[j] â¨ x[j]

    if hasRightChild:
        blocking receive m[j] @ right
        // We do not aggregate m[j] into the local prefix sum, since the right children are higher index PEs
        send x[j] â¨ m[j] to parent
    else:
        send x[j] to parent

// Downward phase
for j=0 to k-1:
    m[j] @ this = 0

    if hasParent:
        blocking receive m[j] @ parent
        // For a left child m[j] is the parents exclusive prefix sum, for a right child the inclusive prefix sum
        x[j] = m[j] â¨ x[j] 
    
    send m[j] to left  // The total prefix sum of all PE's smaller than this or any PE in the left subtree
    send x[j] to right // The total prefix sum of all PE's smaller or equal than this PE

Pipelining[edit]
If the message 
  
    
      
        m
      
    
    {\displaystyle m}
  
 of length 
  
    
      
        n
      
    
    {\displaystyle n}
  
 can be divided into 
  
    
      
        k
      
    
    {\displaystyle k}
  
 packets and the operator â¨ can be used on each of the corresponding message packets separately, pipelining is possible.[17]
If the algorithm is used without pipelining, there are always only two levels (the sending PEs and the receiving PEs) of the binary tree at work while all other PEs are waiting. If there are 
  
    
      
        p
      
    
    {\displaystyle p}
  
 processing elements and a balanced binary tree is used, the tree has 
  
    
      
        
          log
          
            2
          
        
        â¡
        p
      
    
    {\displaystyle \log _{2}p}
  
 levels, the length of the path from 
  
    
      
        P
        
          E
          
            0
          
        
      
    
    {\displaystyle PE_{0}}
  
 to 
  
    
      
        P
        
          E
          
            
              r
              o
              o
              t
            
          
        
      
    
    {\displaystyle PE_{\mathbb {root} }}
  
 is therefore 
  
    
      
        
          log
          
            2
          
        
        â¡
        p
        â
        1
      
    
    {\displaystyle \log _{2}p-1}
  
 which represents the maximum number of non parallel communication operations during the upward phase, likewise, the communication on the downward path is also limited to 
  
    
      
        
          log
          
            2
          
        
        â¡
        p
        â
        1
      
    
    {\displaystyle \log _{2}p-1}
  
 startups. Assuming a communication startup time of 
  
    
      
        
          T
          
            
              s
              t
              a
              r
              t
            
          
        
      
    
    {\displaystyle T_{\mathbb {start} }}
  
 and a bytewise transmission time of 
  
    
      
        
          T
          
            
              b
              y
              t
              e
            
          
        
      
    
    {\displaystyle T_{\mathbb {byte} }}
  
, upward and downward phase are limited to 
  
    
      
        (
        2
        
          log
          
            2
          
        
        â¡
        p
        â
        2
        )
        (
        
          T
          
            
              s
              t
              a
              r
              t
            
          
        
        +
        n
        â
        
          T
          
            
              b
              y
              t
              e
            
          
        
        )
      
    
    {\displaystyle (2\log _{2}p-2)(T_{\mathbb {start} }+n*T_{\mathbb {byte} })}
  
 in a non pipelined scenario.
Upon division into k packets, each of size 
  
    
      
        
          
            n
            k
          
        
      
    
    {\displaystyle {\frac {n}{k}}}
  
 and sending them separately, the first packet still needs 
  
    
      
        (
        
          log
          
            2
          
        
        â¡
        p
        â
        1
        )
        (
        
          T
          
            
              s
              t
              a
              r
              t
            
          
        
        +
        
          
            n
            k
          
        
        â
        
          T
          
            
              b
              y
              t
              e
            
          
        
        )
      
    
    {\displaystyle (\log _{2}p-1)(T_{\mathbb {start} }+{\frac {n}{k}}*T_{\mathbb {byte} })}
  
 to be propagated to 
  
    
      
        P
        
          E
          
            
              r
              o
              o
              t
            
          
        
      
    
    {\displaystyle PE_{\mathbb {root} }}
  
 as part of a local prefix sum and this will occur again for the last packet if 
  
    
      
        k
        >
        
          log
          
            2
          
        
        â¡
        p
      
    
    {\displaystyle k>\log _{2}p}
  
. However, in between, all the PEs along the path can work in parallel and each third communication operation (receive left, receive right, send to parent) sends a packet to the next level, so that one phase can be completed in 
  
    
      
        2
        
          log
          
            2
          
        
        â¡
        p
        â
        1
        +
        3
        (
        k
        â
        1
        )
      
    
    {\displaystyle 2\log _{2}p-1+3(k-1)}
  
 communication operations and both phases together need 
  
    
      
        (
        4
        â
        
          log
          
            2
          
        
        â¡
        p
        â
        2
        +
        6
        (
        k
        â
        1
        )
        )
        (
        
          T
          
            
              s
              t
              a
              r
              t
            
          
        
        +
        
          
            n
            k
          
        
        â
        
          T
          
            
              b
              y
              t
              e
            
          
        
        )
      
    
    {\displaystyle (4*\log _{2}p-2+6(k-1))(T_{\mathbb {start} }+{\frac {n}{k}}*T_{\mathbb {byte} })}
  
 which is favourable for large message sizes 
  
    
      
        n
      
    
    {\displaystyle n}
  
.
The algorithm can further be optimised by making use of full-duplex or telephone model communication and overlapping the upward and the downward phase.[17]

Data structures[edit]
When a data set may be updated dynamically, it may be stored in a Fenwick tree data structure. This structure allows both the lookup of any individual prefix sum value and the modification of any array value in logarithmic time per operation.[18] However, an earlier 1982 paper [19] presents a data structure called Partial Sums Tree (see Section 5.1) that appears to overlap Fenwick trees; in 1982 the term prefix-sum was not yet as common as it is today.
For higher-dimensional arrays, the summed area table provides a data structure based on prefix sums for computing sums of arbitrary rectangular subarrays. This can be a helpful primitive in image convolution operations.[20]

Applications[edit]
Counting sort is an integer sorting algorithm that uses the prefix sum of a histogram of key frequencies to calculate the position of each key in the sorted output array. It runs in linear time for integer keys that are smaller than the number of items, and is frequently used as part of radix sort, a fast algorithm for sorting integers that are less restricted in magnitude.[1]
List ranking, the problem of transforming a linked list into an array that represents the same sequence of items, can be viewed as computing a prefix sum on the sequence 1, 1, 1, ... and then mapping each item to the array position given by its prefix sum value; by combining list ranking, prefix sums, and Euler tours, many important problems on trees may be solved by efficient parallel algorithms.[4]
An early application of parallel prefix sum algorithms was in the design of binary adders, Boolean circuits that can add two n-bit binary numbers. In this application, the sequence of carry bits of the addition can be represented as a scan operation
on the sequence of pairs of input bits, using the majority function to combine the previous carry with these two bits. Each bit of the output number can then be found as the exclusive or of two input bits with the corresponding carry bit. By using a circuit that performs the operations of the parallel prefix sum algorithm, it is possible to design an adder that uses O(n) logic gates and O(log n) time steps.[3][10][11]
In the parallel random access machine model of computing, prefix sums can be used to simulate parallel algorithms that assume the ability for multiple processors to access the same memory cell at the same time, on parallel machines that forbid simultaneous access. By means of a sorting network, a set of parallel memory access requests can be ordered into a sequence such that accesses to the same cell are contiguous within the sequence; scan operations can then be used to determine which of the accesses succeed in writing to their requested cells, and to distribute the results of memory read operations to multiple processors that request the same result.[21]
In Guy Blelloch's Ph.D. thesis,[22] parallel prefix operations form part of the formalization of the Data parallelism model provided by machines such as the Connection Machine. The Connection Machine CM-1 and CM-2 provided a hypercubic network on which the Algorithm 1 above could be implemented, whereas the CM-5 provided a dedicated network to implement Algorithm 2.[23]
In the construction of Gray codes, sequences of binary values with the property that consecutive sequence values differ from each other in a single bit position, a number n can be converted into the Gray code value at position n of the sequence simply by taking the exclusive or of n and n/2 (the number formed by shifting n right by a single bit position). The reverse operation, decoding a Gray-coded value x into a binary number, is more complicated, but can be expressed as the prefix sum of the bits ofÂ x, where each summation operation within the prefix sum is performed modulo two. A prefix sum of this type may be performed efficiently using the bitwise Boolean operations available on modern computers, by computing the exclusive or of x with each of the numbers formed by shifting x to the left by a number of bits that is a power of two.[24]
Parallel prefix (using multiplication as the underlying associative operation) can also be used to build fast algorithms for parallel polynomial interpolation. In particular, it can be used to compute the divided difference coefficients of the Newton form of the interpolation polynomial.[25] 
This prefix based approach can also be used to obtain the generalized divided differences for (confluent) Hermite interpolation
as well as for parallel algorithms for Vandermonde systems.[26]

See also[edit]
General-purpose computing on graphics processing units
Summed-area table
References[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2001), "8.2 Counting Sort", Introduction to Algorithms (2ndÂ ed.), MIT Press and McGraw-Hill, pp.Â 168â170, ISBNÂ 0-262-03293-7.

^ Cole, Richard; Vishkin, Uzi (1986), "Deterministic coin tossing with applications to optimal parallel list ranking", Information and Control, 70 (1): 32â53, doi:10.1016/S0019-9958(86)80023-7

^ Jump up to: a b c d e Ladner, R. E.; Fischer, M. J. (1980), "Parallel Prefix Computation", Journal of the ACM, 27 (4): 831â838, CiteSeerXÂ 10.1.1.106.6247, doi:10.1145/322217.322232, MRÂ 0594702.

^ Jump up to: a b c Tarjan, Robert E.; Vishkin, Uzi (1985), "An efficient parallel biconnectivity algorithm", SIAM Journal on Computing, 14 (4): 862â874, doi:10.1137/0214061.

^ Lakshmivarahan, S.; Dhall, S.K. (1994), Parallelism in the Prefix Problem, Oxford University Press, ISBNÂ 0-19508849-2.

^ Blelloch, Guy (2011), Prefix Sums and Their Applications (Lecture Notes) (PDF), Carnegie Mellon University.

^ Callahan, Paul; Kosaraju, S. Rao (1995), "A Decomposition of Multi-Dimensional Point Sets with Applications to k-Nearest-Neighbors and n-Body Potential Fields", Journal of the ACM, 42 (1): 67â90, doi:10.1145/200836.200853.

^ "GPU Gems 3".

^ 
Hillis, W. Daniel; Steele, Jr., Guy L. (December 1986). "Data parallel algorithms". Communications of the ACM. 29 (12): 1170â1183. doi:10.1145/7902.7903.

^ Jump up to: a b Ofman, Yu. (1962),  ÐÐ± Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼Ð¸ÑÐµÑÐºÐ¾Ð¹ ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑÐ¸ Ð´Ð¸ÑÐºÑÐµÑÐ½ÑÑ ÑÑÐ½ÐºÑÐ¸Ð¹, Doklady Akademii Nauk SSSR (in Russian), 145 (1): 48â51, MRÂ 0168423. English translation, "On the algorithmic complexity of discrete functions", Soviet Physics Doklady 7: 589â591 1963.

^ Jump up to: a b Khrapchenko, V. M. (1967), "Asymptotic Estimation of Addition Time of a Parallel Adder", Problemy Kibernet. (in Russian), 19: 107â122. English translation in Syst. Theory Res. 19; 105â122, 1970.

^ Sengupta, Shubhabrata; Harris, Mark; Zhang, Yao; Owens, John D. (2007). Scan primitives for GPU computing. Proc. 22nd ACM SIGGRAPH/EUROGRAPHICS Symposium on Graphics Hardware. pp.Â 97â106. Archived from the original on 2014-09-03. Retrieved 2007-11-29.

^ Vishkin, Uzi (2003). Prefix sums and an application thereof. U.S. Patent 6,542,918.

^ Singler, Johannes. "MCSTL: The Multi-Core Standard Template Library". Retrieved 2019-03-29.

^ Singler, Johannes; Sanders, Peter; Putze, Felix (2007). "MCSTL: The Multi-core Standard Template Library". Euro-Par 2007 Parallel Processing. Lecture Notes in Computer Science. Vol.Â 4641. pp.Â 682â694. doi:10.1007/978-3-540-74466-5_72. ISBNÂ 978-3-540-74465-8. ISSNÂ 0302-9743.

^ Ananth Grama; Vipin Kumar; Anshul Gupta (2003). Introduction to Parallel Computing. Addison-Wesley. pp.Â 85, 86. ISBNÂ 978-0-201-64865-2.

^ Jump up to: a b c Sanders, Peter; TrÃ¤ff, Jesper Larsson (2006). "Parallel Prefix (Scan) Algorithms for MPI". Recent Advances in Parallel Virtual Machine and Message Passing Interface. Lecture Notes in Computer Science. Vol.Â 4192. pp.Â 49â57. doi:10.1007/11846802_15. ISBNÂ 978-3-540-39110-4. ISSNÂ 0302-9743.

^ Fenwick, Peter M. (1994), "A new data structure for cumulative frequency tables", Software: Practice and Experience, 24 (3): 327â336, doi:10.1002/spe.4380240306

^ Shiloach, Yossi; Vishkin, Uzi (1982b), "An O(n2Â logÂ n) parallel max-flow algorithm", Journal of Algorithms, 3 (2): 128â146, doi:10.1016/0196-6774(82)90013-X

^ Szeliski, Richard (2010), "Summed area table (integral image)", Computer Vision: Algorithms and Applications, Texts in Computer Science, Springer, pp.Â 106â107, ISBNÂ 9781848829350.

^ Vishkin, Uzi (1983), "Implementation of simultaneous memory address access in models that forbid it", Journal of Algorithms, 4 (1): 45â50, doi:10.1016/0196-6774(83)90033-0, MRÂ 0689265.

^ Blelloch, Guy E. (1990). Vector models for data-parallel computing. Cambridge, MA: MIT Press. ISBNÂ 026202313X. OCLCÂ 21761743.

^ Leiserson, Charles E.; Abuhamdeh, Zahi S.; Douglas, David C.; Feynman, Carl R.; Ganmukhi, Mahesh N.; Hill, Jeffrey V.; Hillis, W. Daniel; Kuszmaul, Bradley C.; St. Pierre, Margaret A. (March 15, 1996). "The Network Architecture of the Connection Machine CM-5". Journal of Parallel and Distributed Computing. 33 (2): 145â158. doi:10.1006/jpdc.1996.0033. ISSNÂ 0743-7315.

^ Warren, Henry S. (2003), Hacker's Delight, Addison-Wesley, p.Â 236, ISBNÂ 978-0-201-91465-8.

^ EÄecioÄlu, O.; Gallopoulos, E.; KoÃ§, C. (1990), "A parallel method for fast and practical high-order Newton interpolation", BIT Computer Science and Numerical Mathematics, 30 (2): 268â288, doi:10.1007/BF02017348.

^ EÄecioÄlu, O.; Gallopoulos, E.; KoÃ§, C. (1989), "Fast computation of divided differences and parallel Hermite interpolation", Journal of Complexity, 5 (4): 417â437, doi:10.1016/0885-064X(89)90018-6


External links[edit]
Weisstein, Eric W. "Cumulative Sum". MathWorld.




<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Prefix_sum&oldid=1060355926"
		Categories: Concurrent algorithmsHigher-order functionsHidden categories: CS1 uses Russian-language script (ru)CS1 Russian-language sources (ru)
	
