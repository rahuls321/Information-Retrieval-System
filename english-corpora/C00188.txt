
Title:
IEEE 754
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		IEEE Standard for floating-point arithmetic

The IEEE Standard for Floating-Point Arithmetic (IEEE 754) is a technical standard  for floating-point arithmetic established in 1985 by the Institute of Electrical and Electronics Engineers (IEEE). The standard addressed many problems found in the diverse floating-point implementations that made them difficult to use reliably and portably. Many hardware floating-point units use the IEEE 754 standard.
The standard defines:

arithmetic formats: sets of binary and decimal floating-point data, which consist of finite numbers (including signed zeros and subnormal numbers), infinities, and special "not a number" values (NaNs)
interchange formats: encodings (bit strings) that may be used to exchange floating-point data in an efficient and compact form
rounding rules: properties to be satisfied when rounding numbers during arithmetic and conversions
operations: arithmetic and other operations (such as trigonometric functions) on arithmetic formats
exception handling: indications of exceptional conditions (such as division by zero, overflow, etc.)
IEEE 754-2008, published in August 2008, includes nearly all of the original IEEE 754-1985 standard, plus the IEEE 854-1987 Standard for Radix-Independent Floating-Point Arithmetic.  The current version, IEEE 754-2019, was published in July 2019.[1] It is a minor revision of the previous version, incorporating mainly clarifications, defect fixes and new recommended operations.

Contents

1 Standard development
2 Formats

2.1 Representation and encoding in memory
2.2 Basic and interchange formats
2.3 Extended and extendable precision formats
2.4 Interchange formats

2.4.1 Binary
2.4.2 Decimal




3 Rounding rules

3.1 Roundings to nearest
3.2 Directed roundings


4 Required operations

4.1 Comparison predicates
4.2 Total-ordering predicate


5 Exception handling
6 Recommendations

6.1 Alternate exception handling
6.2 Recommended operations
6.3 Expression evaluation
6.4 Reproducibility


7 Character representation

7.1 Hexadecimal literals


8 See also
9 Notes
10 References

10.1 Standards
10.2 Secondary references


11 Further reading
12 External links



Standard development[edit]
The first standard for floating-point arithmetic, IEEE 754-1985, was published in 1985. It covered only binary floating-point arithmetic.
A new version, IEEE 754-2008, was published in August 2008, following a seven-year revision process, chaired by Dan Zuras and edited by Mike Cowlishaw. It replaced both IEEE 754-1985 (binary floating-point arithmetic) and IEEE 854-1987 Standard for Radix-Independent Floating-Point Arithmetic. The binary formats in the original standard are included in this new standard along with three new basic formats, one binary and two decimal.  To conform to the current standard, an implementation must implement at least one of the basic formats as both an arithmetic format and an interchange format.
The international standard ISO/IEC/IEEE 60559:2011 (with content identical to IEEE 754-2008) has been approved for adoption through JTC1/SC 25 under the ISO/IEEE PSDO Agreement[2][3] and published.[4]
The current version, IEEE 754-2019 published in July 2019, is derived from and replaces IEEE 754-2008, following a revision process started in September 2015, chaired by David G. Hough and edited by Mike Cowlishaw. It incorporates mainly clarifications (e.g. totalOrder) and defect fixes (e.g. minNum), but also includes some new recommended operations (e.g. augmentedAddition).[5][6]
The international standard ISO/IEC 60559:2020 (with content identical to IEEE 754-2019) has been approved for adoption through JTC1/SC 25 and published.[7]
The next projected revision of the standard is in 2028.[8]

Formats[edit]
An IEEE 754 format is a "set of representations of numerical values and symbols". A format may also include how the set is encoded.[9]
A floating-point format is specified by:

a base (also called radix) b, which is either 2 (binary) or 10 (decimal) in IEEE 754;
a precision p;
an exponent range from emin to emax, with emin = 1 â emax for all IEEE 754 formats.
A format comprises:

Finite numbers, which can be described by three integers: sÂ = a sign (zero or one), cÂ = a significand (or coefficient) having no more than p digits when written in base b (i.e., an integer in the range through 0 to bpÂ âÂ 1), and qÂ = an exponent such that emin â¤ qÂ +Â pÂ âÂ 1 â¤ emax. The numerical value of such a finite number is (â1)s Ã c Ã bq.[a] Moreover, there are two zero values, called signed zeros: the sign bit specifies whether a zero is +0 (positive zero) or â0 (negative zero).
Two infinities: +â and ââ.
Two kinds of NaN (not-a-number): a quiet NaN (qNaN) and a signaling NaN (sNaN).
For example, if b = 10, p = 7, and emax = 96, then emin = â95, the significand satisfies 0 â¤ c â¤ 9999999, and the exponent satisfies â101 â¤ q â¤ 90. Consequently, the smallest non-zero positive number that can be represented is 1Ã10â101, and the largest is 9999999Ã1090 (9.999999Ã1096), so the full range of numbers is â9.999999Ã1096 through 9.999999Ã1096. The numbers âb1âemax and b1âemax (here, â1Ã10â95 and 1Ã10â95) are the smallest (in magnitude) normal numbers; non-zero numbers between these smallest numbers are called subnormal numbers.

Representation and encoding in memory[edit]
Some numbers may have several possible exponential format representations. For instance, if bÂ =Â 10, and pÂ =Â 7, then â12.345 can be represented by â12345Ã10â3, â123450Ã10â4, and â1234500Ã10â5. However, for most operations, such as arithmetic operations, the result (value) does not depend on the representation of the inputs.
For the decimal formats, any representation is valid, and the set of these representations is called a cohort. When a result can have several representations, the standard specifies which member of the cohort is chosen.
For the binary formats, the representation is made unique by choosing the smallest representable exponent allowing the value to be represented exactly. Further, the exponent is not represented directly, but a bias is added so that the smallest representable exponent is represented as 1, with 0 used for subnormal numbers. For numbers with an exponent in the normal range (the exponent field being neither all ones nor all zeros), the leading bit of the significand will always be 1. Consequently, a leading 1 can be implied rather than explicitly present in the memory encoding, and under the standard the explicitly represented part of the significand will lie between 0 and 1. This rule is called leading bit convention, implicit bit convention, or hidden bit convention. This rule allows the binary format to have an extra bit of precision. The leading bit convention cannot be used for the subnormal numbers as they have an exponent outside the normal exponent range and scale by the smallest represented exponent as used for the smallest normal numbers.
Due to the possibility of multiple encodings (at least in formats called interchange formats), a NaN may carry other information: a sign bit (which has no meaning, but may be used by some operations) and a payload, which is intended for diagnostic information indicating the source of the NaN (but the payload may have other uses, such as NaN-boxing[10][11][12]).

Basic and interchange formats[edit]
The standard defines five basic formats that are named for their numeric base and the number of bits used in their interchange encoding. There are three binary floating-point basic formats (encoded with 32, 64 or 128 bits) and two decimal floating-point basic formats (encoded with 64 or 128 bits). The binary32 and binary64 formats are the single and double formats of IEEE 754-1985 respectively. A conforming implementation must fully implement at least one of the basic formats.
The standard also defines interchange formats, which generalize these basic formats.[13] For the binary formats, the leading bit convention is required. The following table summarizes the smallest interchange formats (including the basic ones).



Name
Common name
Base
Significand bits[b] or digits
Decimal digits
Exponent bits
Decimal E max
Exponent bias[14]
E min
E max
Notes


binary16
Half precision
2
11
3.31
5
4.51
24â1 = 15
â14
+15
not basic


binary32
Single precision
2
24
7.22
8
38.23
27â1 = 127
â126
+127



binary64
Double precision
2
53
15.95
11
307.95
210â1 = 1023
â1022
+1023



binary128
Quadruple precision
2
113
34.02
15
4931.77
214â1 = 16383
â16382
+16383



binary256
Octuple precision
2
237
71.34
19
78913.2
218â1 = 262143
â262142
+262143
not basic


decimal32

10
7
7
7.58
96
101
â95
+96
not basic


decimal64

10
16
16
9.58
384
398
â383
+384



decimal128

10
34
34
13.58
6144
6176
â6143
+6144



Note that in the table above, the minimum exponents listed are for normal numbers; the special subnormal number representation allows even smaller numbers to be represented (with some loss of precision). For example, the smallest positive number that can be represented in binary64 is 2â1074; contributions to the â1074 figure include the EÂ min value â1022 and all but one of the 53 significand bits (2â1022Â âÂ (53Â âÂ 1)Â =Â 2â1074).
Decimal digits is digits Ã log10 base. This gives an approximate precision in number of decimal digits.
Decimal E max is Emax Ã log10 base. This gives an approximate value of the maximum decimal exponent.
The binary32 (single) and binary64 (double) formats are two of the most common formats used today. The figure below shows the absolute precision for both formats over a range of values. This figure can be used to select an appropriate format given the expected value of a number and the required precision.

  Precision of binary32 and binary64 in the range 10â12 to 1012

An example of a layout for 32-bit floating point is


and the 64 bit layout is similar.

Extended and extendable precision formats[edit]
The standard specifies optional extended and extendable precision formats, which provide greater precision than the basic formats.[15] An extended precision format extends a basic format by using more precision and more exponent range. An extendable precision format allows the user to specify the precision and exponent range. An implementation may use whatever internal representation it chooses for such formats; all that needs to be defined are its parameters (b, p, and emax). These parameters uniquely describe the set of finite numbers (combinations of sign, significand, and exponent for the given radix) that it can represent.
The standard recommends that language standards provide a method of specifying p and emax for each supported base b.[16] The standard recommends that language standards and implementations support an extended format which has a greater precision than the largest basic format supported for each radix b.[17] For an extended format with a precision between two basic formats the exponent range must be as great as that of the next wider basic format. So for instance a 64-bit extended precision binary number must have an 'emax' of at least 16383. The x87 80-bit extended format meets this requirement.

Interchange formats[edit]
Interchange formats are intended for the exchange of floating-point data using a bit string of fixed length for a given format. 

Binary[edit]
For the exchange of binary floating-point numbers, interchange formats of length 16 bits, 32 bits, 64 bits, and any multiple of 32 bits â¥ 128[c] are defined.  The 16-bit format is intended for the exchange or storage of small numbers (e.g., for graphics).
The encoding scheme for these binary interchange formats is the same as that of IEEE 754-1985: a sign bit, followed by w exponent bits that describe the exponent offset by a bias, and pÂ âÂ 1 bits that describe the significand.  The width of the exponent field for a k-bit format is computed as wÂ =Â round(4Â log2(k))Â âÂ 13.  The existing 64- and 128-bit formats follow this rule, but the 16- and 32-bit formats have more exponent bits (5 and 8 respectively) than this formula would provide (3 and 7 respectively).
As with IEEE 754-1985, the biased-exponent field is filled with all 1 bits to indicate either infinity (trailing significand field = 0) or a NaN (trailing significand field â  0).  For NaNs, quiet NaNs and signaling NaNs are distinguished by using the most significant bit of the trailing significand field exclusively,[d] and the payload is carried in the remaining bits.

Decimal[edit]
For the exchange of decimal floating-point numbers, interchange formats of any multiple of 32 bits are defined. As with binary interchange, the encoding scheme for the decimal interchange formats encodes the sign, exponent, and significand. Two different bit-level encodings are defined, and interchange is complicated by the fact that some external indicator of the encoding in use may be required.
The two options allow the significand to be encoded as a compressed sequence of decimal digits using densely packed decimal or, alternatively, as a binary integer.  The former is more convenient for direct hardware implementation of the standard, while the latter is more suited to software emulation on a binary computer.  In either case, the set of numbers (combinations of sign, significand, and exponent) that may be encoded is identical, and special values (Â±zero with the minimum exponent, Â±infinity, quiet NaNs, and signaling NaNs) have identical encodings.

Rounding rules[edit]
The standard defines five rounding rules.  The first two rules round to a nearest value; the others are called directed roundings:

Roundings to nearest[edit]
Round to nearest, ties to evenÂ â rounds to the nearest value; if the number falls midway, it is rounded to the nearest value with an even least significant digit; this is the default for binary floating point and the recommended default for decimal.
Round to nearest, ties away from zeroÂ â rounds to the nearest value; if the number falls midway, it is rounded to the nearest value above (for positive numbers) or below (for negative numbers); this is intended as an option for decimal floating point.
Directed roundings[edit]
Round toward 0Â â directed rounding towards zero (also known as truncation).
Round toward +âÂ â directed rounding towards positive infinity (also known as rounding up or ceiling).
Round toward ââÂ â directed rounding towards negative infinity (also known as rounding down or floor).

Example of rounding to integers using the IEEE 754 rules


Mode
Example value


+11.5

+12.5

â11.5

â12.5


to nearest, ties to even

+12.0

+12.0

â12.0

â12.0


to nearest, ties away from zero

+12.0

+13.0

â12.0

â13.0


toward 0

+11.0

+12.0

â11.0

â12.0


toward +â

+12.0

+13.0

â11.0

â12.0


toward ââ

+11.0

+12.0

â12.0

â13.0

Unless specified otherwise, the floating-point result of an operation is determined by applying the rounding function on the infinitely precise (mathematical) result. Such an operation is said to be correctly rounded. This requirement is called correct rounding.[18]

Required operations[edit]
Required operations for a supported arithmetic format (including the basic formats) include:

Arithmetic operations (add, subtract, multiply, divide, square root, fused multiplyâadd, remainder)[19][20]
Conversions (between formats, to and from strings, etc.)[21][22]
Scaling and (for decimal) quantizing[23][24]
Copying and manipulating the sign (abs, negate, etc.)[25]
Comparisons and total ordering[26][27]
Classification and testing for NaNs, etc.[28]
Testing and setting flags[29]
Miscellaneous operations.[specify]
Comparison predicates[edit]
The standard provides comparison predicates to compare one floating-point datum to another in the supported arithmetic format.[30] Any comparison with a NaN is treated as unordered. â0 and +0 compare as equal.

Total-ordering predicate[edit]
The standard provides a predicate totalOrder, which defines a total ordering on canonical members of the supported arithmetic format.[31] The predicate agrees with the comparison predicates when one floating-point number is less than the other. The totalOrder predicate does not impose a total ordering on all encodings in a format. In particular, it does not distinguish among different encodings of the same floating-point representation, as when one or both encodings are non-canonical.[32] IEEE 754-2019 incorporates clarifications of totalOrder.
For the binary interchange formats whose encoding follows the IEEE 754-2008 recommendation on placement of the NaN signaling bit, the comparison is identical to one that type puns the floating-point numbers to a signâmagnitude integer (assuming a payload ordering consistent with this comparison), an old trick for FP comparison without an FPU.[33]

Exception handling[edit]
The standard defines five exceptions, each of which returns a default value and has a corresponding status flag that is raised when the exception occurs.[e]  No other exception handling is required, but additional non-default alternatives are recommended (see Â§Â Alternate exception handling).
The five possible exceptions are:

Invalid operation: mathematically undefined, e.g., the square root of a negative number. By default, returns qNaN.
Division by zero: an operation on finite operands gives an exact infinite result, e.g., 1/0 or log(0). By default, returns Â±infinity.
Overflow: a finite result is too large to be represented accurately (i.e., its exponent with an unbounded exponent range would be larger than emax). By default, returns Â±infinity for the round-to-nearest modes (and follows the rounding rules for the directed rounding modes).
Underflow: a result is very small (outside the normal range). By default, returns a number less than or equal to the minimum positive normal number in magnitude (following the rounding rules); a subnormal always implies an underflow exception, but by default, if it is exact, no flag is raised.
Inexact: the exact (i.e., unrounded) result is not representable exactly. By default, returns the correctly rounded result.
These are the same five exceptions as were defined in IEEE 754-1985, but the division by zero exception has been extended to operations other than the division.
Some decimal floating-point implementations define additional exceptions,[34][35] which are not part of IEEE 754:

Clamped: a result's exponent is too large for the destination format. By default, trailing zeros will be added to the coefficient to reduce the exponent to the largest usable value. If this is not possible (because this would cause the number of digits needed to be more than the destination format) then an overflow exception occurs.
Rounded: a result's coefficient requires more digits than the destination format provides. An inexact exception is signaled if any non-zero digits are discarded.
Additionally, operations like quantize when either operand is infinite, or when the result does not fit the destination format, will also signal invalid operation exception.[36]

Recommendations[edit]
Alternate exception handling[edit]
The standard recommends optional exception handling in various forms, including presubstitution of user-defined default values, and traps (exceptions that change the flow of control in some way) and other exception handling models that interrupt the flow, such as try/catch.  The traps and other exception mechanisms remain optional, as they were in IEEE 754-1985.

Recommended operations[edit]
Clause 9 in the standard recommends additional mathematical operations[37] that language standards should define.[38]  None are required in order to conform to the standard.
Recommended arithmetic operations, which must round correctly:[39]


  
    
      
        
          e
          
            x
          
        
      
    
    {\displaystyle e^{x}}
  
, 
  
    
      
        
          2
          
            x
          
        
      
    
    {\displaystyle 2^{x}}
  
, 
  
    
      
        
          10
          
            x
          
        
      
    
    {\displaystyle 10^{x}}
  


  
    
      
        
          e
          
            x
          
        
        â
        1
      
    
    {\displaystyle e^{x}-1}
  
, 
  
    
      
        
          2
          
            x
          
        
        â
        1
      
    
    {\displaystyle 2^{x}-1}
  
, 
  
    
      
        
          10
          
            x
          
        
        â
        1
      
    
    {\displaystyle 10^{x}-1}
  


  
    
      
        ln
        â¡
        x
      
    
    {\displaystyle \ln x}
  
, 
  
    
      
        
          log
          
            2
          
        
        â¡
        x
      
    
    {\displaystyle \log _{2}x}
  
, 
  
    
      
        
          log
          
            10
          
        
        â¡
        x
      
    
    {\displaystyle \log _{10}x}
  


  
    
      
        ln
        â¡
        (
        1
        +
        x
        )
      
    
    {\displaystyle \ln(1+x)}
  
, 
  
    
      
        
          log
          
            2
          
        
        â¡
        (
        1
        +
        x
        )
      
    
    {\displaystyle \log _{2}(1+x)}
  
, 
  
    
      
        
          log
          
            10
          
        
        â¡
        (
        1
        +
        x
        )
      
    
    {\displaystyle \log _{10}(1+x)}
  


  
    
      
        
          
            
              x
              
                2
              
            
            +
            
              y
              
                2
              
            
          
        
      
    
    {\displaystyle {\sqrt {x^{2}+y^{2}}}}
  


  
    
      
        
          
            x
          
        
      
    
    {\displaystyle {\sqrt {x}}}
  


  
    
      
        (
        1
        +
        x
        
          )
          
            n
          
        
      
    
    {\displaystyle (1+x)^{n}}
  


  
    
      
        
          x
          
            
              1
              n
            
          
        
      
    
    {\displaystyle x^{\frac {1}{n}}}
  


  
    
      
        
          x
          
            n
          
        
      
    
    {\displaystyle x^{n}}
  
, 
  
    
      
        
          x
          
            y
          
        
      
    
    {\displaystyle x^{y}}
  


  
    
      
        sin
        â¡
        x
      
    
    {\displaystyle \sin x}
  
, 
  
    
      
        cos
        â¡
        x
      
    
    {\displaystyle \cos x}
  
, 
  
    
      
        tan
        â¡
        x
      
    
    {\displaystyle \tan x}
  


  
    
      
        arcsin
        â¡
        x
      
    
    {\displaystyle \arcsin x}
  
, 
  
    
      
        arccos
        â¡
        x
      
    
    {\displaystyle \arccos x}
  
, 
  
    
      
        arctan
        â¡
        x
      
    
    {\displaystyle \arctan x}
  
, 
  
    
      
        atan2
        â¡
        (
        y
        ,
        x
        )
      
    
    {\displaystyle \operatorname {atan2} (y,x)}
  


  
    
      
        sinPi
        â¡
        x
        =
        sin
        â¡
        Ï
        x
      
    
    {\displaystyle \operatorname {sinPi} x=\sin \pi x}
  
, 
  
    
      
        cosPi
        â¡
        x
        =
        cos
        â¡
        Ï
        x
      
    
    {\displaystyle \operatorname {cosPi} x=\cos \pi x}
  
, 
  
    
      
        tanPi
        â¡
        x
        =
        tan
        â¡
        Ï
        x
      
    
    {\displaystyle \operatorname {tanPi} x=\tan \pi x}
  
 (see also: Multiples of Ï)

  
    
      
        asinPi
        â¡
        x
        =
        
          
            
              arcsin
              â¡
              x
            
            Ï
          
        
      
    
    {\displaystyle \operatorname {asinPi} x={\frac {\arcsin x}{\pi }}}
  
, 
  
    
      
        acosPi
        â¡
        x
        =
        
          
            
              arccos
              â¡
              x
            
            Ï
          
        
      
    
    {\displaystyle \operatorname {acosPi} x={\frac {\arccos x}{\pi }}}
  
, 
  
    
      
        atanPi
        â¡
        x
        =
        
          
            
              arctan
              â¡
              x
            
            Ï
          
        
      
    
    {\displaystyle \operatorname {atanPi} x={\frac {\arctan x}{\pi }}}
  
, 
  
    
      
        atan2Pi
        â¡
        (
        y
        ,
        x
        )
        =
        
          
            
              atan2
              â¡
              (
              y
              ,
              x
              )
            
            Ï
          
        
      
    
    {\displaystyle \operatorname {atan2Pi} (y,x)={\frac {\operatorname {atan2} (y,x)}{\pi }}}
  
 (see also: Multiples of Ï)

  
    
      
        sinh
        â¡
        x
      
    
    {\displaystyle \sinh x}
  
, 
  
    
      
        cosh
        â¡
        x
      
    
    {\displaystyle \cosh x}
  
, 
  
    
      
        tanh
        â¡
        x
      
    
    {\displaystyle \tanh x}
  


  
    
      
        arsinh
        â¡
        x
      
    
    {\displaystyle \operatorname {arsinh} x}
  
, 
  
    
      
        arcosh
        â¡
        x
      
    
    {\displaystyle \operatorname {arcosh} x}
  
, 
  
    
      
        artanh
        â¡
        x
      
    
    {\displaystyle \operatorname {artanh} x}
  

The asinPi, acosPi and tanPi functions were not part of the IEEE 754-2008 standard because they were deemed less necessary.[40] asinPi, acosPi were mentioned, but this was regarded as an error.[5] All three were added in the 2019 revision.
The recommended operations also include setting and accessing dynamic mode rounding direction,[41] and implementation-defined vector reduction operations such as sum, scaled product, and dot product, whose accuracy is unspecified by the standard.[42]

As of 2019[update], augmented arithmetic operations[43] for the binary formats are also recommended. These operations, specified for addition, subtraction and multiplication, produce a pair of values consisting of a result correctly rounded to nearest in the format and the error term, which is representable exactly in the format. At the time of publication of the standard, no hardware implementations are known, but very similar operations were already implemented in software using well-known algorithms. The history and motivation for their standardization are explained in a background document.[44][45]

As of 2019, the formerly required minNum, maxNum, minNumMag, and maxNumMag in IEEE 754-2008 are now deleted due to their non-associativity. Instead, two sets of new minimum and maximum operations are recommended.[46]  The first set contains  minimum, minimumNumber, maximum and maximumNumber.  The second set contains minimumMagnitude, minimumMagnitudeNumber, maximumMagnitude and maximumMagnitudeNumber.  The history and motivation for this change are explained in a background document.[47]

Expression evaluation[edit]
The standard recommends how language standards should specify the semantics of sequences of operations, and points out the subtleties of literal meanings and optimizations that change the value of a result. By contrast, the previous 1985 version of the standard left aspects of the language interface unspecified, which led to inconsistent behavior between compilers, or different optimization levels in an optimizing compiler.
Programming languages should allow a user to specify a minimum precision for intermediate calculations of expressions for each radix. This is referred to as preferredWidth in the standard, and it should be possible to set this on a per-block basis. Intermediate calculations within expressions should be calculated, and any temporaries saved, using the maximum of the width of the operands and the preferred width if set. Thus, for instance, a compiler targeting x87 floating-point hardware should have a means of specifying that intermediate calculations must use the double-extended format. The stored value of a variable must always be used when evaluating subsequent expressions, rather than any precursor from before rounding and assigning to the variable.

Reproducibility[edit]
The IEEE 754-1985 version of the standard allowed many variations in implementations (such as the encoding of some values and the detection of certain exceptions). IEEE 754-2008 has reduced these allowances, but a few variations still remain (especially for binary formats).  The reproducibility clause recommends that language standards should provide a means to write reproducible programs (i.e., programs that will produce the same result in all implementations of a language) and describes what needs to be done to achieve reproducible results.

Character representation[edit]
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}See also: Floating-point arithmetic Â§Â Binary-to-decimal conversion with minimal number of digits
The standard requires operations to convert between basic formats and external character sequence formats.[48] Conversions to and from a decimal character format are required for all formats. Conversion to an external character sequence must be such that conversion back using round to nearest, ties to even will recover the original number. There is no requirement to preserve the payload of a quiet NaN or signaling NaN, and conversion from the external character sequence may turn a signaling NaN into a quiet NaN.
The original binary value will be preserved by converting to decimal and back again using:[49]

5 decimal digits for binary16,
9 decimal digits for binary32,
17 decimal digits for binary64,
36 decimal digits for binary128.
For other binary formats, the required number of decimal digits is[f]


  
    
      
        1
        +
        â
        p
        
          log
          
            10
          
        
        â¡
        (
        2
        )
        â
        ,
      
    
    {\displaystyle 1+\lceil p\log _{10}(2)\rceil ,}
  

where p is the number of significant bits in the binary format, e.g. 237 bits for binary256.
When using a decimal floating-point format, the decimal representation will be preserved using:

7 decimal digits for decimal32,
16 decimal digits for decimal64,
34 decimal digits for decimal128.
Algorithms, with code, for correctly rounded conversion from binary to decimal and decimal to binary are discussed by Gay,[50] and for testingÂ â  by Paxson and Kahan.[51]

Hexadecimal literals[edit]
The standard recommends providing conversions to and from external hexadecimal-significand character sequences, based on C99's hexadecimal floating point literals. Such a literal consists of an optional sign (+ or -), the indicator "0x", a hexadecimal number with or without a period, an exponent indicator "p", and a decimal exponent with optional sign. The syntax is not case-sensitive.[52] The decimal exponent scales by powers of 2, so for example 0x0.1p-4 is 1/256.[53]

See also[edit]
bfloat16 floating-point format
Binade
Coprocessor
C99 for code examples demonstrating  access and use of IEEE 754 features.
Floating-point arithmetic, for history, design rationale and example usage of IEEE 754 features.
Fixed-point arithmetic, for an alternative approach at computation with rational numbers (especially beneficial when the exponent range is known, fixed, or bound at compile time).
IBM System z9, the first CPU to implement IEEE 754-2008 decimal arithmetic (using hardware microcode).
IBM z10, IBM z196, IBM zEC12, and IBM z13, CPUs that implement IEEE 754-2008  decimal arithmetic fully in hardware.
ISO/IEC 10967, language-independent arithmetic (LIA).
Minifloat, low-precision binary floating-point formats following IEEE 754 principles.
POWER6, POWER7, and POWER8 CPUs that implement IEEE 754-2008 decimal arithmetic fully in hardware.
strictfp, a keyword in the Java programming language that restricts arithmetic to IEEE 754 single and double precision to ensure reproducibility across common hardware platforms.
Table-maker's dilemma for more about the correct rounding of functions.
Standard Apple Numerics Environment
Tapered floating point
Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ For example, if the base is 10, the sign is 1 (indicating negative), the significand is 12345, and the exponent is â3, then the value of the number is (â1)1 Ã 12345 Ã 10â3 = â1 Ã 12345 Ã 0.001 = â12.345.

^ Including the implicit bit (which always equals 1 for normal numbers, and 0 for subnormal numbers. This implicit bit is not stored in memory), but not the sign bit.

^ Contrary to decimal, there is no binary interchange format of 96-bit length. Such a format is still allowed as a non-interchange format, though.

^ The standard recommends 0 for signaling NaNs, 1 for quiet NaNs, so that a signaling NaNs can be quieted by changing only this bit to 1, while the reverse could yield the encoding of an infinity.

^ No flag is raised in certain cases of underflow.

^ As an implementation limit, correct rounding is only guaranteed for the number of decimal digits required plus 3 for the largest supported binary format. For instance, if binary32 is the largest supported binary format, then a conversion from a decimal external sequence with 12 decimal digits is guaranteed to be correctly rounded when converted to binary32; but conversion of a sequence of 13 decimal digits is not; however, the standard recommends that implementations impose no such limit.


References[edit]


^ IEEE 754 2019

^ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}"FW: ISO/IEC/IEEE 60559 (IEEE Std 754-2008)". grouper.ieee.org. Archived from the original on 2017-10-27. Retrieved 2018-04-04.

^ "ISO/IEEE Partner Standards Development Organization (PSDO) Cooperation Agreement" (PDF). 2007-12-19. Retrieved 2021-12-27.

^ "ISO/IEC/IEEE 60559:2011 â Information technology â Microprocessor Systems â Floating-Point arithmetic". www.iso.org. Retrieved 2018-04-04.

^ Jump up to: a b Cowlishaw, Mike (2013-11-13). "IEEE 754-2008 errata". speleotrove.com. Retrieved 2020-01-24.

^ "Revising ANSI/IEEE Std 754-2008". ucbtest.org. Retrieved 2018-04-04.

^ "ISO/IEC 60559:2020 â Information technology â Microprocessor Systems â Floating-Point arithmetic". www.iso.org. Retrieved 2020-10-25.

^ Riedy, E. Jason (2018-06-26), "Plans for IEEE Standard 754 â 2028" (PDF), 25th IEEE Symposium on Computer Arithmetic, Amherst, MA: IEEE{{citation}}:  CS1 maint: date and year (link)

^ IEEE 754 2008, Â§2.1.27.

^ "SpiderMonkey Internals". developer.mozilla.org. Retrieved 2018-03-11.

^ Klemens, Ben (September 2014). 21st Century C: C Tips from the New School. O'Reilly Media, Incorporated. p.Â 160. ISBNÂ 9781491904442. Retrieved 2018-03-11.

^ "zuiderkwast/nanbox: NaN-boxing in C". GitHub. Retrieved 2018-03-11.

^ IEEE 754 2008, Â§3.6.

^ Cowlishaw, Mike. "Decimal Arithmetic Encodings" (PDF). IBM. Retrieved 2015-08-06.

^ IEEE 754 2008, Â§3.7.

^ IEEE 754 2008, Â§3.7 states: "Language standards should define mechanisms supporting extendable precision for each supported radix."

^ IEEE 754 2008, Â§3.7 states: "Language standards or implementations should support an extended precision format that extends the widest basic format that is supported in that radix."

^ IEEE 754 2019, Â§2.1

^ IEEE 754 2008, Â§5.3.1

^ IEEE 754 2008, Â§5.4.1

^ IEEE 754 2008, Â§5.4.2

^ IEEE 754 2008, Â§5.4.3

^ IEEE 754 2008, Â§5.3.2

^ IEEE 754 2008, Â§5.3.3

^ IEEE 754 2008, Â§5.5.1

^ IEEE 754 2008, Â§5.10

^ IEEE 754 2008, Â§5.11

^ IEEE 754 2008, Â§5.7.2

^ IEEE 754 2008, Â§5.7.4

^ IEEE 754 2019, Â§5.11

^ IEEE 754 2019, Â§5.10

^ IEEE 754 2019, Â§5.10

^ Herf, Michael (December 2001). "radix tricks". stereopsisÂ : graphics.

^ "9.4. decimal â Decimal fixed point and floating point arithmetic â Python 3.6.5 documentation". docs.python.org. Retrieved 2018-04-04.

^ "Decimal Arithmetic - Exceptional conditions". speleotrove.com. Retrieved 2018-04-04.

^ IEEE 754 2008, Â§7.2(h)

^ IEEE 754 2019, Â§9.2

^ IEEE 754 2008, Clause 9

^ IEEE 754 2019, Â§9.2.

^ "Re: Missing functions tanPi, asinPi and acosPi". grouper.ieee.org. Archived from the original on 2017-07-06. Retrieved 2018-04-04.

^ IEEE 754 2008, Â§9.3.

^ IEEE 754 2008, Â§9.4.

^ IEEE 754 2019, Â§9.5

^ Riedy, Jason; Demmel, James. "Augmented Arithmetic Operations Proposed for IEEE-754 2018" (PDF). 25th IEEE Symbosium on Computer Arithmetic (ARITH 2018). pp.Â 49â56. Archived (PDF) from the original on 2019-07-23. Retrieved 2019-07-23.

^ "754 Revision targeted for 2019". 754r.ucbtest.org. Retrieved 2019-07-23.

^ IEEE 754 2019, Â§9.6.

^ Chen, David. "The Removal of MinNum and MaxNum Operations from IEEE 754-2019" (PDF). grouper.ieee.org. Retrieved 2020-02-05.

^ IEEE 754 2008, Â§5.12.

^ IEEE 754 2008, Â§5.12.2.

^ Gay, David M. (1990-11-30). "Correctly rounded binary-decimal and decimal-binary conversions". Numerical Analysis Manuscript. Murry Hill, NJ, USA: AT&T Laboratories. 90-10. {{cite journal}}: Cite journal requires |journal= (help)

^ Paxson, Vern; Kahan, William (1991-05-22). "A Program for Testing IEEE DecimalâBinary Conversion". Manuscript. CiteSeerXÂ 10.1.1.144.5889. {{cite journal}}: Cite journal requires |journal= (help)

^ IEEE 754 2008, Â§5.12.3

^ "6.9.3. Hexadecimal floating point literals â Glasgow Haskell Compiler 9.3.20220129 User's Guide". ghc.gitlab.haskell.org. Retrieved 2022-01-29.


Standards[edit]
"IEEE Standard for Binary Floating-Point Arithmetic". ANSI/IEEE Std 754-1985. 1985-10-12. doi:10.1109/IEEESTD.1985.82928.
IEEE Computer Society (2008-08-29). IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2008. IEEE. pp.Â 1â70. doi:10.1109/IEEESTD.2008.4610935. ISBNÂ 978-0-7381-5753-5. IEEE Std 754-2008.
IEEE Computer Society (2019-07-22). IEEE Standard for Floating-Point Arithmetic. IEEE STD 754-2019. IEEE. pp.Â 1â84. doi:10.1109/IEEESTD.2019.8766229. ISBNÂ 978-1-5044-5924-2. IEEE Std 754-2019.
ISO/IEC/IEEE 60559:2011 â Information technology â Microprocessor Systems â Floating-Point arithmetic. Iso.org. June 2011. pp.Â 1â58.
ISO/IEC 60559:2020 â Information technology â Microprocessor Systems â Floating-Point arithmetic. Iso.org. May 2020. pp.Â 1â74.
Secondary references[edit]
Decimal floating-point arithmetic, FAQs, bibliography, and links
Comparing binary floats
IEEE 754 Reference Material
IEEE 854-1987Â â History and minutes
Supplementary readings for IEEE 754. Includes historical perspectives.
Further reading[edit]
Goldberg, David (March 1991). "What Every Computer Scientist Should Know About Floating-Point Arithmetic". ACM Computing Surveys. 23 (1): 5â48. doi:10.1145/103162.103163. S2CIDÂ 222008826. Retrieved 2019-03-08.
Hecker, Chris (February 1996). "Let's Get To The (Floating) Point" (PDF). Game Developer Magazine: 19â24. ISSNÂ 1073-922X.
Severance, Charles (March 1998). "IEEE 754: An Interview with William Kahan" (PDF). IEEE Computer. 31 (3): 114â115. doi:10.1109/MC.1998.660194. S2CIDÂ 33291145. Retrieved 2019-03-08.
Cowlishaw, Mike (June 2003). "Decimal Floating-Point: Algorism for Computers". 16th IEEE Symposium on Computer Arithmetic, 2003. Proceedings (PDF). Proceedings 16th IEEE Symposium on Computer Arithmetic. Los Alamitos, Calif.: IEEE Computer Society. pp.Â 104â111. doi:10.1109/ARITH.2003.1207666. ISBNÂ 978-0-7695-1894-7. S2CIDÂ 18713046. Retrieved 2014-11-14..  (Note: Algorism is not a misspelling of the title; see also algorism.)
Monniaux, David (May 2008). "The pitfalls of verifying floating-point computations". ACM Transactions on Programming Languages and Systems. 30 (3): 1â41. arXiv:cs/0701192. doi:10.1145/1353445.1353446. ISSNÂ 0164-0925. S2CIDÂ 218578808.: A compendium of non-intuitive behaviours of floating-point on popular architectures, with implications for program verification and testing.
Muller, Jean-Michel; Brunie, Nicolas; de Dinechin, Florent; Jeannerod, Claude-Pierre; Joldes, Mioara; LefÃ¨vre, Vincent; Melquiond, Guillaume; Revol, Nathalie; Torres, Serge (2018) [2010]. Handbook of Floating-Point Arithmetic (2Â ed.). BirkhÃ¤user. doi:10.1007/978-3-319-76526-6. ISBNÂ 978-3-319-76525-9.
Overton, Michael L. (2001).  Written at Courant Institute of Mathematical Sciences, New York University, New York, USA. Numerical Computing with IEEE Floating Point Arithmetic (1Â ed.). Philadelphia, USA: SIAM. doi:10.1137/1.9780898718072. ISBNÂ 978-0-89871-482-1. 978-0-89871-571-2, 0-89871-571-7.
Cleve Moler on Floating Point numbers
Beebe, Nelson H. F. (2017-08-22). The Mathematical-Function Computation Handbook - Programming Using the MathCW Portable Software Library (1Â ed.). Salt Lake City, UT, USA: Springer International Publishing AG. doi:10.1007/978-3-319-64110-2. ISBNÂ 978-3-319-64109-6. LCCNÂ 2017947446. S2CIDÂ 30244721.
Hough, David G. (December 2019). "The IEEE Standard 754: One for the History Books". Computer. IEEE. 52 (12): 109â112. doi:10.1109/MC.2019.2926614. S2CIDÂ 208281213.
External links[edit]



The Wikibook Floating Point has a page on the topic of: special numbers specified in the IEEE 754 standard




Wikimedia Commons has media related to IEEE 754.

Kahan on creating IEEE Standard Floating Point. Turing Awardee Clips. 2020-11-16. Archived from the original on 2021-11-08.
Online IEEE 754 binary calculators
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}show.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vteIEEE standardsCurrent
488
730
754
Revision
854
828
829
896
1003
1014
1016
1076
1149.1
1154
1164
1275
1278
1284
1355
1394
1451
1497
1516
1541
1547
1584
1588
1596
1603
1613
1666
1667
1675
1685
1722
1733
1800
1801
1815
1850
1900
1901
1902
1904
1905
2030
2050
11073
12207
14764
16085
16326
29148
42010
802 series802.1
D
p
Q
Qav
Qat
Qay
w
X
ab
ad
AE
ag
ah
ak
aq
AS
ax
az
BA
802.3
-1983
a
b
d
e
i
j
u
x
y
z
ab
ac
ad
ae
af
ah
ak
an
aq
at
av
az
ba
bt
by
bz
cg
802.11
legacy mode
a
b
c
d
e
f
g
h
i
j
k
n (Wi-Fi 4)
p
r
s
u
v
w
y
ac (Wi-Fi 5)
ad
af
ah
ai
ax (Wi-Fi 6)
ay
be (Wi-Fi 7)

.2
.4
.5
.6
.7
.8
.9
.10
.12
.14
.15
.1
.4
.4a
.6
.16
Original Â· d Â· e
.17
.18
.20
.21
.22Proposed
P1363
P1619
P1699
P1823
P1906.1
Superseded
754-1985
830
1219
1233
1362
1364
1471

See also
IEEE Standards Association
Category:IEEE standards

showvteIEC standardsIEC standards
60027
60034
60038
60062
60063
60068
60112
60228
60269
60297
60309
60320
60364
60446
60559
60601
60870
60870-5
60870-6
60906-1
60908
60929
60958
61030
61131
61131-3
61131-9
61158
61162
61334
61355
61360
61400
61499
61508
61511
61784
61850
61851
61883
61960
61968
61970
62014-4
62026
62056
62061
62196
62262
62264
62304
62325
62351
62365
62366
62379
62386
62455
62680
62682
62700
63110
63119
63382
ISO/IEC standards
646
2022
4909
5218
6429
6523
7810
7811
7812
7813
7816
7942
8613
8632
8652
8859
9126
9293
9496
9529
9592
9593
9899
9945
9995
10021
10116
10165
10179
10646
10967
11172
11179
11404
11544
11801
12207
13250
13346
13522-5
13568
13816
13818
14443
14496
14651
14882
15288
15291
15408
15444
15445
15504
15511
15693
15897
15938
16262
17024
17025
18000
18004
18014
19752
19757
19770
19788
20000
20802
21000
21827
23000
23003
23008
23270
23360
24707
24727
24744
24752
26300
27000
27000-series
27002
27040
29110
29119
33001
38500
42010
80000
81346
Related
International Electrotechnical Commission





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=IEEE_754&oldid=1068670959"
		Categories: Computer arithmeticIEEE standardsFloating point typesBinary arithmeticHidden categories: CS1 maint: date and yearCS1 errors: missing periodicalArticles with short descriptionShort description matches WikidataUse dmy dates from May 2019Articles needing more detailed referencesArticles containing potentially dated statements from 2019All articles containing potentially dated statementsCS1 location testCommons category link is on Wikidata
	
