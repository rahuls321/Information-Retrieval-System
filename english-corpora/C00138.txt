
Title:
Linear programming
Text:

		From Wikipedia, the free encyclopedia
		
		
		
		
		Jump to navigation
		Jump to search
		Method to solve some optimization problems
.mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}For the retronym referring to television broadcasting, see Broadcast programming.
  A pictorial representation of a simple linear program with two variables and six inequalities. The set of feasible solutions is depicted in yellow and forms a polygon, a 2-dimensional polytope. The linear cost function is represented by the red line and the arrow: The red line is a level set of the cost function, and the arrow indicates the direction in which we are optimizing.
  A closed feasible region of a problem with three variables is a convex polyhedron. The surfaces giving a fixed value of the objective function are planes (not shown). The linear programming problem is to find a point on the polyhedron that is on the plane with the highest possible value.
Linear programming (LP, also called linear optimization) is a method to achieve the best outcome (such as maximum profit or lowest cost) in a mathematical model whose requirements are represented by linear relationships. Linear programming is a special case of mathematical programming (also known as mathematical optimization).
More formally, linear programming is a technique for the optimization of a linear objective function, subject to linear equality and linear inequality constraints. Its feasible region is a convex polytope, which is a set defined as the intersection of finitely many half spaces, each of which is defined by a linear inequality. Its objective function is a real-valued affine (linear) function defined on this polyhedron. A linear programming algorithm finds a point in the polytope where this function has the smallest (or largest) value if such a point exists.
Linear programs are problems that can be expressed in canonical form as


  
    
      
        
          
            
              
              
                
                  Find a vector
                
              
              
              
                
                  x
                
              
            
            
              
              
                
                  that maximizes
                
              
              
              
                
                  
                    c
                  
                  
                    T
                  
                
                
                  x
                
              
            
            
              
              
                
                  subject to
                
              
              
              
                A
                
                  x
                
                â¤
                
                  b
                
              
            
            
              
              
                
                  and
                
              
              
              
                
                  x
                
                â¥
                
                  0
                
                .
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}&{\text{Find a vector}}&&\mathbf {x} \\&{\text{that maximizes}}&&\mathbf {c} ^{T}\mathbf {x} \\&{\text{subject to}}&&A\mathbf {x} \leq \mathbf {b} \\&{\text{and}}&&\mathbf {x} \geq \mathbf {0} .\end{aligned}}}
  

Here the components of x are the variables to be determined, c and b are given vectors (with 
  
    
      
        
          
            c
          
          
            T
          
        
      
    
    {\displaystyle \mathbf {c} ^{T}}
  
 indicating that the coefficients of c are used as a single-row matrix for the purpose of forming the matrix product), and A is a given matrix. The function whose value is to be maximized or minimized (
  
    
      
        
          x
        
        â¦
        
          
            c
          
          
            T
          
        
        
          x
        
      
    
    {\displaystyle \mathbf {x} \mapsto \mathbf {c} ^{T}\mathbf {x} }
  
 in this case) is called the objective function. The inequalities AxÂ â¤Â b and x â¥ 0 are the constraints which specify a convex polytope over which the objective function is to be optimized. In this context, two vectors are comparable when they have the same dimensions. If every entry in the first is less-than or equal-to the corresponding entry in the second, then it can be said that the first vector is less-than or equal-to the second vector.
Linear programming can be applied to various fields of study. It is widely used in mathematics, and to a lesser extent in business, economics, and for some engineering problems. Industries that use linear programming models include transportation, energy, telecommunications, and manufacturing. It has proven useful in modeling diverse types of problems in planning, routing, scheduling, assignment, and design.

Contents

1 History
2 Uses
3 Standard form

3.1 Example


4 Augmented form (slack form)

4.1 Example


5 Duality
6 Variations

6.1 Covering/packing dualities

6.1.1 Examples




7 Complementary slackness
8 Theory

8.1 Existence of optimal solutions
8.2 Optimal vertices (and rays) of polyhedra


9 Algorithms

9.1 Basis exchange algorithms

9.1.1 Simplex algorithm of Dantzig
9.1.2 Criss-cross algorithm


9.2 Interior point

9.2.1 Ellipsoid algorithm, following Khachiyan
9.2.2 Projective algorithm of Karmarkar
9.2.3 Vaidya's 87 algorithm
9.2.4 Vaidya's 89 algorithm
9.2.5 Input sparsity time algorithms
9.2.6 Current matrix multiplication time algorithm


9.3 Comparison of interior-point methods and simplex algorithms


10 Open problems and recent work
11 Integer unknowns
12 Integral linear programs
13 Solvers and scripting (programming) languages
14 See also
15 Notes
16 References
17 Further reading
18 External links



History[edit]
  Leonid Kantorovich
  John von Neumann
The problem of solving a system of linear inequalities dates back at least as far as Fourier, who in 1827 published a method for solving them,[1] and after whom the method of FourierâMotzkin elimination is named.
In 1939 a linear programming formulation of a problem that is equivalent to the general linear programming problem was given by the Soviet mathematician and economist Leonid Kantorovich, who also proposed a method for solving it.[2] It is a way he developed, during World War II, to plan expenditures and returns in order to reduce costs of the army and to increase losses imposed on the enemy.[citation needed] Kantorovich's work was initially neglected in the USSR.[3] About the same time as Kantorovich, the Dutch-American economist T. C. Koopmans formulated classical economic problems as linear programs. Kantorovich and Koopmans later shared the 1975 Nobel prize in economics.[1] In 1941, Frank Lauren Hitchcock also formulated transportation  problems as linear programs and gave a solution very similar to the later simplex method.[2] Hitchcock had died in 1957 and the Nobel prize is not awarded posthumously.
During 1946â1947, George B. Dantzig independently developed general linear programming formulation to use for planning problems in the US Air Force.[4] In 1947, Dantzig also invented the simplex method that for the first time efficiently tackled the linear programming problem in most cases.[4] When Dantzig arranged a meeting with John von Neumann to discuss his simplex method, Neumann immediately conjectured the theory of duality by realizing that the problem he had been working in game theory was equivalent.[4] Dantzig provided formal proof in an unpublished report "A Theorem on Linear Inequalities" on January 5, 1948.[3] Dantzig's work was made available to public in 1951. In the post-war years, many industries applied it in their daily planning.
Dantzig's original example was to find the best assignment of 70 people to 70 jobs. The computing power required to test all the permutations to select the best assignment is vast; the number of possible configurations exceeds the number of particles in the observable universe. However, it takes only a moment to find the optimum solution by posing the problem as a linear program and applying the simplex algorithm. The theory behind linear programming drastically reduces the number of possible solutions that must be checked.
The linear programming problem was first shown to be solvable in polynomial time by Leonid Khachiyan in 1979,[5] but a larger theoretical and practical breakthrough in the field came in 1984 when Narendra Karmarkar introduced a new interior-point method for solving linear-programming problems.[6]

Uses[edit]
Linear programming is a widely used field of optimization for several reasons. Many practical problems in operations research can be expressed as linear programming problems.[3] Certain special cases of linear programming, such as network flow problems and multicommodity flow problems are considered important enough to have generated much research on specialized algorithms for their solution. A number of algorithms for other types of optimization problems work by solving LP problems as sub-problems. Historically, ideas from linear programming have inspired many of the central concepts of optimization theory, such as duality, decomposition, and the importance of convexity and its generalizations. Likewise, linear programming was heavily used in the early formation of microeconomics and it is currently utilized in company management, such as planning, production, transportation, technology and other issues. Although the modern management issues are ever-changing, most companies would like to maximize profits and minimize costs with limited resources. Google uses linear programming to stabilize YouTube videos.[7] Therefore, many issues can be characterized as linear programming problems.

Standard form[edit]
Standard form is the usual and most intuitive form of describing a linear programming problem. It consists of the following three parts:

A linear function to be maximized
e.g. 
  
    
      
        f
        (
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        )
        =
        
          c
          
            1
          
        
        
          x
          
            1
          
        
        +
        
          c
          
            2
          
        
        
          x
          
            2
          
        
      
    
    {\displaystyle f(x_{1},x_{2})=c_{1}x_{1}+c_{2}x_{2}}
  

Problem constraints of the following form
e.g.

  
    
      
        
          
            
              
                
                  a
                  
                    11
                  
                
                
                  x
                  
                    1
                  
                
                +
                
                  a
                  
                    12
                  
                
                
                  x
                  
                    2
                  
                
              
              
                â¤
                
                  b
                  
                    1
                  
                
              
            
            
              
                
                  a
                  
                    21
                  
                
                
                  x
                  
                    1
                  
                
                +
                
                  a
                  
                    22
                  
                
                
                  x
                  
                    2
                  
                
              
              
                â¤
                
                  b
                  
                    2
                  
                
              
            
            
              
                
                  a
                  
                    31
                  
                
                
                  x
                  
                    1
                  
                
                +
                
                  a
                  
                    32
                  
                
                
                  x
                  
                    2
                  
                
              
              
                â¤
                
                  b
                  
                    3
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{matrix}a_{11}x_{1}+a_{12}x_{2}&\leq b_{1}\\a_{21}x_{1}+a_{22}x_{2}&\leq b_{2}\\a_{31}x_{1}+a_{32}x_{2}&\leq b_{3}\\\end{matrix}}}
  

Non-negative variables
e.g.

  
    
      
        
          
            
              
                
                  x
                  
                    1
                  
                
                â¥
                0
              
            
            
              
                
                  x
                  
                    2
                  
                
                â¥
                0
              
            
          
        
      
    
    {\displaystyle {\begin{matrix}x_{1}\geq 0\\x_{2}\geq 0\end{matrix}}}
  

The problem is usually expressed in matrix form, and then becomes:


  
    
      
        max
        {
        
        
          
            c
          
          
            
              T
            
          
        
        
          x
        
        â£
        
          x
        
        â
        
          
            R
          
          
            n
          
        
        â§
        A
        
          x
        
        â¤
        
          b
        
        â§
        
          x
        
        â¥
        0
        
        }
      
    
    {\displaystyle \max\{\,\mathbf {c} ^{\mathrm {T} }\mathbf {x} \mid \mathbf {x} \in \mathbb {R} ^{n}\land A\mathbf {x} \leq \mathbf {b} \land \mathbf {x} \geq 0\,\}}
  

Other forms, such as minimization problems, problems with constraints on alternative forms, as well as problems involving negative variables can always be rewritten into an equivalent problem in standard form.

Example[edit]
Suppose that a farmer has a piece of farm land, say L km2, to be planted with either wheat or barley or some combination of the two. The farmer has a limited amount of fertilizer, F kilograms, and pesticide, P kilograms. Every square kilometer of wheat requires F1 kilograms of fertilizer and P1 kilograms of pesticide, while every square kilometer of barley requires F2 kilograms of fertilizer and P2 kilograms of pesticide. Let S1 be the selling price of wheat per square kilometer, and S2 be the selling price of barley. If we denote the area of land planted with wheat and barley by x1 and x2 respectively, then profit can be maximized by choosing optimal values for x1 and x2. This problem can be expressed with the following linear programming problem in the standard form:




Maximize: 
  
    
      
        
          S
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          S
          
            2
          
        
        â
        
          x
          
            2
          
        
      
    
    {\displaystyle S_{1}\cdot x_{1}+S_{2}\cdot x_{2}}
  


(maximize the revenue (the total wheat sales plus the total barley sales) â revenue is the "objective function")


Subject to:


  
    
      
        
          x
          
            1
          
        
        +
        
          x
          
            2
          
        
        â¤
        L
      
    
    {\displaystyle x_{1}+x_{2}\leq L}
  


(limit on total area)





  
    
      
        
          F
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          F
          
            2
          
        
        â
        
          x
          
            2
          
        
        â¤
        F
      
    
    {\displaystyle F_{1}\cdot x_{1}+F_{2}\cdot x_{2}\leq F}
  


(limit on fertilizer)





  
    
      
        
          P
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          P
          
            2
          
        
        â
        
          x
          
            2
          
        
        â¤
        P
      
    
    {\displaystyle P_{1}\cdot x_{1}+P_{2}\cdot x_{2}\leq P}
  


(limit on pesticide)





  
    
      
        
          x
          
            1
          
        
        â¥
        0
        ,
        
          x
          
            2
          
        
        â¥
        0
      
    
    {\displaystyle x_{1}\geq 0,x_{2}\geq 0}
  


(cannot plant a negative area).

In matrix form this becomes:

maximize 
  
    
      
        
          
            [
            
              
                
                  
                    S
                    
                      1
                    
                  
                
                
                  
                    S
                    
                      2
                    
                  
                
              
            
            ]
          
        
        
          
            [
            
              
                
                  
                    x
                    
                      1
                    
                  
                
              
              
                
                  
                    x
                    
                      2
                    
                  
                
              
            
            ]
          
        
      
    
    {\displaystyle {\begin{bmatrix}S_{1}&S_{2}\end{bmatrix}}{\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}}}
  

subject to 
  
    
      
        
          
            [
            
              
                
                  1
                
                
                  1
                
              
              
                
                  
                    F
                    
                      1
                    
                  
                
                
                  
                    F
                    
                      2
                    
                  
                
              
              
                
                  
                    P
                    
                      1
                    
                  
                
                
                  
                    P
                    
                      2
                    
                  
                
              
            
            ]
          
        
        
          
            [
            
              
                
                  
                    x
                    
                      1
                    
                  
                
              
              
                
                  
                    x
                    
                      2
                    
                  
                
              
            
            ]
          
        
        â¤
        
          
            [
            
              
                
                  L
                
              
              
                
                  F
                
              
              
                
                  P
                
              
            
            ]
          
        
        ,
        
        
          
            [
            
              
                
                  
                    x
                    
                      1
                    
                  
                
              
              
                
                  
                    x
                    
                      2
                    
                  
                
              
            
            ]
          
        
        â¥
        
          
            [
            
              
                
                  0
                
              
              
                
                  0
                
              
            
            ]
          
        
        .
      
    
    {\displaystyle {\begin{bmatrix}1&1\\F_{1}&F_{2}\\P_{1}&P_{2}\end{bmatrix}}{\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}}\leq {\begin{bmatrix}L\\F\\P\end{bmatrix}},\,{\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}}\geq {\begin{bmatrix}0\\0\end{bmatrix}}.}
  

Augmented form (slack form)[edit]
Linear programming problems can be converted into an augmented form in order to apply the common form of the simplex algorithm. This form introduces non-negative slack variables to replace inequalities with equalities in the constraints. The problems can then be written in the following block matrix form:

Maximize 
  
    
      
        z
      
    
    {\displaystyle z}
  
:

  
    
      
        
          
            [
            
              
                
                  1
                
                
                  â
                  
                    
                      c
                    
                    
                      T
                    
                  
                
                
                  0
                
              
              
                
                  0
                
                
                  
                    A
                  
                
                
                  
                    I
                  
                
              
            
            ]
          
        
        
          
            [
            
              
                
                  z
                
              
              
                
                  
                    x
                  
                
              
              
                
                  
                    s
                  
                
              
            
            ]
          
        
        =
        
          
            [
            
              
                
                  0
                
              
              
                
                  
                    b
                  
                
              
            
            ]
          
        
      
    
    {\displaystyle {\begin{bmatrix}1&-\mathbf {c} ^{T}&0\\0&\mathbf {A} &\mathbf {I} \end{bmatrix}}{\begin{bmatrix}z\\\mathbf {x} \\\mathbf {s} \end{bmatrix}}={\begin{bmatrix}0\\\mathbf {b} \end{bmatrix}}}
  


  
    
      
        
          x
        
        â¥
        0
        ,
        
          s
        
        â¥
        0
      
    
    {\displaystyle \mathbf {x} \geq 0,\mathbf {s} \geq 0}
  

where 
  
    
      
        
          s
        
      
    
    {\displaystyle \mathbf {s} }
  
 are the newly introduced slack variables, 
  
    
      
        
          x
        
      
    
    {\displaystyle \mathbf {x} }
  
 are the decision variables, and 
  
    
      
        z
      
    
    {\displaystyle z}
  
 is the variable to be maximized.

Example[edit]
The example above is converted into the following augmented form:




Maximize: 
  
    
      
        
          S
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          S
          
            2
          
        
        â
        
          x
          
            2
          
        
      
    
    {\displaystyle S_{1}\cdot x_{1}+S_{2}\cdot x_{2}}
  


(objective function)


subject to:


  
    
      
        
          x
          
            1
          
        
        +
        
          x
          
            2
          
        
        +
        
          x
          
            3
          
        
        =
        L
      
    
    {\displaystyle x_{1}+x_{2}+x_{3}=L}
  


(augmented constraint)





  
    
      
        
          F
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          F
          
            2
          
        
        â
        
          x
          
            2
          
        
        +
        
          x
          
            4
          
        
        =
        F
      
    
    {\displaystyle F_{1}\cdot x_{1}+F_{2}\cdot x_{2}+x_{4}=F}
  


(augmented constraint)





  
    
      
        
          P
          
            1
          
        
        â
        
          x
          
            1
          
        
        +
        
          P
          
            2
          
        
        â
        
          x
          
            2
          
        
        +
        
          x
          
            5
          
        
        =
        P
      
    
    {\displaystyle P_{1}\cdot x_{1}+P_{2}\cdot x_{2}+x_{5}=P}
  


(augmented constraint)





  
    
      
        
          x
          
            1
          
        
        ,
        
          x
          
            2
          
        
        ,
        
          x
          
            3
          
        
        ,
        
          x
          
            4
          
        
        ,
        
          x
          
            5
          
        
        â¥
        0.
      
    
    {\displaystyle x_{1},x_{2},x_{3},x_{4},x_{5}\geq 0.}
  


where 
  
    
      
        
          x
          
            3
          
        
        ,
        
          x
          
            4
          
        
        ,
        
          x
          
            5
          
        
      
    
    {\displaystyle x_{3},x_{4},x_{5}}
  
 are (non-negative) slack variables, representing in this example the unused area, the amount of unused fertilizer, and the amount of unused pesticide.
In matrix form this becomes:

Maximize 
  
    
      
        z
      
    
    {\displaystyle z}
  
:

  
    
      
        
          
            [
            
              
                
                  1
                
                
                  â
                  
                    S
                    
                      1
                    
                  
                
                
                  â
                  
                    S
                    
                      2
                    
                  
                
                
                  0
                
                
                  0
                
                
                  0
                
              
              
                
                  0
                
                
                  1
                
                
                  1
                
                
                  1
                
                
                  0
                
                
                  0
                
              
              
                
                  0
                
                
                  
                    F
                    
                      1
                    
                  
                
                
                  
                    F
                    
                      2
                    
                  
                
                
                  0
                
                
                  1
                
                
                  0
                
              
              
                
                  0
                
                
                  
                    P
                    
                      1
                    
                  
                
                
                  
                    P
                    
                      2
                    
                  
                
                
                  0
                
                
                  0
                
                
                  1
                
              
            
            ]
          
        
        
          
            [
            
              
                
                  z
                
              
              
                
                  
                    x
                    
                      1
                    
                  
                
              
              
                
                  
                    x
                    
                      2
                    
                  
                
              
              
                
                  
                    x
                    
                      3
                    
                  
                
              
              
                
                  
                    x
                    
                      4
                    
                  
                
              
              
                
                  
                    x
                    
                      5
                    
                  
                
              
            
            ]
          
        
        =
        
          
            [
            
              
                
                  0
                
              
              
                
                  L
                
              
              
                
                  F
                
              
              
                
                  P
                
              
            
            ]
          
        
        ,
        
        
          
            [
            
              
                
                  
                    x
                    
                      1
                    
                  
                
              
              
                
                  
                    x
                    
                      2
                    
                  
                
              
              
                
                  
                    x
                    
                      3
                    
                  
                
              
              
                
                  
                    x
                    
                      4
                    
                  
                
              
              
                
                  
                    x
                    
                      5
                    
                  
                
              
            
            ]
          
        
        â¥
        0.
      
    
    {\displaystyle {\begin{bmatrix}1&-S_{1}&-S_{2}&0&0&0\\0&1&1&1&0&0\\0&F_{1}&F_{2}&0&1&0\\0&P_{1}&P_{2}&0&0&1\\\end{bmatrix}}{\begin{bmatrix}z\\x_{1}\\x_{2}\\x_{3}\\x_{4}\\x_{5}\end{bmatrix}}={\begin{bmatrix}0\\L\\F\\P\end{bmatrix}},\,{\begin{bmatrix}x_{1}\\x_{2}\\x_{3}\\x_{4}\\x_{5}\end{bmatrix}}\geq 0.}
  

Duality[edit]
Main article: Dual linear program
Every linear programming problem, referred to as a primal problem, can be converted into a dual problem, which provides an upper bound to the optimal value of the primal problem. In matrix form, we can express the primal problem as:

Maximize cTx  subject to Ax â¤ b, x â¥ 0;
with the corresponding symmetric dual problem,
Minimize  bTy  subject to ATy â¥ c, y â¥ 0.
An alternative primal formulation is:

Maximize cTx subject to Ax â¤ b;
with the corresponding asymmetric dual problem,
Minimize  bTy subject to ATy = c, y â¥ 0.
There are two ideas fundamental to duality theory. One is the fact that (for the symmetric dual) the dual of a dual linear program is the original primal linear program. Additionally, every feasible solution for a linear program gives a bound on the optimal value of the objective function of its dual.  The weak duality theorem states that the objective function value of the dual at any feasible solution is always greater than or equal to the objective function value of the primal at any feasible solution. The strong duality theorem states that if the primal has an optimal solution, x*, then the dual also has an optimal solution, y*, and cTx*=bTy*.
A linear program can also be unbounded or infeasible. Duality theory tells us that if the primal is unbounded then the dual is infeasible by the weak duality theorem. Likewise, if the dual is unbounded, then the primal must be infeasible. However, it is possible for both the dual and the primal to be infeasible.  See dual linear program for details and several more examples.

Variations[edit]
Covering/packing dualities[edit]
.mw-parser-output .sidebar{width:22em;float:right;clear:right;margin:0.5em 0 1em 1em;background:#f8f9fa;border:1px solid #aaa;padding:0.2em;text-align:center;line-height:1.4em;font-size:88%;border-collapse:collapse;display:table}body.skin-minerva .mw-parser-output .sidebar{display:table!important;float:right!important;margin:0.5em 0 1em 1em!important}.mw-parser-output .sidebar-subgroup{width:100%;margin:0;border-spacing:0}.mw-parser-output .sidebar-left{float:left;clear:left;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-none{float:none;clear:both;margin:0.5em 1em 1em 0}.mw-parser-output .sidebar-outer-title{padding:0 0.4em 0.2em;font-size:125%;line-height:1.2em;font-weight:bold}.mw-parser-output .sidebar-top-image{padding:0.4em}.mw-parser-output .sidebar-top-caption,.mw-parser-output .sidebar-pretitle-with-top-image,.mw-parser-output .sidebar-caption{padding:0.2em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-pretitle{padding:0.4em 0.4em 0;line-height:1.2em}.mw-parser-output .sidebar-title,.mw-parser-output .sidebar-title-with-pretitle{padding:0.2em 0.8em;font-size:145%;line-height:1.2em}.mw-parser-output .sidebar-title-with-pretitle{padding:0.1em 0.4em}.mw-parser-output .sidebar-image{padding:0.2em 0.4em 0.4em}.mw-parser-output .sidebar-heading{padding:0.1em 0.4em}.mw-parser-output .sidebar-content{padding:0 0.5em 0.4em}.mw-parser-output .sidebar-content-with-subgroup{padding:0.1em 0.4em 0.2em}.mw-parser-output .sidebar-above,.mw-parser-output .sidebar-below{padding:0.3em 0.8em;font-weight:bold}.mw-parser-output .sidebar-collapse .sidebar-above,.mw-parser-output .sidebar-collapse .sidebar-below{border-top:1px solid #aaa;border-bottom:1px solid #aaa}.mw-parser-output .sidebar-navbar{text-align:right;font-size:115%;padding:0 0.4em 0.4em}.mw-parser-output .sidebar-list-title{padding:0 0.4em;text-align:left;font-weight:bold;line-height:1.6em;font-size:105%}.mw-parser-output .sidebar-list-title-c{padding:0 0.4em;text-align:center;margin:0 3.3em}@media(max-width:720px){body.mediawiki .mw-parser-output .sidebar{width:100%!important;clear:both;float:none!important;margin-left:0!important;margin-right:0!important}}Covering/packing-problem pairs
 Covering problems Packing problems Minimum set cover Maximum set packing Minimum edge cover Maximum matching Minimum vertex cover Maximum independent set Bin covering Bin packing Polygon covering Rectangle packing
.mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em}vte
A covering LP is a linear program of the form:

Minimize:  bTy,
subject to: ATy â¥ c, y â¥ 0,
such that the matrix A and the vectors b and c are non-negative.
The dual of a covering LP is a packing LP, a linear program of the form:

Maximize: cTx,
subject to: Ax â¤ b, x â¥ 0,
such that the matrix A and the vectors b and c are non-negative.

Examples[edit]
Covering and packing LPs commonly arise as a linear programming relaxation of a combinatorial problem and are important in the study of approximation algorithms.[8] For example, the LP relaxations of the set packing problem, the independent set problem, and the matching problem are packing LPs. The LP relaxations of the set cover problem, the vertex cover problem, and the dominating set problem are also covering LPs.
Finding a fractional coloring of a graph is another example of a covering LP. In this case, there is one constraint for each vertex of the graph and one variable for each independent set of the graph.

Complementary slackness[edit]
It is possible to obtain an optimal solution to the dual when only an optimal solution to the primal is known using the complementary slackness theorem. The theorem states:
Suppose that xÂ =Â (x1,Â x2,Â ...Â ,Â xn) is primal feasible and that yÂ =Â (y1,Â y2,Â ...Â ,Â ym) is dual feasible. Let (w1,Â w2,Â ...,Â wm) denote the corresponding primal slack variables, and let (z1,Â z2,Â ...Â ,Â zn) denote the corresponding dual slack variables. Then x and y are optimal for their respective problems if and only if

xj zjÂ =Â 0, for jÂ =Â 1,Â 2,Â ...Â ,Â n, and
wi yiÂ =Â 0, for iÂ =Â 1,Â 2,Â ...Â ,Â m.
So if the i-th slack variable of the primal is not zero, then the i-th variable of the dual is equal to zero. Likewise, if the j-th slack variable of the dual is not zero, then the j-th variable of the primal is equal to zero.
This necessary condition for optimality conveys a fairly simple economic principle.  In standard form (when maximizing), if there is slack in a constrained primal resource (i.e., there are "leftovers"), then additional quantities of that resource must have no value.  Likewise, if there is slack in the dual (shadow) price non-negativity constraint requirement, i.e., the price is not zero, then there must be scarce supplies (no "leftovers").

Theory[edit]
Existence of optimal solutions[edit]
Geometrically, the linear constraints define the feasible region, which is a convex polyhedron. A linear function is a convex function, which implies that every local minimum is a global minimum; similarly, a linear function is a concave function, which implies that every local maximum is a global maximum.
An optimal solution need not exist, for two reasons. First, if the constraints are inconsistent, then no feasible solution exists: For instance, the constraints xÂ â¥Â 2 and xÂ â¤Â 1 cannot be satisfied jointly; in this case, we say that the LP is infeasible. Second, when the polytope is unbounded in the direction of the gradient of the objective function (where the gradient of the objective function is the vector of the coefficients of the objective function), then no optimal value is attained because it is always possible to do better than any finite value of the objective function.

Optimal vertices (and rays) of polyhedra[edit]
Otherwise, if a feasible solution exists and if the constraint set is bounded, then the optimum value is always attained on the boundary of the constraint set, by the maximum principle for convex functions (alternatively, by the minimum principle for concave functions) since linear functions are both convex and concave. However, some problems have distinct optimal solutions; for example, the problem of finding a feasible solution to a system of linear inequalities is a linear programming problem in which the objective function is the zero function (that is, the constant function taking the value zero everywhere). For this feasibility problem with the zero-function for its objective-function, if there are two distinct solutions, then every convex combination of the solutions is a solution.
The vertices of the polytope are also called basic feasible solutions. The reason for this choice of name is as follows. Let d denote the number of variables. Then the fundamental theorem of linear inequalities implies (for feasible problems) that for every vertex x* of the LP feasible region, there exists a set of d (or fewer) inequality constraints from the LP such that, when we treat those d constraints as equalities, the unique solution is x*. Thereby we can study these vertices by means of looking at certain subsets of the set of all constraints (a discrete set), rather than the continuum of LP solutions. This principle underlies the simplex algorithm for solving linear programs.

Algorithms[edit]
See also: List of numerical analysis topics Â§Â Linear programming
  In a linear programming problem, a series of linear constraints produces a convex feasible region of possible values for those variables. In the two-variable case this region is in the shape of a convex simple polygon.
Basis exchange algorithms[edit]
Simplex algorithm of Dantzig[edit]
The simplex algorithm, developed by George Dantzig in 1947, solves LP problems by constructing a feasible solution at a vertex of the polytope and then walking along a path on the edges of the polytope to vertices with non-decreasing values of the objective function until an optimum is reached for sure. In many practical problems, "stalling" occurs: many pivots are made with no increase in the objective function.[9][10] In rare practical problems, the usual versions of the simplex algorithm may actually "cycle".[10] To avoid cycles, researchers developed new pivoting rules.[11][12][9][10][13][14]
In practice, the simplex algorithm is quite efficient and can be guaranteed to find the global optimum if certain precautions against cycling are taken. The simplex algorithm has been proved to solve "random" problems efficiently, i.e. in a cubic number of steps,[15] which is similar to its behavior on practical problems.[9][16]
However, the simplex algorithm has poor worst-case behavior: Klee and Minty constructed a family of linear programming problems for which the simplex method takes a number of steps exponential in the problem size.[9][12][13] In fact, for some time it was not known whether the linear programming problem was solvable in polynomial time, i.e. of complexity class P.

Criss-cross algorithm[edit]
Like the simplex algorithm of Dantzig, the criss-cross algorithm is a basis-exchange algorithm that pivots between bases. However, the criss-cross algorithm need not maintain feasibility, but can pivot rather from a feasible basis to an infeasible basis. The criss-cross algorithm does not have polynomial time-complexity for linear programming. Both algorithms visit allÂ 2D corners of a (perturbed) cube in dimensionÂ D, the KleeâMinty cube, in the worst case.[14][17]

Interior point[edit]
In contrast to the simplex algorithm, which finds an optimal solution by traversing the edges between vertices on a polyhedral set, interior-point methods move through the interior of the feasible region.

Ellipsoid algorithm, following Khachiyan[edit]
This is the first worst-case polynomial-time algorithm ever found for linear programming.  To solve a problem which has n variables and can be encoded in L input bits, this algorithm runs in 
  
    
      
        O
        (
        
          n
          
            6
          
        
        L
        )
      
    
    {\displaystyle O(n^{6}L)}
  
 time.[5] Leonid Khachiyan solved this long-standing complexity issue in 1979 with the introduction of the ellipsoid method. The convergence analysis has (real-number) predecessors, notably the iterative methods developed by Naum Z. Shor and the approximation algorithms by Arkadi Nemirovski and D. Yudin.

Projective algorithm of Karmarkar[edit]
Main article: Karmarkar's algorithm
Khachiyan's algorithm was of landmark importance for establishing the polynomial-time solvability of linear programs.  The algorithm was not a computational break-through, as the simplex method is more efficient for all but specially constructed families of linear programs.
However, Khachiyan's algorithm inspired new lines of research in linear programming. In 1984, N. Karmarkar proposed a projective method for linear programming.  Karmarkar's algorithm[6] improved on Khachiyan's[5] worst-case polynomial bound (giving 
  
    
      
        O
        (
        
          n
          
            3.5
          
        
        L
        )
      
    
    {\displaystyle O(n^{3.5}L)}
  
). Karmarkar claimed that his algorithm was much faster in practical LP than the simplex method, a claim that created great interest in interior-point methods.[18] Since Karmarkar's discovery, many interior-point methods have been proposed and analyzed.

Vaidya's 87 algorithm[edit]
In 1987, Vaidya proposed an algorithm that runs in 
  
    
      
        O
        (
        
          n
          
            3
          
        
        )
      
    
    {\displaystyle O(n^{3})}
  
 time.[19]

Vaidya's 89 algorithm[edit]
In 1989, Vaidya developed an algorithm that runs in 
  
    
      
        O
        (
        
          n
          
            2.5
          
        
        )
      
    
    {\displaystyle O(n^{2.5})}
  
 time.[20] Formally speaking, the algorithm takes 
  
    
      
        O
        (
        (
        n
        +
        d
        
          )
          
            1.5
          
        
        n
        L
        )
      
    
    {\displaystyle O((n+d)^{1.5}nL)}
  
 arithmetic operations in the worst case, where 
  
    
      
        d
      
    
    {\displaystyle d}
  
 is the number of constraints, 
  
    
      
        n
      
    
    {\displaystyle n}
  
 is the number of variables, and 
  
    
      
        L
      
    
    {\displaystyle L}
  
 is the number of bits.

Input sparsity time algorithms[edit]
In 2015, Lee and Sidford showed that, it can be solved in 
  
    
      
        
          
            
              O
              ~
            
          
        
        (
        (
        n
        n
        z
        (
        A
        )
        +
        
          d
          
            2
          
        
        )
        
          
            d
          
        
        L
        )
      
    
    {\displaystyle {\tilde {O}}((nnz(A)+d^{2}){\sqrt {d}}L)}
  
 time,[21] where 
  
    
      
        n
        n
        z
        (
        A
        )
      
    
    {\displaystyle nnz(A)}
  
 represents the number of non-zero elements, and it remains taking 
  
    
      
        O
        (
        
          n
          
            2.5
          
        
        L
        )
      
    
    {\displaystyle O(n^{2.5}L)}
  
 in the worst case.

Current matrix multiplication time algorithm[edit]
In 2019, Cohen, Lee and Song improved the running time to 
  
    
      
        
          
            
              O
              ~
            
          
        
        (
        (
        
          n
          
            Ï
          
        
        +
        
          n
          
            2.5
            â
            Î±
            
              /
            
            2
          
        
        +
        
          n
          
            2
            +
            1
            
              /
            
            6
          
        
        )
        L
        )
      
    
    {\displaystyle {\tilde {O}}((n^{\omega }+n^{2.5-\alpha /2}+n^{2+1/6})L)}
  
 time, 
  
    
      
        Ï
      
    
    {\displaystyle \omega }
  
 is the exponent of matrix multiplication and 
  
    
      
        Î±
      
    
    {\displaystyle \alpha }
  
 is the dual exponent of matrix multiplication.[22]  
  
    
      
        Î±
      
    
    {\displaystyle \alpha }
  
 is (roughly) defined to be the largest number such that one can multiply an 
  
    
      
        n
        Ã
        n
      
    
    {\displaystyle n\times n}
  
 matrix by a 
  
    
      
        n
        Ã
        
          n
          
            Î±
          
        
      
    
    {\displaystyle n\times n^{\alpha }}
  
 matrix in 
  
    
      
        O
        (
        
          n
          
            2
          
        
        )
      
    
    {\displaystyle O(n^{2})}
  
 time. In a followup work by Lee, Song and Zhang, they reproduce the same result via a different method.[23] These two algorithms remain 
  
    
      
        
          
            
              O
              ~
            
          
        
        (
        
          n
          
            2
            +
            1
            
              /
            
            6
          
        
        L
        )
      
    
    {\displaystyle {\tilde {O}}(n^{2+1/6}L)}
  
 when 
  
    
      
        Ï
        =
        2
      
    
    {\displaystyle \omega =2}
  
 and 
  
    
      
        Î±
        =
        1
      
    
    {\displaystyle \alpha =1}
  
. The result due to Jiang, Song, Weinstein and Zhang improved 
  
    
      
        
          
            
              O
              ~
            
          
        
        (
        
          n
          
            2
            +
            1
            
              /
            
            6
          
        
        L
        )
      
    
    {\displaystyle {\tilde {O}}(n^{2+1/6}L)}
  
 to 
  
    
      
        
          
            
              O
              ~
            
          
        
        (
        
          n
          
            2
            +
            1
            
              /
            
            18
          
        
        L
        )
      
    
    {\displaystyle {\tilde {O}}(n^{2+1/18}L)}
  
.[24]

Comparison of interior-point methods and simplex algorithms[edit]
The current opinion is that the efficiencies of good implementations of simplex-based methods and interior point methods are similar for routine applications of linear programming. However, for specific types of LP problems, it may be that one type of solver is better than another (sometimes much better), and that the structure of the solutions generated by interior point methods versus simplex-based methods are significantly different with the support set of active variables being typically smaller for the latter one.[25]

Open problems and recent work[edit]
.mw-parser-output .unsolved{margin:0 1em 1em;border:#ccc solid;padding:0.35em 0.35em 0.35em 2.2em;background-color:#eee;background-image:url("https://upload.wikimedia.org/wikipedia/commons/2/26/Question%2C_Web_Fundamentals.svg");background-position:top 50%left 0.35em;background-size:1.5em;background-repeat:no-repeat}@media(min-width:720px){.mw-parser-output .unsolved{float:right;max-width:25%}}.mw-parser-output .unsolved-label{font-weight:bold}.mw-parser-output .unsolved-body{margin:0.35em;font-style:italic}.mw-parser-output .unsolved-more{font-size:smaller}

Unsolved problem in computer science:
Does linear programming admit a strongly polynomial-time algorithm?
(more unsolved problems in computer science)

There are several open problems in the theory of linear programming, the solution of which would represent fundamental breakthroughs in mathematics and potentially major advances in our ability to solve large-scale linear programs.

Does LP admit a strongly polynomial-time algorithm?
Does LP admit a strongly polynomial-time algorithm to find a strictly complementary solution?
Does LP admit a polynomial-time algorithm in the real number (unit cost) model of computation?
This closely related set of problems has been cited by Stephen Smale as among the 18 greatest unsolved problems of the 21st century.  In Smale's words, the third version of the problem "is the main unsolved problem of linear programming theory."  While algorithms exist to solve linear programming in weakly polynomial time, such as the ellipsoid methods and interior-point techniques, no algorithms have yet been found that allow strongly polynomial-time performance in the number of constraints and the number of variables.  The development of such algorithms would be of great theoretical interest, and perhaps allow practical gains in solving large LPs as well.
Although the Hirsch conjecture was recently disproved for higher dimensions, it still leaves the following questions open.

Are there pivot rules which lead to polynomial-time simplex variants?
Do all polytopal graphs have polynomially bounded diameter?
These questions relate to the performance analysis and development of simplex-like methods.  The immense efficiency of the simplex algorithm in practice despite its exponential-time theoretical performance hints that there may be variations of simplex that run in polynomial or even strongly polynomial time.  It would be of great practical and theoretical significance to know whether any such variants exist, particularly as an approach to deciding if LP can be solved in strongly polynomial time.
The simplex algorithm and its variants fall in the family of edge-following algorithms, so named because they solve linear programming problems by moving from vertex to vertex along edges of a polytope.  This means that their theoretical performance is limited by the maximum number of edges between any two vertices on the LP polytope.  As a result, we are interested in knowing the maximum graph-theoretical diameter of polytopal graphs.  It has been proved that all polytopes have subexponential diameter. The recent disproof of the Hirsch conjecture is the first step to prove whether any polytope has superpolynomial diameter. If any such polytopes exist, then no edge-following variant can run in polynomial time. Questions about polytope diameter are of independent mathematical interest.
Simplex pivot methods preserve primal (or dual) feasibility.  On the other hand, criss-cross pivot methods do not preserve (primal or dual) feasibilityÂ â they may visit primal feasible, dual feasible or primal-and-dual infeasible bases in any order.  Pivot methods of this type have been studied since the 1970s.[citation needed]  Essentially, these methods attempt to find the shortest pivot path on the arrangement polytope under the linear programming problem.  In contrast to polytopal graphs, graphs of arrangement polytopes are known to have small diameter, allowing the possibility of strongly polynomial-time criss-cross pivot algorithm without resolving questions about the diameter of general polytopes.[14]

Integer unknowns[edit]
If all of the unknown variables are required to be integers, then the problem is called an integer programming (IP) or integer linear programming (ILP) problem.  In contrast to linear programming, which can be solved efficiently in the worst case, integer programming problems are in many practical situations (those with bounded variables) NP-hard. 0â1 integer programming or binary integer programming (BIP) is the special case of integer programming where variables are required to be 0 or 1 (rather than arbitrary integers). This problem is also classified as NP-hard, and in fact the decision version was one of Karp's 21 NP-complete problems.
If only some of the unknown variables are required to be integers, then the problem is called a mixed integer programming (MIP) problem.  These are generally also NP-hard because they are even more general than ILP programs.
There are however some important subclasses of IP and MIP problems that are efficiently solvable, most notably problems where the constraint matrix is totally unimodular and the right-hand sides of the constraints are integers or â more general â where the system has the total dual integrality (TDI) property.
Advanced algorithms for solving integer linear programs include:

cutting-plane method
Branch and bound
Branch and cut
Branch and price
if the problem has some extra structure, it may be possible to apply delayed column generation.
Such integer-programming algorithms are discussed by Padberg and in Beasley.

Integral linear programs[edit]
Main article: Integral polytope
A linear program in real variables is said to be integral if it has at least one optimal solution which is integral. Likewise, a polyhedron 
  
    
      
        P
        =
        {
        x
        â£
        A
        x
        â¥
        0
        }
      
    
    {\displaystyle P=\{x\mid Ax\geq 0\}}
  
 is said to be integral if for all bounded feasible objective functions c, the linear program 
  
    
      
        {
        max
        c
        x
        â£
        x
        â
        P
        }
      
    
    {\displaystyle \{\max cx\mid x\in P\}}
  
 has an optimum 
  
    
      
        
          x
          
            â
          
        
      
    
    {\displaystyle x^{*}}
  
 with integer coordinates. As observed by Edmonds and Giles in 1977, one can equivalently say that the polyhedron 
  
    
      
        P
      
    
    {\displaystyle P}
  
 is integral if for every bounded feasible integral objective function c, the optimal value of the linear program 
  
    
      
        {
        max
        c
        x
        â£
        x
        â
        P
        }
      
    
    {\displaystyle \{\max cx\mid x\in P\}}
  
 is an integer.
Integral linear programs are of central importance in the polyhedral aspect of combinatorial optimization since they provide an alternate characterization of a problem. Specifically, for any problem, the convex hull of the solutions is an integral polyhedron; if this polyhedron has a nice/compact description, then we can efficiently find the optimal feasible solution under any linear objective. Conversely, if we can prove that a linear programming relaxation is integral, then it is the desired description of the convex hull of feasible (integral) solutions.
Terminology is not consistent throughout the literature, so one should be careful to distinguish the following two concepts,

in an integer linear program, described in the previous section, variables are forcibly constrained to be integers, and this problem is NP-hard in general,
in an integral linear program, described in this section, variables are not constrained to be integers but rather one has proven somehow that the continuous problem always has an integral optimal value (assuming c is integral), and this optimal value may be found efficiently since all polynomial-size linear programs can be solved in polynomial time.
One common way of proving that a polyhedron is integral is to show that it is totally unimodular. There are other general methods including the integer decomposition property and total dual integrality. Other specific well-known integral LPs include the matching polytope, lattice polyhedra, submodular flow polyhedra, and the intersection of two generalized polymatroids/g-polymatroids â e.g. see Schrijver 2003.

Solvers and scripting (programming) languages[edit]
Permissive licenses:




Name

License

Brief info


GLOP
Apache v2
Google's open-source linear programming solver


Pyomo
BSD
An open-source modeling language for large-scale linear, mixed integer and nonlinear optimization


SuanShu
Apache v2
an open-source suite of optimization algorithms to solve LP, QP, SOCP, SDP, SQP in Java

Copyleft (reciprocal) licenses:




Name

License

Brief info


Cassowary constraint solver
LGPL
an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities


CLP
CPL
an LP solver from COIN-OR


glpk
GPL
GNU Linear Programming Kit, an LP/MILP solver with a native C API and numerous (15) third-party wrappers for other languages.  Specialist support for flow networks.  Bundles the AMPL-like GNU MathProg modelling language and translator.


Qoca
GPL
a library for incrementally solving systems of linear equations with various goal functions


R-Project
GPL
a programming language and software environment for statistical computing and graphics

MINTO (Mixed Integer Optimizer, an integer programming solver which uses branch and bound algorithm) has publicly available source code[26] but is not open source.
Proprietary licenses:




Name

Brief info


AIMMS
A modeling language that allows to model linear, mixed integer, and nonlinear optimization models. It also offers a tool for constraint programming. Algorithm, in the forms of heuristics or exact methods, such as Branch-and-Cut or Column Generation, can also be implemented. The tool calls an appropriate solver such as CPLEX or similar, to solve the optimization problem at hand. Academic licenses are free of charge.


AMPL
A popular modeling language for large-scale linear, mixed integer and nonlinear optimisation with a free student limited version available (500 variables and 500 constraints).


APMonitor
API to MATLAB and Python. Solve example Linear Programming (LP) problems through MATLAB, Python, or a web-interface.


CPLEX
Popular solver with an API for several programming languages, and also has a modelling language and works with AIMMS, AMPL, GAMS, MPL, OpenOpt, OPL Development Studio, and TOMLAB. Free for academic use.


Excel Solver Function
A nonlinear solver adjusted to spreadsheets in which function evaluations are based on the recalculating cells. Basic version available as a standard add-on for Excel.


FortMP



GAMS



IMSL Numerical Libraries
Collections of math and statistical algorithms available in C/C++, Fortran, Java and C#/.NET. Optimization routines in the IMSL Libraries include unconstrained, linearly and nonlinearly constrained minimizations, and linear programming algorithms.


LINDO
Solver with an API for large scale optimization of linear, integer, quadratic, conic and general nonlinear programs with stochastic programming extensions. It offers a global optimization procedure for finding guaranteed globally optimal solution to general nonlinear programs with continuous and discrete variables. It also has a statistical sampling API to integrate Monte-Carlo simulations into an optimization framework. It has an algebraic modeling language (LINGO) and allows modeling within a spreadsheet (What'sBest).


Maple
A general-purpose programming-language for symbolic and numerical computing.


MATLAB
A general-purpose and matrix-oriented programming-language for numerical computing.  Linear programming in MATLAB requires the Optimization Toolbox in addition to the base MATLAB product; available routines include INTLINPROG and LINPROG


Mathcad
A WYSIWYG math editor. It has functions for solving both linear and nonlinear optimization problems.


Mathematica
A general-purpose programming-language for mathematics, including symbolic and numerical capabilities.


MOSEK
A solver for large scale optimization with API for several languages (C++,java,.net, Matlab and python).


NAG Numerical Library
A collection of mathematical and statistical routines developed by the Numerical Algorithms Group for multiple programming languages (C, C++, Fortran, Visual Basic, Java and C#) and packages (MATLAB, Excel, R, LabVIEW). The Optimization chapter of the NAG Library includes routines for linear programming problems with both sparse and non-sparse linear constraint matrices, together with routines for the optimization of quadratic, nonlinear, sums of squares of linear or nonlinear functions with nonlinear, bounded or no constraints.  The NAG Library has routines for both local and global optimization, and for continuous or integer problems.


OptimJ
A Java-based modeling language for optimization with a free version available.[27][28]


SAS/OR
A suite of solvers for Linear, Integer, Nonlinear, Derivative-Free, Network, Combinatorial and Constraint Optimization; the Algebraic modeling language OPTMODEL; and a variety of vertical solutions aimed at specific problems/markets, all of which are fully integrated with the SAS System.


SCIP
A general-purpose constraint integer programming solver with an emphasis on MIP. Compatible with Zimpl modelling language. Free for academic use and available in source code.


XPRESS
Solver for large-scale linear programs, quadratic programs, general nonlinear and mixed-integer programs. Has API for several programming languages, also has a modelling language Mosel and works with AMPL, GAMS. Free for academic use.


VisSim
A visual block diagram language for simulation of dynamical systems.

See also[edit]
.mw-parser-output .div-col{margin-top:0.3em;column-width:30em}.mw-parser-output .div-col-small{font-size:90%}.mw-parser-output .div-col-rules{column-rule:1px solid #aaa}.mw-parser-output .div-col dl,.mw-parser-output .div-col ol,.mw-parser-output .div-col ul{margin-top:0}.mw-parser-output .div-col li,.mw-parser-output .div-col dd{page-break-inside:avoid;break-inside:avoid-column}
Convex programming
Dynamic programming
Expected shortfall Â§Â Optimization of expected shortfall
Inputâoutput model
Job shop scheduling
Linear algebra
Linear production game
Linear-fractional programming (LFP)
LP-type problem
Mathematical programming
Nonlinear programming
Oriented matroid
Quadratic programming, a superset of linear programming
Semidefinite programming
Shadow price
Simplex algorithm, used to solve LP problems

Notes[edit]
.mw-parser-output .reflist{font-size:90%;margin-bottom:0.5em;list-style-type:decimal}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman}

^ Jump up to: a b .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}Gerard Sierksma; Yori Zwols (2015). Linear and Integer Optimization: Theory and Practice (3rdÂ ed.). CRC Press. p.Â 1. ISBNÂ 978-1498710169.

^ Jump up to: a b Alexander Schrijver (1998). Theory of Linear and Integer Programming. John Wiley & Sons. pp.Â 221â222. ISBNÂ 978-0-471-98232-6.

^ Jump up to: a b c George B. Dantzig (April 1982). "Reminiscences about the origins of linear programming". Operations Research Letters. 1 (2): 43â48. doi:10.1016/0167-6377(82)90043-8.

^ Jump up to: a b c Dantzig, George B.; Thapa, Mukund Narain (1997). Linear programming. New York: Springer. p.Â xxvii. ISBNÂ 0387948333. OCLCÂ 35318475.

^ Jump up to: a b c Leonid Khachiyan (1979). "A Polynomial Algorithm for Linear Programming". Doklady Akademii Nauk SSSR. 224 (5): 1093â1096.

^ Jump up to: a b Narendra Karmarkar (1984). "A New Polynomial-Time Algorithm for Linear Programming". Combinatorica. 4 (4): 373â395. doi:10.1007/BF02579150. S2CIDÂ 7257867.

^  (PDF) https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37041.pdf. {{cite web}}: Missing or empty |title= (help)

^ Vazirani (2001, p.Â 112)

^ Jump up to: a b c d Dantzig & Thapa (2003) harvtxt error: no target: CITEREFDantzigThapa2003 (help)

^ Jump up to: a b c Padberg (1999) harvtxt error: no target: CITEREFPadberg1999 (help)

^ Bland (1977)

^ Jump up to: a b Murty (1983)

^ Jump up to: a b Papadimitriou & Steiglitz harvtxt error: no target: CITEREFPapadimitriouSteiglitz (help)

^ Jump up to: a b c Fukuda, Komei; Terlaky, TamÃ¡s (1997).  Thomas M. Liebling; Dominique de Werra (eds.). "Criss-cross methods: A fresh view on pivot algorithms". Mathematical Programming, Series B. 79 (1â3): 369â395. CiteSeerXÂ 10.1.1.36.9373. doi:10.1007/BF02614325. MRÂ 1464775. S2CIDÂ 2794181.

^ Borgwardt (1987) harvtxt error: no target: CITEREFBorgwardt1987 (help)

^ Todd (2002) harvtxt error: no target: CITEREFTodd2002 (help)

^ Roos, C. (1990). "An exponential example for Terlaky's pivoting rule for the criss-cross simplex method". Mathematical Programming. Series A. 46 (1): 79â84. doi:10.1007/BF01585729. MRÂ 1045573. S2CIDÂ 33463483.

^ Strang, Gilbert (1 June 1987). "Karmarkar's algorithm and its place in applied mathematics". The Mathematical Intelligencer. 9 (2): 4â10. doi:10.1007/BF03025891. ISSNÂ 0343-6993. MRÂ 0883185. S2CIDÂ 123541868.

^ Vaidya, Pravin M. (1987). An algorithm for linear programming which requires 
  
    
      
        
          O
        
        (
        (
        (
        m
        +
        n
        )
        
          n
          
            2
          
        
        +
        (
        m
        +
        n
        
          )
          
            1.5
          
        
        n
        )
        L
        )
      
    
    {\displaystyle {O}(((m+n)n^{2}+(m+n)^{1.5}n)L)}
  
 arithmetic operations. 28th Annual IEEE Symposium on Foundations of Computer Science. FOCS.

^ Vaidya, Pravin M. (1989). Speeding-up linear programming using fast matrix multiplication. 30th Annual Symposium on Foundations of Computer Science. FOCS. doi:10.1109/SFCS.1989.63499.

^ Lee, Yin-Tat; Sidford, Aaron (2015). Efficient inverse maintenance and faster algorithms for linear programming. FOCS '15 Foundations of Computer Science. arXiv:1503.01752.

^ Cohen, Michael B.; Lee, Yin-Tat; Song, Zhao (2018). Solving Linear Programs in the Current Matrix Multiplication Time. 51st Annual ACM Symposium on the Theory of Computing. STOC'19. arXiv:1810.07896.

^ Lee, Yin-Tat; Song, Zhao; Zhang, Qiuyi (2019). Solving Empirical Risk Minimization in the Current Matrix Multiplication Time. Conference on Learning Theory. COLT'19. arXiv:1905.04447.

^ Jiang, Shunhua; Song, Zhao; Weinstein, Omri; Zhang, Hengjie (2020). Faster Dynamic Matrix Inverse for Faster LPs. arXiv:2004.07470.

^ IllÃ©s, Tibor; Terlaky, TamÃ¡s (2002). "Pivot versus interior point methods: Pros and cons". European Journal of Operational Research. 140 (2): 170. CiteSeerXÂ 10.1.1.646.3539. doi:10.1016/S0377-2217(02)00061-9.

^ "COR@L â Computational Optimization Research At Lehigh". lehigh.edu.

^ http://www.in-ter-trans.eu/resources/Zesch_Hellingrath_2010_Integrated+Production-Distribution+Planning.pdf OptimJ used in an optimization model for mixed-model assembly lines, University of MÃ¼nster

^ http://www.aaai.org/ocs/index.php/AAAI/AAAI10/paper/viewFile/1769/2076 OptimJ used in an Approximate Subgame-Perfect Equilibrium Computation Technique for Repeated Games


References[edit]

Kantorovich, L. V. (1940). "ÐÐ± Ð¾Ð´Ð½Ð¾Ð¼ ÑÑÑÐµÐºÑÐ¸Ð²Ð½Ð¾Ð¼ Ð¼ÐµÑÐ¾Ð´Ðµ ÑÐµÑÐµÐ½Ð¸Ñ Ð½ÐµÐºÐ¾ÑÐ¾ÑÑÑ ÐºÐ»Ð°ÑÑÐ¾Ð² ÑÐºÑÑÑÐµÐ¼Ð°Ð»ÑÐ½ÑÑ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼" [A new method of solving some classes of extremal problems]. Doklady Akad Sci SSSR. 28: 211â214.
F. L. Hitchcock: The distribution of a product from several sources to numerous localities, Journal of Mathematics and Physics, 20, 1941, 224â230.
G.B Dantzig: Maximization of a linear function of variables subject to linear inequalities, 1947. Published pp.Â 339â347 in T.C. Koopmans (ed.):Activity Analysis of Production and Allocation, New York-London 1951 (Wiley & Chapman-Hall)
J. E. Beasley, editor. Advances in Linear and Integer Programming. Oxford Science, 1996. (Collection of surveys)
Bland, Robert G. (1977). "New Finite Pivoting Rules for the Simplex Method". Mathematics of Operations Research. 2 (2): 103â107. doi:10.1287/moor.2.2.103. JSTORÂ 3689647.
Karl-Heinz Borgwardt, The Simplex Algorithm: A Probabilistic Analysis, Algorithms and Combinatorics, Volume 1, Springer-Verlag, 1987. (Average behavior on random problems)
Richard W. Cottle, ed. The Basic George B. Dantzig. Stanford Business Books, Stanford University Press, Stanford, California, 2003. (Selected papers by George B. Dantzig)
George B. Dantzig and Mukund N. Thapa. 1997. Linear programming 1: Introduction. Springer-Verlag.
George B. Dantzig and Mukund N. Thapa. 2003. Linear Programming 2: Theory and Extensions. Springer-Verlag. (Comprehensive, covering e.g. pivoting and interior-point algorithms, large-scale problems, decomposition following DantzigâWolfe and Benders, and introducing stochastic programming.)
Edmonds, Jack; Giles, Rick (1977). "A Min-Max Relation for Submodular Functions on Graphs". Studies in Integer Programming. Annals of Discrete Mathematics. Vol.Â 1. pp.Â 185â204. doi:10.1016/S0167-5060(08)70734-9. ISBNÂ 978-0-7204-0765-5.
Fukuda, Komei; Terlaky, TamÃ¡s (1997).  Thomas M. Liebling; Dominique de Werra (eds.). "Criss-cross methods: A fresh view on pivot algorithms". Mathematical Programming, Series B. 79 (1â3): 369â395. CiteSeerXÂ 10.1.1.36.9373. doi:10.1007/BF02614325. MRÂ 1464775. S2CIDÂ 2794181.
Gondzio, Jacek; Terlaky, TamÃ¡s (1996). "3 A computational view of interior point methods".  In J. E. Beasley (ed.). Advances in linear and integer programming. Oxford Lecture Series in Mathematics and its Applications. Vol.Â 4. New York: Oxford University Press. pp.Â 103â144. MRÂ 1438311. Postscript file at website of Gondzio and at McMaster University website of Terlaky.
Murty, Katta G. (1983). Linear programming. New York: John Wiley & Sons, Inc. pp.Â xix+482. ISBNÂ 978-0-471-09725-9. MRÂ 0720547. (comprehensive reference to classical approaches).
Evar D. Nering and Albert W. Tucker, 1993, Linear Programs and Related Problems, Academic Press. (elementary)
M. Padberg, Linear Optimization and Extensions, Second Edition, Springer-Verlag, 1999. (carefully written account of primal and dual simplex algorithms and projective algorithms, with an introduction to integer linear programming â featuring the traveling salesman problem for Odysseus.)
Christos H. Papadimitriou and Kenneth Steiglitz, Combinatorial Optimization: Algorithms and Complexity, Corrected republication with a new preface, Dover. (computer science)
Michael J. Todd (February 2002). "The many facets of linear programming". Mathematical Programming. 91 (3): 417â436. doi:10.1007/s101070100261. S2CIDÂ 6464735. (Invited survey, from the International Symposium on Mathematical Programming.)
Vanderbei, Robert J. (2001). Linear Programming: Foundations and Extensions. Springer Verlag.
Vazirani, Vijay V. (2001). Approximation Algorithms. Springer-Verlag. ISBNÂ 978-3-540-65367-7. (Computer science)

Further reading[edit]
Library resources about  Linear programming 
Resources in your library


Dmitris Alevras and Manfred W. Padberg, Linear Optimization and Extensions: Problems and Solutions, Universitext, Springer-Verlag, 2001. (Problems from Padberg with solutions.)
Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf (2000). Computational Geometry (2nd revisedÂ ed.). Springer-Verlag. ISBNÂ 978-3-540-65620-3.{{cite book}}:  CS1 maint: multiple names: authors list (link) Chapter 4: Linear Programming: pp.Â 63â94. Describes a randomized half-plane intersection algorithm for linear programming.
Michael R. Garey and David S. Johnson (1979). Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H. Freeman. ISBNÂ 978-0-7167-1045-5. A6: MP1: INTEGER PROGRAMMING, pg.245. (computer science, complexity theory)
GÃ¤rtner, Bernd; MatouÅ¡ek, JiÅÃ­ (2006). Understanding and Using Linear Programming. Berlin: Springer. ISBNÂ 3-540-30697-8. (elementary introduction for mathematicians and computer scientists)
Cornelis Roos, TamÃ¡s Terlaky, Jean-Philippe Vial, Interior Point Methods for Linear Optimization, Second Edition, Springer-Verlag, 2006. (Graduate level)
Alexander Schrijver (2003). Combinatorial optimization: polyhedra and efficiency. Springer.
Alexander Schrijver, Theory of Linear and Integer Programming. John Wiley & sons, 1998, ISBNÂ 0-471-98232-6 (mathematical)
Gerard Sierksma; Yori Zwols (2015). Linear and Integer Optimization: Theory and Practice. CRC Press. ISBNÂ 978-1-498-71016-9.
Gerard Sierksma; Diptesh Ghosh (2010). Networks in Action; Text and Computer Exercises in Network Optimization. Springer. ISBNÂ 978-1-4419-5512-8. (linear optimization modeling)
H. P. Williams, Model Building in Mathematical Programming, Fifth Edition, 2013. (Modeling)
Stephen J. Wright, 1997, Primal-Dual Interior-Point Methods, SIAM. (Graduate level)
Yinyu Ye, 1997, Interior Point Algorithms: Theory and Analysis, Wiley. (Advanced graduate-level)
Ziegler, GÃ¼nter M., Chapters 1â3 and 6â7 in Lectures on Polytopes, Springer-Verlag, New York, 1994. (Geometry)

External links[edit]



Wikimedia Commons has media related to Linear programming.

Guidance On Formulating LP Problems
Mathematical Programming Glossary
The Linear Programming FAQ
Benchmarks For Optimisation Software
.mw-parser-output .navbox{box-sizing:border-box;border:1px solid #a2a9b1;width:100%;clear:both;font-size:88%;text-align:center;padding:1px;margin:1em auto 0}.mw-parser-output .navbox .navbox{margin-top:0}.mw-parser-output .navbox+.navbox,.mw-parser-output .navbox+.navbox-styles+.navbox{margin-top:-1px}.mw-parser-output .navbox-inner,.mw-parser-output .navbox-subgroup{width:100%}.mw-parser-output .navbox-group,.mw-parser-output .navbox-title,.mw-parser-output .navbox-abovebelow{padding:0.25em 1em;line-height:1.5em;text-align:center}.mw-parser-output .navbox-group{white-space:nowrap;text-align:right}.mw-parser-output .navbox,.mw-parser-output .navbox-subgroup{background-color:#fdfdfd}.mw-parser-output .navbox-list{line-height:1.5em;border-color:#fdfdfd}.mw-parser-output .navbox-list-with-group{text-align:left;border-left-width:2px;border-left-style:solid}.mw-parser-output tr+tr>.navbox-abovebelow,.mw-parser-output tr+tr>.navbox-group,.mw-parser-output tr+tr>.navbox-image,.mw-parser-output tr+tr>.navbox-list{border-top:2px solid #fdfdfd}.mw-parser-output .navbox-title{background-color:#ccf}.mw-parser-output .navbox-abovebelow,.mw-parser-output .navbox-group,.mw-parser-output .navbox-subgroup .navbox-title{background-color:#ddf}.mw-parser-output .navbox-subgroup .navbox-group,.mw-parser-output .navbox-subgroup .navbox-abovebelow{background-color:#e6e6ff}.mw-parser-output .navbox-even{background-color:#f7f7f7}.mw-parser-output .navbox-odd{background-color:transparent}.mw-parser-output .navbox .hlist td dl,.mw-parser-output .navbox .hlist td ol,.mw-parser-output .navbox .hlist td ul,.mw-parser-output .navbox td.hlist dl,.mw-parser-output .navbox td.hlist ol,.mw-parser-output .navbox td.hlist ul{padding:0.125em 0}.mw-parser-output .navbox .navbar{display:block;font-size:100%}.mw-parser-output .navbox-title .navbar{float:left;text-align:left;margin-right:0.5em}hidevteOptimization: Algorithms, methods, and heuristicsshowUnconstrained nonlinearFunctions
Golden-section search
Interpolation methods
Line search
NelderâMead method
Successive parabolic interpolation
GradientsConvergence
Trust region
Wolfe conditions
QuasiâNewton
BerndtâHallâHallâHausman
BroydenâFletcherâGoldfarbâShanno and L-BFGS
DavidonâFletcherâPowell
Symmetric rank-one (SR1)
Other methods
Conjugate gradient
GaussâNewton
Gradient
LevenbergâMarquardt
Powell's dog leg method
Truncated Newton
Hessians
Newton's method
showConstrained nonlinearGeneral
Barrier methods
Penalty methods
Differentiable
Augmented Lagrangian methods
Sequential quadratic programming
Successive linear programming
showConvex optimizationConvex minimization
Cutting-plane method
Reduced gradient (FrankâWolfe)
Subgradient method
Linear andquadraticInterior point
Affine scaling
Ellipsoid algorithm of Khachiyan
Projective algorithm of Karmarkar
Basis-exchange
Simplex algorithm of Dantzig
Revised simplex algorithm
Criss-cross algorithm
Principal pivoting algorithm of Lemke
showCombinatorialParadigms
Approximation algorithm
Dynamic programming
Greedy algorithm
Integer programming
Branch and bound/cut
Graph algorithmsMinimum spanning tree
BorÅ¯vka
Prim
Kruskal

    Shortest path
BellmanâFord
SPFA
Dijkstra
FloydâWarshall
Network flows
Dinic
EdmondsâKarp
FordâFulkerson
Pushârelabel maximum flow
showMetaheuristics
Evolutionary algorithm
Hill climbing
Local search
Simulated annealing
Tabu search

Software

showvte Complementarity problems and algorithmsComplementarity Problems
 Linear programming (LP)
 Quadratic programming (QP)
 Linear complementarity problem (LCP)
 Mixed linear (MLCP)
 Mixed (MCP)
 Nonlinear(NCP)
Basis-exchange algorithms
Simplex (Dantzig)
Revised simplex
Criss-cross
Lemke

showAuthority control General
Integrated Authority File (Germany)
National libraries
France (data)
United States
Japan





<img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" />
Retrieved from "https://en.wikipedia.org/w/index.php?title=Linear_programming&oldid=1061252591"
		Categories: Linear programmingConvex optimizationGeometric algorithmsP-complete problemsHidden categories: CS1 errors: missing titleCS1 errors: bare URLHarv and Sfn no-target errorsArticles with short descriptionShort description is different from WikidataAll articles with unsourced statementsArticles with unsourced statements from August 2017Articles with unsourced statements from February 2019CS1 maint: multiple names: authors listCommons category link from WikidataArticles with GND identifiersArticles with BNF identifiersArticles with LCCN identifiersArticles with NDL identifiers
	
